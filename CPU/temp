/* SPIM S20 MIPS simulator.
   Code to manipulate data segment directives.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/data.c 12    11/27/04 8:55p Larus $
*/


#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "mem.h"
#include "sym-tbl.h"
#include "parser.h"
#include "run.h"
#include "data.h"


/* The first 64K of the data segment are dedicated to small data
   segment, which is pointed to by $gp. This register points to the
   middle of the segment, so we can use the full offset field in an
   instruction. */

static mem_addr next_data_pc;	/* Location for next datum in user process */

static mem_addr next_k_data_pc;	/* Location for next datum in kernel */

static int in_kernel = 0;	/* Non-zero => data goes to kdata, not data */

#define DATA_PC (in_kernel ? next_k_data_pc : next_data_pc)

#define BUMP_DATA_PC(DELTA) {if (in_kernel) \
				next_k_data_pc += DELTA; \
				else {next_data_pc += DELTA;}}

static mem_addr next_gp_item_addr; /* Address of next item accessed off $gp */

static int auto_alignment = 1;	/* Non-zero => align literal to natural bound*/



/* If TO_KERNEL is non-zero, subsequent data will be placed in the
   kernel data segment.  If it is zero, data will go to the user's data
   segment.*/

void
user_kernel_data_segment (int to_kernel)
{
    in_kernel = to_kernel;
}


void
end_of_assembly_file ()
{
  in_kernel = 0;
  auto_alignment = 1;
}


/* Set the point at which the first datum is stored to be ADDRESS +
   64K.	 The 64K increment allocates an area pointed to by register
   $gp, which is initialized. */

void
data_begins_at_point (mem_addr addr)
{
  if (bare_machine)
    next_data_pc = addr;
  else
    {
      next_gp_item_addr = addr;
      gp_midpoint = addr + 32*K;
      R[REG_GP] = gp_midpoint;
      next_data_pc = addr + 64 * K;
    }
}


/* Set the point at which the first datum is stored in the kernel's
   data segment. */

void
k_data_begins_at_point (mem_addr addr)
{
    next_k_data_pc = addr;
}


/* Arrange that the next datum is stored on a memory boundary with its
   low ALIGNMENT bits equal to 0.  If argument is 0, disable automatic
   alignment.*/

void
align_data (int alignment)
{
  if (alignment == 0)
    auto_alignment = 0;
  else if (in_kernel)
    {
      next_k_data_pc =
	(next_k_data_pc + (1 << alignment) - 1) & (-1 << alignment);
      fix_current_label_address (next_k_data_pc);
    }
  else
    {
      next_data_pc = (next_data_pc + (1 << alignment) - 1) & (-1 << alignment);
      fix_current_label_address (next_data_pc);
    }
}


void
set_data_alignment (int alignment)
{
  if (auto_alignment)
    align_data (alignment);
}


void
enable_data_alignment ()
{
  auto_alignment = 1;
}


/* Set the location (in user or kernel data space) for the next datum. */

void
set_data_pc (mem_addr addr)
{
  if (in_kernel)
    next_k_data_pc = addr;
  else
    next_data_pc = addr;
}


/* Return the address at which the next datum will be stored.  */

mem_addr
current_data_pc ()
{
  return (DATA_PC);
}


/* Bump the address at which the next data will be stored by VALUE
   bytes. */

void
increment_data_pc (int value)
{
  BUMP_DATA_PC (value);
}


/* Process a .extern NAME SIZE directive. */

void
extern_directive (char *name, int size)
{
  label *sym = make_label_global (name);

  if (!bare_machine
      && size > 0 && size <= SMALL_DATA_SEG_MAX_SIZE
      && next_gp_item_addr + size < gp_midpoint + 32*K)
    {
      sym->gp_flag = 1;
      sym->addr = next_gp_item_addr;
      next_gp_item_addr += size;
    }
}


/* Process a .lcomm NAME SIZE directive. */

void
lcomm_directive (char *name, int size)
{
  if (!bare_machine
      && size > 0 && size <= SMALL_DATA_SEG_MAX_SIZE
      && next_gp_item_addr + size < gp_midpoint + 32*K)
    {
      label *sym = record_label (name, next_gp_item_addr, 1);
      sym->gp_flag = 1;

      next_gp_item_addr += size;
      /* Don't need to initialize since memory starts with 0's */
    }
  else
    {
      (void)record_label (name, next_data_pc, 1);

      for ( ; size > 0; size --)
	{
	  set_mem_byte (DATA_PC, 0);
	  BUMP_DATA_PC(1);
	}
    }
}


/* Process a .ascii STRING or .asciiz STRING directive. */

void
store_string (char *string, int length, int null_terminate)
{
  for ( ; length > 0; string ++, length --) {
    set_mem_byte (DATA_PC, *string);
    BUMP_DATA_PC(1);
  }
  if (null_terminate)
    {
      set_mem_byte (DATA_PC, 0);
      BUMP_DATA_PC(1);
    }
}


/* Process a .byte EXPR directive. */

void
store_byte (int value)
{
  set_mem_byte (DATA_PC, value);
  BUMP_DATA_PC (1);
}


/* Process a .half EXPR directive. */

void
store_half (int value)
{
  if ((DATA_PC & 0x1) != 0)
    {
#ifdef BIGENDIAN
      store_byte ((value >> 8) & 0xff);
      store_byte (value & 0xff);
#else
      store_byte (value & 0xff);
      store_byte ((value >> 8) & 0xff);
#endif
    }
  else
    {
      set_mem_half (DATA_PC, value);
      BUMP_DATA_PC (BYTES_PER_WORD / 2);
    }
}


/* Process a .word EXPR directive. */

void
store_word (int value)
{
  if ((DATA_PC & 0x3) != 0)
    {
#ifdef BIGENDIAN
      store_half ((value >> 16) & 0xffff);
      store_half (value & 0xffff);
#else
      store_half (value & 0xffff);
      store_half ((value >> 16) & 0xffff);
#endif
    }
  else
    {
      set_mem_word (DATA_PC, value);
      BUMP_DATA_PC (BYTES_PER_WORD);
    }
}


/* Process a .double EXPR directive. */

void
store_double (double *value)
{
  if ((DATA_PC & 0x7) != 0)
    {
      store_word (* ((mem_word *) value));
      store_word (* (((mem_word *) value) + 1));
    }
  else
    {
      set_mem_word (DATA_PC, *((mem_word *) value));
      BUMP_DATA_PC (BYTES_PER_WORD);
      set_mem_word (DATA_PC, *(((mem_word *) value) + 1));
      BUMP_DATA_PC (BYTES_PER_WORD);
    }
}


/* Process a .float EXPR directive. */

void
store_float (double *value)
{
  float val = (float)*value;
  float *vp = &val;

  if ((DATA_PC & 0x3) != 0)
    {
      store_half (*(mem_word *) vp & 0xffff);
      store_half ((*(mem_word *) vp >> 16) & 0xffff);
    }
  else
    {
      set_mem_word (DATA_PC, *((mem_word *) vp));
      BUMP_DATA_PC (BYTES_PER_WORD);
    }
}
/* SPIM S20 MIPS simulator.
   Interface to code to manipulate data segment directives.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/data.h 7     2/23/04 4:42a Larus $
*/


/* Exported functions: */

void align_data (int alignment);
mem_addr current_data_pc ();
void data_begins_at_point (mem_addr addr);
void enable_data_alignment ();
void end_of_assembly_file ();
void extern_directive (char *name, int size);
void increment_data_pc (int value);
void k_data_begins_at_point (mem_addr addr);
void lcomm_directive (char *name, int size);
void set_data_alignment (int);
void set_data_pc (mem_addr addr);
void set_text_pc (mem_addr addr);
void store_byte (int value);
void store_double (double *value);
void store_float (double *value);
void store_half (int value);
void store_string (char *string, int length, int null_terminate);
void store_word (int value);
void user_kernel_data_segment (int to_kernel);
/* SPIM S20 MIPS simulator.
  Utilities for displaying machine contents.

  Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
  ALL RIGHTS RESERVED.

  SPIM is distributed under the following conditions:

  You may make copies of SPIM for your own use and modify those copies.

  All copies of SPIM must retain my name and copyright notice.

  You may not sell SPIM or distributed SPIM in conjunction with a
  commerical product or service without the expressed written consent of
  James Larus.

  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE.

  $Header: /Software/SPIM/src/display-utils.c 21    3/27/04 4:50p Larus $
*/


#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "data.h"
#include "reg.h"
#include "mem.h"
#include "run.h"
#include "sym-tbl.h"


static mem_addr format_partial_line (str_stream *ss, mem_addr addr);


/* Write to the stream the contents of the machine's registers, in a wide
   variety of formats. */

void
format_registers (str_stream *ss, int print_gpr_hex, int print_fpr_hex)
{
  int i;
  char *grstr, *fpstr;
  char *grfill, *fpfill;
  static char *reg_names[] =
    {"r0", "at", "v0", "v1", "a0", "a1", "a2", "a3",
     "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7",
     "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
     "t8", "t9", "k0", "k1", "gp", "sp", "s8", "ra"};

  ss_printf (ss, " PC      = %08x   ", PC);
  ss_printf (ss, "EPC     = %08x  ", CP0_EPC);
  ss_printf (ss, " Cause   = %08x  ", CP0_Cause);
  ss_printf (ss, " BadVAddr= %08x\n", CP0_BadVAddr);
  ss_printf (ss, " Status  = %08x   ", CP0_Status);
  ss_printf (ss, "HI      = %08x  ", HI);
  ss_printf (ss, " LO      = %08x\n", LO);

  if (print_gpr_hex)
    grstr = "R%-2d (%2s) = %08x", grfill = "  ";
  else
    grstr = "R%-2d (%2s) = %-10d", grfill = " ";

  ss_printf (ss, "\t\t\t\t General Registers\n");
  for (i = 0; i < 8; i++)
    {
      ss_printf (ss, grstr, i, reg_names[i], R[i]);
      ss_printf (ss, grfill);
      ss_printf (ss, grstr, i+8, reg_names[i+8], R[i+8]);
      ss_printf (ss, grfill);
      ss_printf (ss, grstr, i+16, reg_names[i+16], R[i+16]);
      ss_printf (ss, grfill);
      ss_printf (ss, grstr, i+24, reg_names[i+24], R[i+24]);
      ss_printf (ss, "\n");
    }

  ss_printf (ss, "\n FIR    = %08x   ", FIR);
  ss_printf (ss, " FCSR    = %08x   ", FCSR);
  ss_printf (ss, " FCCR   = %08x  ", FCCR);
  ss_printf (ss, " FEXR    = %08x\n", FEXR);
  ss_printf (ss, " FENR   = %08x\n", FENR);

  ss_printf (ss, "\t\t\t      Double Floating Point Registers\n");

  if (print_fpr_hex)
    fpstr = "FP%-2d=%08x,%08x", fpfill = " ";
  else
    fpstr = "FP%-2d = %#-13.6g", fpfill = " ";

  if (print_fpr_hex)
    for (i = 0; i < 4; i += 1)
      {
	int *r1, *r2;

	/* Use pointers to cast to ints without invoking float->int conversion
	   so we can just print the bits. */
	r1 = (int *)&FPR[i]; r2 = r1 + 1;
	ss_printf (ss, fpstr, 2*i, *r1, *r2);
	ss_printf (ss, fpfill);

	r1 = (int *)&FPR[i+4]; r2 = r1 + 1;
	ss_printf (ss, fpstr, 2*i+8, *r1, *r2);
	ss_printf (ss, fpfill);

	r1 = (int *)&FPR[i+8]; r2 = r1 + 1;
	ss_printf (ss, fpstr, 2*i+16, *r1, *r2);
	ss_printf (ss, fpfill);

	r1 = (int *)&FPR[i+12]; r2 = r1 + 1;
	ss_printf (ss, fpstr, 2*i+24, *r1, *r2);
	ss_printf (ss, "\n");
      }
  else for (i = 0; i < 4; i += 1)
    {
      ss_printf (ss, fpstr, 2*i, FPR[i]);
      ss_printf (ss, fpfill);
      ss_printf (ss, fpstr, 2*i+8, FPR[i+4]);
      ss_printf (ss, fpfill);
      ss_printf (ss, fpstr, 2*i+16, FPR[i+8]);
      ss_printf (ss, fpfill);
      ss_printf (ss, fpstr, 2*i+24, FPR[i+12]);
      ss_printf (ss, "\n");
    }

  if (print_fpr_hex)
    fpstr = "FP%-2d=%08x", fpfill = " ";
  else
    fpstr = "FP%-2d = %#-13.6g", fpfill = " ";

  ss_printf (ss, "\t\t\t      Single Floating Point Registers\n");

  if (print_fpr_hex)
    for (i = 0; i < 8; i += 1)
      {
	/* Use pointers to cast to ints without invoking float->int conversion
	   so we can just print the bits. */
	ss_printf (ss, fpstr, i, *(int *)&FPR_S(i));
	ss_printf (ss, fpfill);

	ss_printf (ss, fpstr, i+8, *(int *)&FPR_S(i+8));
	ss_printf (ss, fpfill);

	ss_printf (ss, fpstr, i+16, *(int *)&FPR_S(i+16));
	ss_printf (ss, fpfill);

	ss_printf (ss, fpstr, i+24, *(int *)&FPR_S(i+24));
	ss_printf (ss, "\n");
      }
  else for (i = 0; i < 8; i += 1)
    {
      ss_printf (ss, fpstr, i, FPR_S(i));
      ss_printf (ss, fpfill);
      ss_printf (ss, fpstr, i+8, FPR_S(i+8));
      ss_printf (ss, fpfill);
      ss_printf (ss, fpstr, i+16, FPR_S(i+16));
      ss_printf (ss, fpfill);
      ss_printf (ss, fpstr, i+24, FPR_S(i+24));
      ss_printf (ss, "\n");
    }
}



/* Write to the stream a printable representation of the instructions in
   memory addresses: FROM...TO. */

void
format_insts (str_stream *ss, mem_addr from, mem_addr to)
{
  instruction *inst;
  mem_addr i;

  for (i = from; i < to; i += 4)
    {
      inst = read_mem_inst (i);
      if (inst != NULL)
	{
	  format_an_inst (ss, inst, i);
	}
    }
}


/* Write to the stream a printable representation of the data and stack
   segments. */

void
format_data_segs (str_stream *ss)
{
  ss_printf (ss, "\tDATA\n");
  format_mem (ss, DATA_BOT, data_top);

  ss_printf (ss, "\n\tSTACK\n");
  format_mem (ss, ROUND_DOWN (R[29], BYTES_PER_WORD), STACK_TOP - 4096);

  ss_printf (ss, "\n\tKERNEL DATA\n");
  format_mem (ss, K_DATA_BOT, k_data_top);
}


#define BYTES_PER_LINE (4*BYTES_PER_WORD)


/* Write to the stream a printable representation of the data in memory
   address: FROM...TO. */

void
format_mem (str_stream *ss, mem_addr from, mem_addr to)
{
  mem_word val;
  mem_addr i = ROUND_UP (from, BYTES_PER_WORD);
  int j;

  i = format_partial_line (ss, i);

  for ( ; i < to; )
    {
      /* Count consecutive zero words */
      for (j = 0; (i + (uint32) j * BYTES_PER_WORD) < to; j += 1)
	{
	  val = read_mem_word (i + (uint32) j * BYTES_PER_WORD);
	  if (val != 0)
	    {
	      break;
	    }
	}

      if (j >= 4)
	{
	  /* Block of 4 or more zero memory words: */
	  ss_printf (ss, "[0x%08x]...[0x%08x]	0x00000000\n",
		     i,
		     i + (uint32) j * BYTES_PER_WORD);

	  i = i + (uint32) j * BYTES_PER_WORD;
	  i = format_partial_line (ss, i);
	}
      else
	{
	  /* Fewer than 4 zero words, print them on a single line: */
	  ss_printf (ss, "[0x%08x]		      ", i);
	  do
	    {
	      val = read_mem_word (i);
	      ss_printf (ss, "  0x%08x", (unsigned int)val);
	      i += BYTES_PER_WORD;
	    }
	  while (i % BYTES_PER_LINE != 0);

	  ss_printf (ss, "\n");
	}
    }
}


/* Write to the stream a text line containing a fraction of a
   quadword. Return the address after the last one written.  */

static mem_addr
format_partial_line (str_stream *ss, mem_addr addr)
{
  if ((addr % BYTES_PER_LINE) != 0)
    {
      ss_printf (ss, "[0x%08x]		      ", addr);

      for (; (addr % BYTES_PER_LINE) != 0; addr += BYTES_PER_WORD)
	{
	  mem_word val = read_mem_word (addr);
	  ss_printf (ss, "  0x%08x", (unsigned int)val);
	}

      ss_printf (ss, "\n");
    }

  return addr;
}
/* SPIM S20 MIPS simulator.
   Dump the op.h file in a readable format to allow checking of encodings.

   Copyright (C) 2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: $
*/



#include <stdio.h>

typedef struct inst_t
{
  char *opcode;

  union
  {
    unsigned int x;
    struct
    {
      unsigned int funct:6;
      unsigned int pad:10;
      unsigned int rt:5;
      unsigned int rs:5;
      unsigned int op:6;
    } f;
  };
} inst;


#define OP(a, b, c, d) {a, d},

inst ops [] = {
#include "op.h"
};


int
compare_ops (inst *p1, inst *p2)
{
  if (p1->f.op < p2->f.op)
    return (-1);
  else if (p1->f.op > p2->f.op)
    return (1);
  else
    {
      if (p1->f.rs < p2->f.rs)
	return (-1);
      else if (p1->f.rs > p2->f.rs)
	return (1);
      else
	{
	  if (p1->f.rt < p2->f.rt)
	    return (-1);
	  else if (p1->f.rt > p2->f.rt)
	    return (1);
	  else
	    {
	      if (p1->f.funct < p2->f.funct)
		return (-1);
	      else if (p1->f.funct > p2->f.funct)
		return (1);
	      else
		return 0;
	    }
	}
    }
}


main (int argc, char** argv)
{
  /* Remove pseudo ops (opcode == -1) from table */
  int empty, next;
  for (empty = 0, next = 0; next < (sizeof(ops) / sizeof(ops[0])); next += 1)
    {
      if (-1 == ops[next].x)
	{
	}
      else
	{
	  ops[empty] = ops[next];
	  empty += 1;
	}
    }

  /* Radix sort instructions by field: op, rs, rt, funct */
  qsort (ops, empty, sizeof(ops[0]), compare_ops);

  /* Print related instructions in groups */
  int i;
  for (i = 0; i < empty; i += 1)
    {
      if (0 < i && ops[i - 1].f.op != ops[i].f.op)
	printf ("\n");

      printf ("%10s  op=%2d  rs=%2d  rt=%2d  funct=%02x      0x%08x\n",
	      ops[i].opcode,
	      ops[i].f.op,
	      ops[i].f.rs,
	      ops[i].f.rt,
	      ops[i].f.funct,
	      ops[i].x);
    }
}
int
main ()
{
  int x = 0x12345678;

  /* Return 1 for little-endian, 0 for big-endian. */
  return (*(char *)&x == 0x78);
}
# SPIM S20 MIPS simulator.
# The default exception handler for spim.
#
# Copyright (C) 1990-2004 James Larus, larus@cs.wisc.edu.
# ALL RIGHTS RESERVED.
#
# SPIM is distributed under the following conditions:
#
# You may make copies of SPIM for your own use and modify those copies.
#
# All copies of SPIM must retain my name and copyright notice.
#
# You may not sell SPIM or distributed SPIM in conjunction with a commerical
# product or service without the expressed written consent of James Larus.
#
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE.
#

# $Header: $


# Define the exception handling code.  This must go first!

	.kdata
__m1_:	.asciiz "  Exception "
__m2_:	.asciiz " occurred and ignored\n"
__e0_:	.asciiz "  [Interrupt] "
__e1_:	.asciiz	"  [TLB]"
__e2_:	.asciiz	"  [TLB]"
__e3_:	.asciiz	"  [TLB]"
__e4_:	.asciiz	"  [Address error in inst/data fetch] "
__e5_:	.asciiz	"  [Address error in store] "
__e6_:	.asciiz	"  [Bad instruction address] "
__e7_:	.asciiz	"  [Bad data address] "
__e8_:	.asciiz	"  [Error in syscall] "
__e9_:	.asciiz	"  [Breakpoint] "
__e10_:	.asciiz	"  [Reserved instruction] "
__e11_:	.asciiz	""
__e12_:	.asciiz	"  [Arithmetic overflow] "
__e13_:	.asciiz	"  [Trap] "
__e14_:	.asciiz	""
__e15_:	.asciiz	"  [Floating point] "
__e16_:	.asciiz	""
__e17_:	.asciiz	""
__e18_:	.asciiz	"  [Coproc 2]"
__e19_:	.asciiz	""
__e20_:	.asciiz	""
__e21_:	.asciiz	""
__e22_:	.asciiz	"  [MDMX]"
__e23_:	.asciiz	"  [Watch]"
__e24_:	.asciiz	"  [Machine check]"
__e25_:	.asciiz	""
__e26_:	.asciiz	""
__e27_:	.asciiz	""
__e28_:	.asciiz	""
__e29_:	.asciiz	""
__e30_:	.asciiz	"  [Cache]"
__e31_:	.asciiz	""
__excp:	.word __e0_, __e1_, __e2_, __e3_, __e4_, __e5_, __e6_, __e7_, __e8_, __e9_
	.word __e10_, __e11_, __e12_, __e13_, __e14_, __e15_, __e16_, __e17_, __e18_,
	.word __e19_, __e20_, __e21_, __e22_, __e23_, __e24_, __e25_, __e26_, __e27_,
	.word __e28_, __e29_, __e30_, __e31_
s1:	.word 0
s2:	.word 0

# This is the exception handler code that the processor runs when
# an exception occurs. It only prints some information about the
# exception, but can server as a model of how to write a handler.
#
# Because we are running in the kernel, we can use $k0/$k1 without
# saving their old values.

# This is the exception vector address for MIPS-1 (R2000):
#	.ktext 0x80000080
# This is the exception vector address for MIPS32:
	.ktext 0x80000180
# Select the appropriate one for the mode in which SPIM is compiled.
	.set noat
	move $k1 $at		# Save $at
	.set at
	sw $v0 s1		# Not re-entrant and we can't trust $sp
	sw $a0 s2		# But we need to use these registers

	mfc0 $k0 $13		# Cause register
	srl $a0 $k0 2		# Extract ExcCode Field
	andi $a0 $a0 0x1f

	# Print information about exception.
	#
	li $v0 4		# syscall 4 (print_str)
	la $a0 __m1_
	syscall

	li $v0 1		# syscall 1 (print_int)
	srl $a0 $k0 2		# Extract ExcCode Field
	andi $a0 $a0 0x1f
	syscall

	li $v0 4		# syscall 4 (print_str)
	andi $a0 $k0 0x3c
	lw $a0 __excp($a0)
	nop
	syscall

	bne $k0 0x18 ok_pc	# Bad PC exception requires special checks
	nop

	mfc0 $a0 $14		# EPC
	andi $a0 $a0 0x3	# Is EPC word-aligned?
	beq $a0 0 ok_pc
	nop

	li $v0 10		# Exit on really bad PC
	syscall

ok_pc:
	li $v0 4		# syscall 4 (print_str)
	la $a0 __m2_
	syscall

	srl $a0 $k0 2		# Extract ExcCode Field
	andi $a0 $a0 0x1f
	bne $a0 0 ret		# 0 means exception was an interrupt
	nop

# Interrupt-specific code goes here!
# Don't skip instruction at EPC since it has not executed.


ret:
# Return from (non-interrupt) exception. Skip offending instruction
# at EPC to avoid infinite loop.
#
	mfc0 $k0 $14		# Bump EPC register
	addiu $k0 $k0 4		# Skip faulting instruction
				# (Need to handle delayed branch case here)
	mtc0 $k0 $14


# Restore registers and reset procesor state
#
	lw $v0 s1		# Restore other registers
	lw $a0 s2

	.set noat
	move $at $k1		# Restore $at
	.set at

	mtc0 $0 $13		# Clear Cause register

	mfc0 $k0 $12		# Set Status register
	ori  $k0 0x1		# Interrupts enabled
	mtc0 $k0 $12

# Return from exception on MIPS32:
	eret

# Return sequence for MIPS-I (R2000):
#	rfe			# Return from exception handler
				# Should be in jr's delay slot
#	jr $k0
#	 nop



# Standard startup code.  Invoke the routine "main" with arguments:
#	main(argc, argv, envp)
#
	.text
	.globl __start
__start:
	lw $a0 0($sp)		# argc
	addiu $a1 $sp 4		# argv
	addiu $a2 $a1 4		# envp
	sll $v0 $a0 2
	addu $a2 $a2 $v0
	jal main
	nop

	li $v0 10
	syscall			# syscall 10 (exit)

	.globl __eoth
__eoth:
/* SPIM S20 MIPS simulator.
   Code to build assembly instructions and resolve symbolic labels.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/inst.c 27    10/19/04 9:22p Larus $
*/

#include <stdio.h>
#include <string.h>

#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "mem.h"
#include "sym-tbl.h"
#include "parser.h"
#include "scanner.h"
#include "y.tab.h"
#include "data.h"


/* Local functions: */

static int compare_pair_value (name_val_val *p1, name_val_val *p2);
static void format_imm_expr (str_stream *ss, imm_expr *expr, int base_reg);
static void i_type_inst_full_word (int opcode, int rt, int rs, imm_expr *expr,
				   int value_known, int32 value);
static void inst_cmp (instruction *inst1, instruction *inst2);
static instruction *make_r_type_inst (int opcode, int rd, int rs, int rt);
static instruction *mk_i_inst (int32 value, int opcode, int rs, int rt, int offset);
static instruction *mk_j_inst (int32, int opcode, int target);
static instruction *mk_r_inst (int32, int opcode, int rs, int rt, int rd, int shamt);
static void produce_immediate (imm_expr *expr, int rt, int value_known, int32 value);
static void sort_a_opcode_table ();
static void sort_i_opcode_table ();
static void sort_name_table ();


/* Local variables: */

/* Non-zero means store instructions in kernel, not user, text segment */

static int in_kernel = 0;

/* Instruction used as breakpoint by SPIM: */

static instruction *break_inst = NULL;


/* Locations for next instruction in user and kernel text segments */

static mem_addr next_text_pc;

static mem_addr next_k_text_pc;


#define INST_PC (in_kernel ? next_k_text_pc : next_text_pc)
#define BUMP_INST_PC(DELTA) {if (in_kernel) \
			       next_k_text_pc += DELTA; \
			       else next_text_pc += DELTA;}



/* Set ADDRESS at which the next instruction is stored. */

void
text_begins_at_point (mem_addr addr)
{
  next_text_pc = addr;
}


void
k_text_begins_at_point (mem_addr addr)
{
  next_k_text_pc = addr;
}


/* Set the location (in user or kernel text space) for the next instruction. */

void
set_text_pc (mem_addr addr)
{
  if (in_kernel)
    next_k_text_pc = addr;
  else
    next_text_pc = addr;
}


/* Return address for next instruction, in appropriate text segment. */

mem_addr
current_text_pc ()
{
  return (INST_PC);
}


/* Increment the current text segement PC. */

void
increment_text_pc (int delta)
{
  BUMP_INST_PC (delta);
}


/* If FLAG is non-zero, next instruction goes to kernel text segment,
   otherwise it goes to user segment. */

void
user_kernel_text_segment (int to_kernel)
{
  in_kernel = to_kernel;
}


/* Store an INSTRUCTION in memory at the next location. */

void
store_instruction (instruction *inst)
{
  if (data_dir)
    {
      store_word (inst_encode (inst));
      free_inst (inst);
    }
  else if (text_dir)
    {
      exception_occurred = 0;
      set_mem_inst (INST_PC, inst);
      if (exception_occurred)
	error ("Invalid address (0x%08x) for instruction\n", INST_PC);
      else
	BUMP_INST_PC (BYTES_PER_WORD);
      if (inst != NULL)
	{
	  SET_SOURCE (inst, source_line ());
	  if (ENCODING (inst) == 0)
	    SET_ENCODING (inst, inst_encode (inst));
	}
    }
}



void
i_type_inst_free (int opcode, int rt, int rs, imm_expr *expr)
{
  i_type_inst (opcode, rt, rs, expr);
  free (expr);
}


/* Produce an immediate instruction with the OPCODE, RT, RS, and IMM
   fields.  NB, because the immediate value may not fit in the field,
   this routine may produce more than one instruction.	On the bare
   machine, we resolve symbolic address, but they better produce values
   that fit into instruction's immediate field. */

void
i_type_inst (int opcode, int rt, int rs, imm_expr *expr)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE (inst, opcode);
  SET_RS (inst, rs);
  SET_RT (inst, rt);
  SET_EXPR (inst, copy_imm_expr (expr));
  if (expr->symbol == NULL || SYMBOL_IS_DEFINED (expr->symbol))
    {
      /* Evaluate the instruction's expression. */
      int32 value = eval_imm_expr (expr);

      if (!bare_machine
	  && (((opcode == Y_ADDI_OP
		|| opcode == Y_ADDIU_OP
		|| opcode == Y_SLTI_OP
		|| opcode == Y_SLTIU_OP)
	       ? ((value & 0xffff8000) != 0
		  && (value & 0xffff8000) != 0xffff8000)
	       : (value & 0xffff0000) != 0)))
	{
	  free_inst (inst);
	  i_type_inst_full_word (opcode, rt, rs, expr, 1, value);
	  return;
	}
      else
	resolve_a_label (expr->symbol, inst);
    }
  else if (bare_machine || expr->bits != 0)
    /* Don't know expression's value, but only needed upper/lower 16-bits
       anyways. */
    record_inst_uses_symbol (inst, expr->symbol);
  else
    {
      /* Don't know the expressions's value and want all of its bits,
	 so assume that it will not produce a small result and generate
	 sequence for 32 bit value. */
      free_inst (inst);

      i_type_inst_full_word (opcode, rt, rs, expr, 0, 0);
      return;
    }

  store_instruction (inst);
}


/* The immediate value for an instruction will (or may) not fit in 16 bits.
   Build the value from its piece with separate instructions. */

static void
i_type_inst_full_word (int opcode, int rt, int rs, imm_expr *expr,
		       int value_known, int32 value)
{
  if (opcode_is_load_store (opcode))
    {
      int offset;

      if (expr->symbol != NULL
	  && expr->symbol->gp_flag
	  && rs == 0
	  && IMM_MIN <= (offset = expr->symbol->addr + expr->offset)
	  && offset <= IMM_MAX)
	{
	  i_type_inst_free (opcode, rt, REG_GP, make_imm_expr (offset, NULL, 0));
	}
      else if (value_known)
	{
	  int low, high;

	  high = (value >> 16) & 0xffff;
	  low = value & 0xffff;

	  if (high != 0 &&
	      !(high == 0xffff && (low & 0x8000)))
	    {
	      /* Some of high 16 bits are non-zero */
	      if (low & 0x8000)
		{
		  /* Adjust high 16, since load sign-extends low 16*/
		  high += 1;
		}

	      i_type_inst_free (Y_LUI_OP, 1, 0, const_imm_expr (high));
	      if (rs != 0)	/* Base register */
		{
		r_type_inst (Y_ADDU_OP, 1, 1, rs);
		}
	      i_type_inst_free (opcode, rt, 1, const_imm_expr (low));
	    }
	  else
	    {
	      /* Special case, sign-extension of low 16 bits sets high to 0xffff */
	      i_type_inst_free (opcode, rt, rs, const_imm_expr (low));
	    }
	}
      else
	{
	  /* Use $at */
	  /* Need to adjust if lower bits are negative */
	  i_type_inst_free (Y_LUI_OP, 1, 0, upper_bits_of_expr (expr));
	  if (rs != 0)		/* Base register */
	    {
	    r_type_inst (Y_ADDU_OP, 1, 1, rs);
	    }
	  i_type_inst_free (opcode, rt, 1, lower_bits_of_expr (expr));
	}
    }
  else if (opcode_is_branch (opcode))
    {
      /* This only allows branches +/- 32K, which is not correct! */
      i_type_inst_free (opcode, rt, rs, lower_bits_of_expr (expr));
    }
  else
    /* Computation instruction */
    {
      int offset;

      if (expr->symbol != NULL
	  && expr->symbol->gp_flag && rs == 0
	  && IMM_MIN <= (offset = expr->symbol->addr + expr->offset)
	  && offset <= IMM_MAX)
	{
	i_type_inst_free ((opcode == Y_LUI_OP ? Y_ADDIU_OP : opcode),
			  rt, REG_GP, make_imm_expr (offset, NULL, 0));
	}
      else
	{
	  /* Use $at */
	  if ((opcode == Y_ORI_OP
	       || opcode == Y_ADDI_OP
	       || opcode == Y_ADDIU_OP
	       || opcode == Y_LUI_OP)
	      && rs == 0)
	    {
	      produce_immediate(expr, rt, value_known, value);
	    }
	  else
	    {
	      produce_immediate(expr, 1, value_known, value);
	      r_type_inst (imm_op_to_op (opcode), rt, rs, 1);
	    }
	}
    }
}


static void
produce_immediate (imm_expr *expr, int rt, int value_known, int32 value)
{
  if (value_known && (value & 0xffff) == 0)
    {
      i_type_inst_free (Y_LUI_OP, rt, 0, upper_bits_of_expr (expr));
    }
  else if (value_known && (value & 0xffff0000) == 0)
    {
      i_type_inst_free (Y_ORI_OP, rt, 0, lower_bits_of_expr (expr));
    }
  else
    {
      i_type_inst_free (Y_LUI_OP, 1, 0, upper_bits_of_expr (expr));
      i_type_inst_free (Y_ORI_OP, rt, 1, lower_bits_of_expr(expr));
    }
}


/* Return a jump-type instruction with the given OPCODE and TARGET
   fields. NB, even the immediate value may not fit in the field, this
   routine will not produce more than one instruction. */

void
j_type_inst (int opcode, imm_expr *target)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE(inst, opcode);
  target->offset = 0;		/* Not PC relative */
  target->pc_relative = 0;
  SET_EXPR (inst, copy_imm_expr (target));
  if (target->symbol == NULL || SYMBOL_IS_DEFINED (target->symbol))
    resolve_a_label (target->symbol, inst);
  else
    record_inst_uses_symbol (inst, target->symbol);
  store_instruction (inst);
}


/* Return a register-type instruction with the given OPCODE, RD, RS, and RT
   fields. */

static instruction *
make_r_type_inst (int opcode, int rd, int rs, int rt)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE(inst, opcode);
  SET_RS(inst, rs);
  SET_RT(inst, rt);
  SET_RD(inst, rd);
  SHAMT(inst) = 0;
  return (inst);
}


/* Return a register-type instruction with the given OPCODE, RD, RS, and RT
   fields. */

void
r_type_inst (int opcode, int rd, int rs, int rt)
{
  store_instruction (make_r_type_inst (opcode, rd, rs, rt));
}


/* Return a register-type instruction with the given OPCODE, FD, FS, and FT
   fields. */

void
r_co_type_inst (int opcode, int fd, int fs, int ft)
{
  instruction *inst = make_r_type_inst (opcode, fs, 0, ft);
  SET_FD (inst, fd);
  store_instruction (inst);
}


/* Return a register-shift instruction with the given OPCODE, RD, RT, and
   SHAMT fields.*/

void
r_sh_type_inst (int opcode, int rd, int rt, int shamt)
{
  instruction *inst = make_r_type_inst (opcode, rd, 0, rt);
  SET_SHAMT(inst, shamt & 0x1f);
  store_instruction (inst);
}


/* Return a floating-point compare instruction with the given OPCODE,
   FS, FT, and CC fields.*/

void
r_cond_type_inst (int opcode, int fs, int ft, int cc)
{
  instruction *inst = make_r_type_inst (opcode, fs, 0, ft);
  SET_FD(inst, cc << 2);
  switch (opcode)
    {
    case Y_C_EQ_D_OP:
    case Y_C_EQ_S_OP:
      {
	SET_COND(inst, COND_EQ);
	break;
      }

    case Y_C_LE_D_OP:
    case Y_C_LE_S_OP:
      {
	SET_COND(inst, COND_IN | COND_LT | COND_EQ);
	break;
      }

    case Y_C_LT_D_OP:
    case Y_C_LT_S_OP:
      {
	SET_COND(inst, COND_IN | COND_LT);
	break;
      }

    case Y_C_NGE_D_OP:
    case Y_C_NGE_S_OP:
      {
	SET_COND(inst, COND_IN | COND_LT | COND_UN);
	break;
      }

    case Y_C_NGLE_D_OP:
    case Y_C_NGLE_S_OP:
      {
	SET_COND(inst, COND_IN | COND_UN);
	break;
      }

    case Y_C_NGL_D_OP:
    case Y_C_NGL_S_OP:
      {
	SET_COND(inst, COND_IN | COND_EQ | COND_UN);
	break;
      }

    case Y_C_NGT_D_OP:
    case Y_C_NGT_S_OP:
      {
	SET_COND(inst, COND_IN | COND_LT | COND_EQ | COND_UN);
	break;
      }

    case Y_C_OLT_D_OP:
    case Y_C_OLT_S_OP:
      {
	SET_COND(inst, COND_LT);
	break;
      }

    case Y_C_OLE_D_OP:
    case Y_C_OLE_S_OP:
      {
	SET_COND(inst, COND_LT | COND_EQ);
	break;
      }

    case Y_C_SEQ_D_OP:
    case Y_C_SEQ_S_OP:
      {
	SET_COND(inst, COND_IN | COND_EQ);
	break;
      }

    case Y_C_SF_D_OP:
    case Y_C_SF_S_OP:
      {
	SET_COND(inst, COND_IN);
	break;
      }

    case Y_C_F_D_OP:
    case Y_C_F_S_OP:
      {
	SET_COND(inst, 0);
	break;
      }

    case Y_C_UEQ_D_OP:
    case Y_C_UEQ_S_OP:
      {
	SET_COND(inst, COND_EQ | COND_UN);
	break;
      }

    case Y_C_ULT_D_OP:
    case Y_C_ULT_S_OP:
      {
	SET_COND(inst, COND_LT | COND_UN);
	break;
      }

    case Y_C_ULE_D_OP:
    case Y_C_ULE_S_OP:
      {
	SET_COND(inst, COND_LT | COND_EQ | COND_UN);
	break;
      }

    case Y_C_UN_D_OP:
    case Y_C_UN_S_OP:
      {
	SET_COND(inst, COND_UN);
	break;
      }
    }
  store_instruction (inst);
}


/* Make and return a deep copy of INST. */

instruction *
copy_inst (instruction *inst)
{
  instruction *new_inst = (instruction *) xmalloc (sizeof (instruction));

  *new_inst = *inst;
  /*memcpy ((void*)new_inst, (void*)inst , sizeof (instruction));*/
  SET_EXPR (new_inst, copy_imm_expr (EXPR (inst)));
  return (new_inst);
}


void
free_inst (instruction *inst)
{
  if (inst != break_inst)
    /* Don't free the breakpoint insructions since we only have one. */
    {
      if (EXPR (inst))
	free (EXPR (inst));
      free (inst);
    }
}



/* Maintain a table mapping from opcode to instruction name and
   instruction type.

   Table must be sorted before first use since its entries are
   alphabetical on name, not ordered by opcode. */


/* Sort all instruction table before first use. */

void
initialize_inst_tables ()
{
	sort_name_table ();
	sort_i_opcode_table ();
	sort_a_opcode_table ();
}


/* Map from opcode -> name/type. */

static name_val_val name_tbl [] = {
#undef OP
#define OP(NAME, OPCODE, TYPE, R_OPCODE) {NAME, OPCODE, TYPE},
#include "op.h"
};


/* Sort the opcode table on their key (the opcode value). */

static void
sort_name_table ()
{
  qsort (name_tbl,
	 sizeof (name_tbl) / sizeof (name_val_val),
	 sizeof (name_val_val),
	 (QSORT_FUNC) compare_pair_value);
}


/* Compare the VALUE1 field of two NAME_VAL_VAL entries in the format
   required by qsort. */

static int
compare_pair_value (name_val_val *p1, name_val_val *p2)
{
  if (p1->value1 < p2->value1)
    return (-1);
  else if (p1->value1 > p2->value1)
    return (1);
  else
    return (0);
}


/* Print the instruction stored at the memory ADDRESS. */

void
print_inst (mem_addr addr)
{
  instruction *inst;
  static str_stream ss;

  exception_occurred = 0;
  inst = read_mem_inst (addr);

  if (exception_occurred)
    {
      error ("Can't print instruction not in text segment (0x%08x)\n", addr);
      return;
    }

  ss_clear (&ss);
  format_an_inst (&ss, inst, addr);
  write_output (message_out, ss_to_string (&ss));
}


void
format_an_inst (str_stream *ss, instruction *inst, mem_addr addr)
{
  name_val_val *entry;
  int line_start = ss_length (ss);

  if (inst_is_breakpoint (addr))
    {
      delete_breakpoint (addr);
      ss_printf (ss, "*");
      format_an_inst (ss, read_mem_inst (addr), addr);
      add_breakpoint (addr);
      return;
    }

  ss_printf (ss, "[0x%08x]\t", addr);
  if (inst == NULL)
    {
      ss_printf (ss, "<none>\n");
      return;
    }

  entry = map_int_to_name_val_val (name_tbl,
				   sizeof (name_tbl) / sizeof (name_val_val),
				   OPCODE (inst));
  if (entry == NULL)
    {
      ss_printf (ss, "<unknown instruction %d>\n", OPCODE (inst));
      return;
    }

  ss_printf (ss, "0x%08x  %s", (uint32)ENCODING (inst), entry->name);
  switch (entry->value2)
    {
    case BC_TYPE_INST:
      ss_printf (ss, "%d %d", CC (inst), IDISP (inst));
      break;

    case B1_TYPE_INST:
      ss_printf (ss, " $%d %d", RS (inst), IDISP (inst));
      break;

    case I1s_TYPE_INST:
      ss_printf (ss, " $%d, %d", RS (inst), IMM (inst));
      break;

    case I1t_TYPE_INST:
      ss_printf (ss, " $%d, %d", RT (inst), IMM (inst));
      break;

    case I2_TYPE_INST:
      ss_printf (ss, " $%d, $%d, %d", RT (inst), RS (inst), IMM (inst));
      break;

    case B2_TYPE_INST:
      ss_printf (ss, " $%d, $%d, %d", RS (inst), RT (inst), IDISP (inst));
      break;

    case I2a_TYPE_INST:
      ss_printf (ss, " $%d, %d($%d)", RT (inst), IMM (inst), BASE (inst));
      break;

    case R1s_TYPE_INST:
      ss_printf (ss, " $%d", RS (inst));
      break;

    case R1d_TYPE_INST:
      ss_printf (ss, " $%d", RD (inst));
      break;

    case R2td_TYPE_INST:
      ss_printf (ss, " $%d, $%d", RT (inst), RD (inst));
      break;

    case R2st_TYPE_INST:
      ss_printf (ss, " $%d, $%d", RS (inst), RT (inst));
      break;

    case R2ds_TYPE_INST:
      ss_printf (ss, " $%d, $%d", RD (inst), RS (inst));
      break;

    case R2sh_TYPE_INST:
      if (ENCODING (inst) == 0)
	{
	  ss_erase (ss, 3);	/* zap sll */
	  ss_printf (ss, "nop");
	}
      else
	ss_printf (ss, " $%d, $%d, %d", RD (inst), RT (inst), SHAMT (inst));
      break;

    case R3_TYPE_INST:
      ss_printf (ss, " $%d, $%d, $%d", RD (inst), RS (inst), RT (inst));
      break;

    case R3sh_TYPE_INST:
      ss_printf (ss, " $%d, $%d, $%d", RD (inst), RT (inst), RS (inst));
      break;

    case FP_I2a_TYPE_INST:
      ss_printf (ss, " $f%d, %d($%d)", FT (inst), IMM (inst), BASE (inst));
      break;

    case FP_R2ds_TYPE_INST:
      ss_printf (ss, " $f%d, $f%d", FD (inst), FS (inst));
      break;

    case FP_R2ts_TYPE_INST:
      ss_printf (ss, " $%d, $f%d", RT (inst), FS (inst));
      break;

    case FP_CMP_TYPE_INST:
      ss_printf (ss, " $f%d, $f%d", FS (inst), FT (inst));
      break;

    case FP_R3_TYPE_INST:
      ss_printf (ss, " $f%d, $f%d, $f%d", FD (inst), FS (inst), FT (inst));
      break;

    case FP_MOVC_TYPE_INST:
      if (OPCODE (inst) == Y_MOVF_OP)
	ss_printf (ss, " $%d, $%d, %d", FD (inst), FS (inst), CC (inst));
      else
	ss_printf (ss, " $f%d, $f%d, %d", FD (inst), FS (inst), CC (inst));
      break;

    case J_TYPE_INST:
      ss_printf (ss, " 0x%08x", TARGET (inst) << 2);
      break;

    case NOARG_TYPE_INST:
      break;

    default:
      fatal_error ("Unknown instruction type in print_inst\n");
    }

  if (EXPR (inst) != NULL && EXPR (inst)->symbol != NULL)
    {
      ss_printf (ss, " [");
      if (opcode_is_load_store (OPCODE (inst)))
	format_imm_expr (ss, EXPR (inst), BASE (inst));
      else
	format_imm_expr (ss, EXPR (inst), -1);
      ss_printf (ss, "]");
    }

  if (SOURCE (inst) != NULL)
    {
      /* Comment is source line text of current line. */
      int gap_length = 57 - (ss_length (ss) - line_start);
      for ( ; 0 < gap_length; gap_length -= 1)
	{
	  ss_printf (ss, " ");
	}

      ss_printf (ss, "; ");
      ss_printf (ss, "%s", SOURCE (inst));
    }

  ss_printf (ss, "\n");
}



/* Return non-zero if SPIM OPCODE (e.g. Y_...) represents a conditional
   branch. */

int
opcode_is_branch (int opcode)
{
  switch (opcode)
    {
    case Y_BC1F_OP:
    case Y_BC1FL_OP:
    case Y_BC1T_OP:
    case Y_BC1TL_OP:
    case Y_BC2F_OP:
    case Y_BC2FL_OP:
    case Y_BC2T_OP:
    case Y_BC2TL_OP:
    case Y_BEQ_OP:
    case Y_BEQL_OP:
    case Y_BEQZ_POP:
    case Y_BGE_POP:
    case Y_BGEU_POP:
    case Y_BGEZ_OP:
    case Y_BGEZAL_OP:
    case Y_BGEZALL_OP:
    case Y_BGEZL_OP:
    case Y_BGT_POP:
    case Y_BGTU_POP:
    case Y_BGTZ_OP:
    case Y_BGTZL_OP:
    case Y_BLE_POP:
    case Y_BLEU_POP:
    case Y_BLEZ_OP:
    case Y_BLEZL_OP:
    case Y_BLT_POP:
    case Y_BLTU_POP:
    case Y_BLTZ_OP:
    case Y_BLTZAL_OP:
    case Y_BLTZALL_OP:
    case Y_BLTZL_OP:
    case Y_BNE_OP:
    case Y_BNEL_OP:
    case Y_BNEZ_POP:
      return (1);

    default:
      return (0);
    }
}


/* Return non-zero if SPIM OPCODE represents a nullified (e.g., Y_...L_OP)
   conditional branch. */

int
opcode_is_nullified_branch (int opcode)
{
  switch (opcode)
    {
    case Y_BC1FL_OP:
    case Y_BC1TL_OP:
    case Y_BC2FL_OP:
    case Y_BC2TL_OP:
    case Y_BEQL_OP:
    case Y_BGEZALL_OP:
    case Y_BGEZL_OP:
    case Y_BGTZL_OP:
    case Y_BLEZL_OP:
    case Y_BLTZALL_OP:
    case Y_BLTZL_OP:
    case Y_BNEL_OP:
      return (1);

    default:
      return (0);
    }
}


/* Return non-zero if SPIM OPCODE (e.g. Y_...) represents a conditional
   branch on a true condition. */

int
opcode_is_true_branch (int opcode)
{
  switch (opcode)
    {
    case Y_BC1T_OP:
    case Y_BC1TL_OP:
    case Y_BC2T_OP:
    case Y_BC2TL_OP:
      return (1);

    default:
      return (0);
    }
}


/* Return non-zero if SPIM OPCODE (e.g. Y_...) is a direct unconditional
   branch (jump). */

int
opcode_is_jump (int opcode)
{
  switch (opcode)
    {
    case Y_J_OP:
    case Y_JAL_OP:
      return (1);

    default:
      return (0);
    }
}

/* Return non-zero if SPIM OPCODE (e.g. Y_...) is a load or store. */

int
opcode_is_load_store (int opcode)
{
  switch (opcode)
    {
    case Y_LB_OP:
    case Y_LBU_OP:
    case Y_LH_OP:
    case Y_LHU_OP:
    case Y_LL_OP:
    case Y_LDC1_OP:
    case Y_LDC2_OP:
    case Y_LW_OP:
    case Y_LWC1_OP:
    case Y_LWC2_OP:
    case Y_LWL_OP:
    case Y_LWR_OP:
    case Y_SB_OP:
    case Y_SC_OP:
    case Y_SH_OP:
    case Y_SDC1_OP:
    case Y_SDC2_OP:
    case Y_SW_OP:
    case Y_SWC1_OP:
    case Y_SWC2_OP:
    case Y_SWL_OP:
    case Y_SWR_OP:
      return (1);

    default:
      return (0);
    }
}


/* Return non-zero if a breakpoint is set at ADDR. */

int
inst_is_breakpoint (mem_addr addr)
{
  if (break_inst == NULL)
    break_inst = make_r_type_inst (Y_BREAK_OP, 1, 0, 0);

  return (read_mem_inst (addr) == break_inst);
}


/* Set a breakpoint at ADDR and return the old instruction.  If the
   breakpoint cannot be set, return NULL. */

instruction *
set_breakpoint (mem_addr addr)
{
  instruction *old_inst;

  if (break_inst == NULL)
    break_inst = make_r_type_inst (Y_BREAK_OP, 1, 0, 0);

  exception_occurred = 0;
  old_inst = read_mem_inst (addr);
  if (old_inst == break_inst)
    return (NULL);

  set_mem_inst (addr, break_inst);
  if (exception_occurred)
    return (NULL);
  else
    return (old_inst);
}



/* An immediate expression has the form: SYMBOL +/- IOFFSET, where either
   part may be omitted. */

/* Make and return a new immediate expression */

imm_expr *
make_imm_expr (int offs, char *sym, int pc_rel)
{
  imm_expr *expr = (imm_expr *) xmalloc (sizeof (imm_expr));

  expr->offset = offs;
  expr->bits = 0;
  expr->pc_relative = (short)pc_rel;
  if (sym != NULL)
    expr->symbol = lookup_label (sym);
  else
    expr->symbol = NULL;
  return (expr);
}


/* Return a shallow copy of the EXPRESSION. */

imm_expr *
copy_imm_expr (imm_expr *old_expr)
{
  imm_expr *expr = (imm_expr *) xmalloc (sizeof (imm_expr));

  *expr = *old_expr;
  /*memcpy ((void*)expr, (void*)old_expr, sizeof (imm_expr));*/
  return (expr);
}


/* Return a shallow copy of an EXPRESSION that only uses the upper
   sixteen bits of the expression's value. */

imm_expr *
upper_bits_of_expr (imm_expr *old_expr)
{
  imm_expr *expr = copy_imm_expr (old_expr);

  expr->bits = 1;
  return (expr);
}


/* Return a shallow copy of the EXPRESSION that only uses the lower
   sixteen bits of the expression's value. */

imm_expr *
lower_bits_of_expr (imm_expr *old_expr)
{
  imm_expr *expr = copy_imm_expr (old_expr);

  expr->bits = -1;
  return (expr);
}


/* Return an instruction expression for a constant VALUE. */

imm_expr *
const_imm_expr (int32 value)
{
  return (make_imm_expr (value, NULL, 0));
}


/* Return a shallow copy of the EXPRESSION with the offset field
   incremented by the given amount. */

imm_expr *
incr_expr_offset (imm_expr *expr, int32 value)
{
  imm_expr *new_expr = copy_imm_expr (expr);

  new_expr->offset += value;
  return (new_expr);
}


/* Return the value of the EXPRESSION. */

int32
eval_imm_expr (imm_expr *expr)
{
  int32 value;

  if (expr->symbol == NULL)
    value = expr->offset;
  else if (SYMBOL_IS_DEFINED (expr->symbol))
    {
      value = expr->offset + expr->symbol->addr;
      if (expr->symbol->gp_flag) /* Addr is offset from $gp */
	value += gp_midpoint;
    }
  else
    {
      error ("Evaluated undefined symbol: %s\n", expr->symbol->name);
      value = 0;
    }
  if (expr->bits > 0)
    return ((value >> 16) & 0xffff);  /* Use upper bits of result */
  else if (expr->bits < 0)
    return (value & 0xffff);	      /* Use lower bits */
  else
    return (value);
}


/* Print the EXPRESSION. */

static void
format_imm_expr (str_stream *ss, imm_expr *expr, int base_reg)
{
  if (expr->symbol != NULL)
    {
      ss_printf (ss, "%s", expr->symbol->name);
    }

  if (expr->pc_relative)
    ss_printf (ss, "-0x%08x", (unsigned int)-expr->offset);
  else if (expr->offset < -10)
    ss_printf (ss, "-%d (-0x%08x)", -expr->offset, (unsigned int)-expr->offset);
  else if (expr->offset > 10)
    ss_printf (ss, "+%d (0x%08x)", expr->offset, (unsigned int)expr->offset);

  if (base_reg != -1 && expr->symbol != NULL &&
      (expr->offset > 10 || expr->offset < -10))
    {
      if (expr->offset == 0 && base_reg != 0)
	ss_printf (ss, "+0");

      if (expr->offset != 0 || base_reg != 0)
	ss_printf (ss, "($%d)", base_reg);
    }
}


/* Return non-zero if the EXPRESSION is a constant 0. */

int
zero_imm (imm_expr *expr)
{
  return (expr->offset == 0 && expr->symbol == NULL);
}



/* Return an address expression of the form SYMBOL +/- IOFFSET (REGISTER).
   Any of the three parts may be omitted. */

addr_expr *
make_addr_expr (int offs, char *sym, int reg_no)
{
  addr_expr *expr = (addr_expr *) xmalloc (sizeof (addr_expr));
  label *lab;

  if (reg_no == 0 && sym != NULL && (lab = lookup_label (sym))->gp_flag)
    {
      expr->reg_no = REG_GP;
      expr->imm = make_imm_expr (offs + lab->addr - gp_midpoint, NULL, 0);
    }
  else
    {
      expr->reg_no = (unsigned char)reg_no;
      expr->imm = make_imm_expr (offs, (sym ? str_copy (sym) : sym), 0);
    }
  return (expr);
}


imm_expr *
addr_expr_imm (addr_expr *expr)
{
  return (expr->imm);
}


int
addr_expr_reg (addr_expr *expr)
{
  return (expr->reg_no);
}



/* Map between a SPIM instruction and the binary representation of the
   instruction. */


/* Maintain a table mapping from internal opcode (i_opcode) to actual
   opcode (a_opcode).  Table must be sorted before first use since its
   entries are alphabetical on name, not ordered by opcode. */


/* Map from internal opcode -> real opcode */

static name_val_val i_opcode_tbl [] = {
#undef OP
#define OP(NAME, I_OPCODE, TYPE, A_OPCODE) {NAME, I_OPCODE, (int)A_OPCODE},
#include "op.h"
};


/* Sort the opcode table on their key (the interal opcode value). */

static void
sort_i_opcode_table ()
{
  qsort (i_opcode_tbl,
	 sizeof (i_opcode_tbl) / sizeof (name_val_val),
	 sizeof (name_val_val),
	 (QSORT_FUNC) compare_pair_value);
}


#define REGS(R,O) (((R) & 0x1f) << O)


int32
inst_encode (instruction *inst)
{
  int32 a_opcode = 0;
  name_val_val *entry;

  if (inst == NULL)
    return (0);

  entry = map_int_to_name_val_val (i_opcode_tbl,
				sizeof (i_opcode_tbl) / sizeof (name_val_val),
				OPCODE (inst));
  if (entry == NULL)
    return 0;

  a_opcode = entry->value2;
  entry = map_int_to_name_val_val (name_tbl,
				sizeof (name_tbl) / sizeof (name_val_val),
				OPCODE (inst));

  switch (entry->value2)
    {
    case BC_TYPE_INST:
      return (a_opcode
	      | REGS (CC (inst) << 2, 16)
	      | (IOFFSET (inst) & 0xffff));

    case B1_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | (IOFFSET (inst) & 0xffff));

    case I1s_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | (IMM (inst) & 0xffff));

    case I1t_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16)
	      | (IMM (inst) & 0xffff));

    case I2_TYPE_INST:
    case B2_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16)
	      | (IMM (inst) & 0xffff));

    case I2a_TYPE_INST:
      return (a_opcode
	      | REGS (BASE (inst), 21)
	      | REGS (RT (inst), 16)
	      | (IOFFSET (inst) & 0xffff));

    case R1s_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21));

    case R1d_TYPE_INST:
      return (a_opcode
	      | REGS (RD (inst), 11));

    case R2td_TYPE_INST:
      return (a_opcode
	      | REGS (RT (inst), 16)
	      | REGS (RD (inst), 11));

    case R2st_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16));

    case R2ds_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RD (inst), 11));

    case R2sh_TYPE_INST:
      return (a_opcode
	      | REGS (RT (inst), 16)
	      | REGS (RD (inst), 11)
	      | REGS (SHAMT (inst), 6));

    case R3_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16)
	      | REGS (RD (inst), 11));

    case R3sh_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16)
	      | REGS (RD (inst), 11));

    case FP_I2a_TYPE_INST:
      return (a_opcode
	      | REGS (BASE (inst), 21)
	      | REGS (RT (inst), 16)
	      | (IOFFSET (inst) & 0xffff));

    case FP_R2ds_TYPE_INST:
      return (a_opcode
	      | REGS (FS (inst), 11)
	      | REGS (FD (inst), 6));

    case FP_R2ts_TYPE_INST:
      return (a_opcode
	      | REGS (RT (inst), 16)
	      | REGS (FS (inst), 11));

    case FP_CMP_TYPE_INST:
      return (a_opcode
	      | REGS (FT (inst), 16)
	      | REGS (FS (inst), 11)
	      | (COND (inst) & 0xf));

    case FP_R3_TYPE_INST:
      return (a_opcode
	      | REGS (FT (inst), 16)
	      | REGS (FS (inst), 11)
	      | REGS (FD (inst), 6));

    case FP_MOVC_TYPE_INST:
      return (a_opcode
	      | REGS (CC (inst), 18)
	      | REGS (FS (inst), 11)
	      | REGS (FD (inst), 6));

    case J_TYPE_INST:
      return (a_opcode
	      | TARGET (inst));

    case NOARG_TYPE_INST:
      return (a_opcode);

    default:
      fatal_error ("Unknown instruction type in inst_encoding\n");
      return (0);		/* Not reached */
    }
}


/* Maintain a table mapping from actual opcode to interal opcode.
   Table must be sorted before first use since its entries are
   alphabetical on name, not ordered by opcode. */


/* Map from internal opcode -> real opcode */

static name_val_val a_opcode_tbl [] = {
#undef OP
#define OP(NAME, I_OPCODE, TYPE, A_OPCODE) {NAME, (int)A_OPCODE, (int)I_OPCODE},
#include "op.h"
};


/* Sort the opcode table on their key (the interal opcode value). */

static void
sort_a_opcode_table ()
{
  qsort (a_opcode_tbl,
	 sizeof (a_opcode_tbl) / sizeof (name_val_val),
	 sizeof (name_val_val),
	 (QSORT_FUNC) compare_pair_value);
}



instruction *
inst_decode (int32 val)
{
  int32 a_opcode = val & 0xfc000000;
  name_val_val *entry;
  int32 i_opcode;

  /* Field classes: (opcode is continued in other part of instruction): */
  if (a_opcode == 0 || a_opcode == 0x70000000) /* SPECIAL or SPECIAL2 */
    a_opcode |= (val & 0x3f);
  else if (a_opcode == 0x04000000)		/* REGIMM */
    a_opcode |= (val & 0x001f0000);
  else if (a_opcode == 0x40000000)		/* COP0 */
    a_opcode |= (val & 0x03e00000) | (val & 0x1f);
  else if (a_opcode == 0x44000000)		/* COP1 */
    {
      a_opcode |= (val & 0x03e00000);
      if ((val & 0xff000000) == 0x45000000)
	a_opcode |= (val & 0x00010000);		/* BC1f/t */
      else
	a_opcode |= (val & 0x3f);
    }
  else if (a_opcode == 0x48000000		/* COPz */
	   || a_opcode == 0x4c000000)
    a_opcode |= (val & 0x03e00000);


  entry = map_int_to_name_val_val (a_opcode_tbl,
				sizeof (a_opcode_tbl) / sizeof (name_val_val),
				a_opcode);
  if (entry == NULL)
    return (mk_r_inst (val, 0, 0, 0, 0, 0)); /* Invalid inst */

  i_opcode = entry->value2;

  switch (map_int_to_name_val_val (name_tbl,
				sizeof (name_tbl) / sizeof (name_val_val),
				i_opcode)->value2)
    {
    case BC_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), BIN_RT(val),
			 val & 0xffff));

    case B1_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), 0, val & 0xffff));

    case I1s_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), 0, val & 0xffff));

    case I1t_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), BIN_RT(val),
			 val & 0xffff));

    case I2_TYPE_INST:
    case B2_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), BIN_RT(val),
			 val & 0xffff));

    case I2a_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), BIN_RT(val),
			 val & 0xffff));

    case R1s_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_RS(val), 0, 0, 0));

    case R1d_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, 0, BIN_RD(val), 0));

    case R2td_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, BIN_RT(val), BIN_RD(val), 0));

    case R2st_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_RS(val), BIN_RT(val), 0, 0));

    case R2ds_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_RS(val), 0, BIN_RD(val), 0));

    case R2sh_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, BIN_RT(val), BIN_RD(val), BIN_SA(val)));

    case R3_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_RS(val), BIN_RT(val), BIN_RD(val), 0));

    case R3sh_TYPE_INST:
      return(mk_r_inst (val, i_opcode, BIN_RS(val), BIN_RT(val), BIN_RD(val), 0));

    case FP_I2a_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_BASE(val), BIN_FT(val), val & 0xffff));

    case FP_R2ds_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_FS(val), 0, BIN_FD(val), 0));

    case FP_R2ts_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, BIN_RT(val), BIN_FS(val), 0));

    case FP_CMP_TYPE_INST:
      {
	instruction *inst = mk_r_inst (val, i_opcode, BIN_FS (val), BIN_FT (val), 0, 0);
	SET_COND (inst, val & 0xf);
	return (inst);
      }

    case FP_R3_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_FS(val), BIN_FT(val), BIN_FD(val), 0));

    case FP_MOVC_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_FS(val), BIN_RT(val), BIN_FD(val), 0));

    case J_TYPE_INST:
      return (mk_j_inst (val, i_opcode, val & 0x2ffffff));


    case NOARG_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, 0, 0, 0));

    default:
      return (mk_r_inst (val, 0, 0, 0, 0, 0)); /* Invalid inst */
    }
}


static instruction *
mk_r_inst (int32 val, int opcode, int rs, int rt, int rd, int shamt)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE (inst, opcode);
  SET_RS (inst, rs);
  SET_RT (inst, rt);
  SET_RD (inst, rd);
  SET_SHAMT (inst, shamt);
  SET_ENCODING (inst, val);
  SET_EXPR (inst, NULL);
  return (inst);
}


static instruction *
mk_i_inst (int32 val, int opcode, int rs, int rt, int offset)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE (inst, opcode);
  SET_RS (inst, rs);
  SET_RT (inst, rt);
  SET_IOFFSET (inst, offset);
  SET_ENCODING (inst, val);
  SET_EXPR (inst, NULL);
  return (inst);
}

static instruction *
mk_j_inst (int32 val, int opcode, int target)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE (inst, opcode);
  SET_TARGET (inst, target);
  SET_ENCODING (inst, val);
  SET_EXPR (inst, NULL);
  return (inst);
}



/* Code to test encode/decode of instructions. */

void
test_assembly (instruction *inst)
{
  instruction *new_inst = inst_decode (inst_encode (inst));

  inst_cmp (inst, new_inst);
  free_inst (new_inst);
}


static void
inst_cmp (instruction *inst1, instruction *inst2)
{
  static str_stream ss;

  ss_clear (&ss);
  if (memcmp (inst1, inst2, sizeof (instruction) - 4) != 0)
    {
      ss_printf (&ss, "=================== Not Equal ===================\n");
      format_an_inst (&ss, inst1, 0);
      format_an_inst (&ss, inst2, 0);
      ss_printf (&ss, "=================== Not Equal ===================\n");
    }
}
/* SPIM S20 MIPS simulator.
   Description of a SPIM S20 instruction.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/inst.h 22    11/27/04 11:03a Larus $
*/


/* Represenation of the expression that produce a value for an instruction's
   immediate field.  Immediates have the form: label +/- offset. */

typedef struct immexpr
{
  int offset;			/* Offset from symbol */
  struct lab *symbol;		/* Symbolic label */
  short bits;			/* > 0 => 31..16, < 0 => 15..0 */
  short pc_relative;		/* Non-zero => offset from label in code */
} imm_expr;


/* Representation of the expression that produce an address for an
   instruction.  Address have the form: label +/- offset (register). */

typedef struct addrexpr
{
  unsigned char reg_no;		/* Register number */
  imm_expr *imm;		/* The immediate part */
} addr_expr;



/* Representation of an instruction. Store the instruction fields in an
   overlapping manner similar to the real encoding (but not identical, to
   speed decoding in C code, as opposed to hardware).. */

typedef struct inst_s
{
  short opcode;

  union
    {
      /* R-type or I-type: */
      struct
	{
	  unsigned char rs;
	  unsigned char rt;

	  union
	    {
	      short imm;

	      struct
		{
		  unsigned char rd;
		  unsigned char shamt;
		} r;
	    } r_i;
	} r_i;

      /* J-type: */
      mem_addr target;
    } r_t;

  int32 encoding;
  imm_expr *expr;
  char *source_line;
} instruction;


#define OPCODE(INST)		(INST)->opcode
#define SET_OPCODE(INST, VAL)	(INST)->opcode = (short)(VAL)


#define RS(INST)		(INST)->r_t.r_i.rs
#define SET_RS(INST, VAL)	(INST)->r_t.r_i.rs = (unsigned char)(VAL)

#define RT(INST)		(INST)->r_t.r_i.rt
#define SET_RT(INST, VAL)	(INST)->r_t.r_i.rt = (unsigned char)(VAL)

#define RD(INST)		(INST)->r_t.r_i.r_i.r.rd
#define SET_RD(INST, VAL)	(INST)->r_t.r_i.r_i.r.rd = (unsigned char)(VAL)


#define FS(INST)		RD(INST)
#define SET_FS(INST, VAL)	SET_RD(INST, VAL)

#define FT(INST)		RT(INST)
#define SET_FT(INST, VAL)	SET_RT(INST, VAL)

#define FD(INST)		SHAMT(INST)
#define SET_FD(INST, VAL)	SET_SHAMT(INST, VAL)


#define SHAMT(INST)		(INST)->r_t.r_i.r_i.r.shamt
#define SET_SHAMT(INST, VAL)	(INST)->r_t.r_i.r_i.r.shamt = (unsigned char)(VAL)

#define IMM(INST)		(INST)->r_t.r_i.r_i.imm
#define SET_IMM(INST, VAL)	(INST)->r_t.r_i.r_i.imm = (short)(VAL)


#define BASE(INST)		RS(INST)
#define SET_BASE(INST, VAL)	SET_RS(INST, VAL)

#define IOFFSET(INST)		IMM(INST)
#define SET_IOFFSET(INST, VAL)	SET_IMM(INST, VAL)
#define IDISP(INST)		(SIGN_EX (IOFFSET (INST) << 2))


#define COND(INST)		RS(INST)
#define SET_COND(INST, VAL)	SET_RS(INST, VAL)

#define CC(INST)		(RT(INST) >> 2)
#define ND(INST)		((RT(INST) & 0x2) >> 1)
#define TF(INST)		(RT(INST) & 0x1)


#define TARGET(INST)		(INST)->r_t.target
#define SET_TARGET(INST, VAL)	(INST)->r_t.target = (mem_addr)(VAL)

#define ENCODING(INST)		(INST)->encoding
#define SET_ENCODING(INST, VAL)	(INST)->encoding = (int32)(VAL)

#define EXPR(INST)		(INST)->expr
#define SET_EXPR(INST, VAL)	(INST)->expr = (imm_expr*)(VAL)

#define SOURCE(INST)		(INST)->source_line
#define SET_SOURCE(INST, VAL)	(INST)->source_line = (char *)(VAL)


#define COND_UN		0x1
#define COND_EQ		0x2
#define COND_LT		0x4
#define COND_IN		0x8

/* Minimum and maximum values that fit in instruction's imm field */
#define IMM_MIN		0xffff8000
#define IMM_MAX 	0x00007fff

#define UIMM_MIN  	(unsigned)0
#define UIMM_MAX  	((unsigned)((1<<16)-1))



/* Raise an exception! */

extern int exception_occurred;

#define RAISE_EXCEPTION(EXCODE, MISC)					\
	{								\
	raise_exception(EXCODE);					\
	MISC;								\
	}								\


#define RAISE_INTERRUPT(LEVEL)						\
	{								\
	/* Set IP (pending) bit for interrupt level. */			\
	CP0_Cause |= (1 << ((LEVEL) + 8));				\
	}								\

#define CLEAR_INTERRUPT(LEVEL)						\
	{								\
	/* Clear IP (pending) bit for interrupt level. */		\
	CP0_Cause &= ~(1 << ((LEVEL) + 8));				\
	}								\

/* Recognized exceptions: */

#define ExcCode_Int	0	/* Interrupt */
#define ExcCode_Mod	1	/* TLB modification (not implemented) */
#define ExcCode_TLBL	2	/* TLB exception (not implemented) */
#define ExcCode_TLBS	3	/* TLB exception (not implemented) */
#define ExcCode_AdEL	4	/* Address error (load/fetch) */
#define ExcCode_AdES	5	/* Address error (store) */
#define ExcCode_IBE	6	/* Bus error, instruction fetch */
#define ExcCode_DBE	7	/* Bus error, data reference */
#define ExcCode_Sys	8	/* Syscall exception */
#define ExcCode_Bp	9	/* Breakpoint exception */
#define ExcCode_RI	10	/* Reserve instruction */
#define ExcCode_CpU	11	/* Coprocessor unusable */
#define ExcCode_Ov	12	/* Arithmetic overflow */
#define ExcCode_Tr	13	/* Trap */
#define ExcCode_FPE	15	/* Floating point */
#define ExcCode_C2E	18	/* Coprocessor 2 (not impelemented) */
#define ExcCode_MDMX	22	/* MDMX unusable (not implemented) */
#define ExcCode_WATCH	23	/* Reference to Watch (not impelemented) */
#define ExcCode_MCheck	24	/* Machine check (not implemented) */
#define ExcCode_CacheErr 30	/* Cache error (not impelemented) */



/* Fields in binary representation of instructions: */

#define BIN_REG(V,O)	(((V) >> O) & 0x1f)
#define BIN_RS(V)	(BIN_REG(V, 21))
#define BIN_RT(V)	(BIN_REG(V, 16))
#define BIN_RD(V)	(BIN_REG(V, 11))
#define BIN_SA(V)	(BIN_REG(V, 6))

#define BIN_BASE(V)	(BIN_REG(V, 21))
#define BIN_FT(V)	(BIN_REG(V, 16))
#define BIN_FS(V)	(BIN_REG(V, 11))
#define BIN_FD(V)	(BIN_REG(V, 6))



/* Exported functions: */

imm_expr *addr_expr_imm (addr_expr *expr);
int addr_expr_reg (addr_expr *expr);
imm_expr *const_imm_expr (int32 value);
imm_expr *copy_imm_expr (imm_expr *old_expr);
instruction *copy_inst (instruction *inst);
mem_addr current_text_pc ();
int32 eval_imm_expr (imm_expr *expr);
void format_an_inst (str_stream *ss, instruction *inst, mem_addr addr);
void free_inst (instruction *inst);
void i_type_inst (int opcode, int rt, int rs, imm_expr *expr);
void i_type_inst_free (int opcode, int rt, int rs, imm_expr *expr);
void increment_text_pc (int delta);
imm_expr *incr_expr_offset (imm_expr *expr, int32 value);
void initialize_inst_tables ();
instruction *inst_decode (int32 value);
int32 inst_encode (instruction *inst);
int inst_is_breakpoint (mem_addr addr);
void j_type_inst (int opcode, imm_expr *target);
void k_text_begins_at_point (mem_addr addr);
imm_expr *lower_bits_of_expr (imm_expr *old_expr);
addr_expr *make_addr_expr (int offs, char *sym, int reg_no);
imm_expr *make_imm_expr (int offs, char *sym, int pc_rel);
int opcode_is_branch (int opcode);
int opcode_is_nullified_branch (int opcode);
int opcode_is_true_branch (int opcode);
int opcode_is_jump (int opcode);
int opcode_is_load_store (int opcode);
void print_inst (mem_addr addr);
void r_co_type_inst (int opcode, int fd, int fs, int ft);
void r_cond_type_inst (int opcode, int fs, int ft, int cc);
void r_sh_type_inst (int opcode, int rd, int rt, int shamt);
void r_type_inst (int opcode, int rd, int rs, int rt);
void raise_exception(int excode);
instruction *set_breakpoint (mem_addr addr);
void store_instruction (instruction *inst);
void text_begins_at_point (mem_addr addr);
imm_expr *upper_bits_of_expr (imm_expr *old_expr);
void user_kernel_text_segment (int to_kernel);
int zero_imm (imm_expr *expr);
/* SPIM S20 MIPS simulator.
   Code to create, maintain and access memory.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/mem.c 28    11/27/04 8:55p Larus $
*/


#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "mem.h"

/* Exported Variables: */

reg_word R[R_LENGTH];
reg_word HI, LO;
int HI_present, LO_present;
mem_addr PC, nPC;
double *FPR;			/* Dynamically allocate so overlay */
float *FGR;			/* is possible */
int *FWR;			/* is possible */
reg_word CCR[4][32], CPR[4][32];

instruction **text_seg;
int text_modified;		/* Non-zero means text segment was written */
mem_addr text_top;
mem_word *data_seg;
int data_modified;		/* Non-zero means a data segment was written */
short *data_seg_h;		/* Points to same vector as DATA_SEG */
BYTE_TYPE *data_seg_b;		/* Ditto */
mem_addr data_top;
mem_addr gp_midpoint;		/* Middle of $gp area */
mem_word *stack_seg;
short *stack_seg_h;		/* Points to same vector as STACK_SEG */
BYTE_TYPE *stack_seg_b;		/* Ditto */
mem_addr stack_bot;
instruction **k_text_seg;
mem_addr k_text_top;
mem_word *k_data_seg;
short *k_data_seg_h;
BYTE_TYPE *k_data_seg_b;
mem_addr k_data_top;


/* Local functions: */

static mem_word bad_mem_read (mem_addr addr, int mask);
static void bad_mem_write (mem_addr addr, mem_word value, int mask);
static instruction *bad_text_read (mem_addr addr);
static void bad_text_write (mem_addr addr, instruction *inst);
static void free_instructions (instruction **inst, int n);
static mem_word read_memory_mapped_IO (mem_addr addr);
static void write_memory_mapped_IO (mem_addr addr, mem_word value);


/* Local variables: */

static int32 data_size_limit, stack_size_limit, k_data_size_limit;



/* Memory is allocated in five chunks:
	text, data, stack, kernel text, and kernel data.

   The arrays are independent and have different semantics.

   text is allocated from 0x400000 up and only contains INSTRUCTIONs.
   It does not expand.

   data is allocated from 0x10000000 up.  It can be extended by the
   SBRK system call.  Programs can only read and write this segment.

   stack grows from 0x7fffefff down.  It is automatically extended.
   Programs can only read and write this segment.

   k_text is like text, except its is allocated from 0x80000000 up.

   k_data is like data, but is allocated from 0x90000000 up.

   Both kernel text and kernel data can only be accessed in kernel mode.
*/

/* The text segments contain pointers to instructions, not actual
   instructions, so they must be allocated large enough to hold as many
   pointers as there would be instructions (the two differ on machines in
   which pointers are not 32 bits long).  The following calculations round
   up in case size is not a multiple of BYTES_PER_WORD.  */

#define BYTES_TO_INST(N) (((N) + BYTES_PER_WORD - 1) / BYTES_PER_WORD * sizeof(instruction*))


void
make_memory (int text_size, int data_size, int data_limit,
	     int stack_size, int stack_limit, int k_text_size,
	     int k_data_size, int k_data_limit)
{
  if (data_size <= 65536)
    data_size = 65536;
  data_size = ROUND_UP(data_size, BYTES_PER_WORD); /* Keep word aligned */

  if (text_seg == NULL)
    text_seg = (instruction **) xmalloc (BYTES_TO_INST(text_size));
  else
    {
      free_instructions (text_seg, (text_top - TEXT_BOT) / BYTES_PER_WORD);
      text_seg = (instruction **) realloc (text_seg, BYTES_TO_INST(text_size));
    }
  memclr (text_seg, BYTES_TO_INST(text_size));
  text_top = TEXT_BOT + text_size;

  data_size = ROUND_UP(data_size, BYTES_PER_WORD); /* Keep word aligned */
  if (data_seg == NULL)
    data_seg = (mem_word *) xmalloc (data_size);
  else
    data_seg = (mem_word *) realloc (data_seg, data_size);
  memclr (data_seg, data_size);
  data_seg_b = (BYTE_TYPE *) data_seg;
  data_seg_h = (short *) data_seg;
  data_top = DATA_BOT + data_size;
  data_size_limit = data_limit;

  stack_size = ROUND_UP(stack_size, BYTES_PER_WORD); /* Keep word aligned */
  if (stack_seg == NULL)
    stack_seg = (mem_word *) xmalloc (stack_size);
  else
    stack_seg = (mem_word *) realloc (stack_seg, stack_size);
  memclr (stack_seg, stack_size);
  stack_seg_b = (BYTE_TYPE *) stack_seg;
  stack_seg_h = (short *) stack_seg;
  stack_bot = STACK_TOP - stack_size;
  stack_size_limit = stack_limit;

  if (k_text_seg == NULL)
    k_text_seg = (instruction **) xmalloc (BYTES_TO_INST(k_text_size));
  else
    {
      free_instructions (k_text_seg,
			 (k_text_top - K_TEXT_BOT) / BYTES_PER_WORD);
      k_text_seg = (instruction **) realloc(k_text_seg,
					    BYTES_TO_INST(k_text_size));
    }
  memclr (k_text_seg, BYTES_TO_INST(k_text_size));
  k_text_top = K_TEXT_BOT + k_text_size;

  k_data_size = ROUND_UP(k_data_size, BYTES_PER_WORD); /* Keep word aligned */
  if (k_data_seg == NULL)
    k_data_seg = (mem_word *) xmalloc (k_data_size);
  else
    k_data_seg = (mem_word *) realloc (k_data_seg, k_data_size);
  memclr (k_data_seg, k_data_size);
  k_data_seg_b = (BYTE_TYPE *) k_data_seg;
  k_data_seg_h = (short *) k_data_seg;
  k_data_top = K_DATA_BOT + k_data_size;
  k_data_size_limit = k_data_limit;

  text_modified = 1;
  data_modified = 1;
}


/* Free the storage used by the old instructions in memory. */

static void
free_instructions (instruction **inst, int n)
{
  for ( ; n > 0; n --, inst ++)
    if (*inst)
      free_inst (*inst);
}


/* Expand the data segment by adding N bytes. */

void
expand_data (int addl_bytes)
{
  int delta = ROUND_UP(addl_bytes, BYTES_PER_WORD); /* Keep word aligned */
  int old_size = data_top - DATA_BOT;
  int new_size = old_size + delta;
  BYTE_TYPE *p;

  if ((addl_bytes < 0) || (new_size > data_size_limit))
    {
      error ("Can't expand data segment by %d bytes to %d bytes\n",
	     addl_bytes, new_size);
      run_error ("Use -ldata # with # > %d\n", new_size);
    }
  data_seg = (mem_word *) realloc (data_seg, new_size);
  if (data_seg == NULL)
    fatal_error ("realloc failed in expand_data\n");

  data_seg_b = (BYTE_TYPE *) data_seg;
  data_seg_h = (short *) data_seg;
  data_top += delta;

  /* Zero new memory */
  for (p = data_seg_b + old_size; p < data_seg_b + new_size; )
    *p ++ = 0;
}


/* Expand the stack segment by adding N bytes.  Can't use REALLOC
   since it copies from bottom of memory blocks and stack grows down from
   top of its block. */

void
expand_stack (int addl_bytes)
{
  int delta = ROUND_UP(addl_bytes, BYTES_PER_WORD); /* Keep word aligned */
  int old_size = STACK_TOP - stack_bot;
  int new_size = old_size + MAX (delta, old_size);
  mem_word *new_seg;
  mem_word *po, *pn;

  if ((addl_bytes < 0) || (new_size > stack_size_limit))
    {
      error ("Can't expand stack segment by %d bytes to %d bytes\n",
	     addl_bytes, new_size);
      run_error ("Use -lstack # with # > %d\n", new_size);
    }

  new_seg = (mem_word *) xmalloc (new_size);
  po = stack_seg + (old_size / BYTES_PER_WORD - 1);
  pn = new_seg + (new_size / BYTES_PER_WORD - 1);

  for ( ; po >= stack_seg ; ) *pn -- = *po --;
  for ( ; pn >= new_seg ; ) *pn -- = 0;

  free (stack_seg);
  stack_seg = new_seg;
  stack_seg_b = (BYTE_TYPE *) stack_seg;
  stack_seg_h = (short *) stack_seg;
  stack_bot -= (new_size - old_size);
}


/* Expand the kernel data segment by adding N bytes. */

void
expand_k_data (int addl_bytes)
{
  int delta = ROUND_UP(addl_bytes, BYTES_PER_WORD); /* Keep word aligned */
  int old_size = k_data_top - K_DATA_BOT;
  int new_size = old_size + delta;
  BYTE_TYPE *p;

  if ((addl_bytes < 0) || (new_size > k_data_size_limit))
    {
      error ("Can't expand kernel data segment by %d bytes to %d bytes\n",
	     addl_bytes, new_size);
      run_error ("Use -lkdata # with # > %d\n", new_size);
    }
  k_data_seg = (mem_word *) realloc (k_data_seg, new_size);
  if (k_data_seg == NULL)
    fatal_error ("realloc failed in expand_k_data\n");

  k_data_seg_b = (BYTE_TYPE *) k_data_seg;
  k_data_seg_h = (short *) k_data_seg;
  k_data_top += delta;

  /* Zero new memory */
  for (p = k_data_seg_b + old_size / BYTES_PER_WORD;
       p < k_data_seg_b + new_size / BYTES_PER_WORD; )
    *p ++ = 0;
}



/* Access memory */

void*
mem_reference(mem_addr addr)
{
  if ((addr >= TEXT_BOT) && (addr < text_top))
    return addr - TEXT_BOT + (char*) text_seg;
  else if ((addr >= DATA_BOT) && (addr < data_top))
    return addr - DATA_BOT + (char*) data_seg;
  else if ((addr >= stack_bot) && (addr < STACK_TOP))
    return addr - stack_bot + (char*) stack_seg;
  else if ((addr >= K_TEXT_BOT) && (addr < k_text_top))
    return addr - K_TEXT_BOT + (char*) k_text_seg;
  else if ((addr >= K_DATA_BOT) && (addr < k_data_top))
    return addr - K_DATA_BOT + (char*) k_data_seg;
  else
    {
      run_error ("Memory address out of bounds\n");
      return NULL;
    }
}


instruction*
read_mem_inst(mem_addr addr)
{
  if ((addr >= TEXT_BOT) && (addr < text_top) && !(addr & 0x3))
    return text_seg [(addr - TEXT_BOT) >> 2];
  else if ((addr >= K_TEXT_BOT) && (addr < k_text_top) && !(addr & 0x3))
    return k_text_seg [(addr - K_TEXT_BOT) >> 2];
  else
    return bad_text_read (addr);
}


reg_word
read_mem_byte(mem_addr addr)
{
  if ((addr >= DATA_BOT) && (addr < data_top))
    return data_seg_b [addr - DATA_BOT];
  else if ((addr >= stack_bot) && (addr < STACK_TOP))
    return stack_seg_b [addr - stack_bot];
  else if ((addr >= K_DATA_BOT) && (addr < k_data_top))
    return k_data_seg_b [addr - K_DATA_BOT];
  else
    return bad_mem_read (addr, 0);
}


reg_word
read_mem_half(mem_addr addr)
{
  if ((addr >= DATA_BOT) && (addr < data_top) && !(addr & 0x1))
    return data_seg_h [(addr - DATA_BOT) >> 1];
  else if ((addr >= stack_bot) && (addr < STACK_TOP) && !(addr & 0x1))
    return stack_seg_h [(addr - stack_bot) >> 1];
  else if ((addr >= K_DATA_BOT) && (addr < k_data_top) && !(addr & 0x1))
    return k_data_seg_h [(addr - K_DATA_BOT) >> 1];
  else
    return bad_mem_read (addr, 0x1);
}


reg_word
read_mem_word(mem_addr addr)
{
  if ((addr >= DATA_BOT) && (addr < data_top) && !(addr & 0x3))
    return data_seg [(addr - DATA_BOT) >> 2];
  else if ((addr >= stack_bot) && (addr < STACK_TOP) && !(addr & 0x3))
    return stack_seg [(addr - stack_bot) >> 2];
  else if ((addr >= K_DATA_BOT) && (addr < k_data_top) && !(addr & 0x3))
    return k_data_seg [(addr - K_DATA_BOT) >> 2];
  else
    return bad_mem_read (addr, 0x3);
}


void
set_mem_inst(mem_addr addr, instruction* inst)
{
  text_modified = 1;
  if ((addr >= TEXT_BOT) && (addr < text_top) && !(addr & 0x3))
    text_seg [(addr - TEXT_BOT) >> 2] = inst;
  else if ((addr >= K_TEXT_BOT) && (addr < k_text_top) && !(addr & 0x3))
    k_text_seg [(addr - K_TEXT_BOT) >> 2] = inst;
  else
    bad_text_write (addr, inst);
}


void
set_mem_byte(mem_addr addr, reg_word value)
{
  data_modified = 1;
  if ((addr >= DATA_BOT) && (addr < data_top))
    data_seg_b [addr - DATA_BOT] = (BYTE_TYPE) value;
  else if ((addr >= stack_bot) && (addr < STACK_TOP))
    stack_seg_b [addr - stack_bot] = (BYTE_TYPE) value;
  else if ((addr >= K_DATA_BOT) && (addr < k_data_top))
    k_data_seg_b [addr - K_DATA_BOT] = (BYTE_TYPE) value;
  else
    bad_mem_write (addr, value, 0);
}


void
set_mem_half(mem_addr addr, reg_word value)
{
  data_modified = 1;
  if ((addr >= DATA_BOT) && (addr < data_top) && !(addr & 0x1))
    data_seg_h [(addr - DATA_BOT) >> 1] = (short) value;
  else if ((addr >= stack_bot) && (addr < STACK_TOP) && !(addr & 0x1))
    stack_seg_h [(addr - stack_bot) >> 1] = (short) value;
  else if ((addr >= K_DATA_BOT) && (addr < k_data_top) && !(addr & 0x1))
    k_data_seg_h [(addr - K_DATA_BOT) >> 1] = (short) value;
  else
    bad_mem_write (addr, value, 0x1);
}


void
set_mem_word(mem_addr addr, reg_word value)
{
  data_modified = 1;
  if ((addr >= DATA_BOT) && (addr < data_top) && !(addr & 0x3))
    data_seg [(addr - DATA_BOT) >> 2] = (mem_word) value;
  else if ((addr >= stack_bot) && (addr < STACK_TOP) && !(addr & 0x3))
    stack_seg [(addr - stack_bot) >> 2] = (mem_word) value;
  else if ((addr >= K_DATA_BOT) && (addr < k_data_top) && !(addr & 0x3))
    k_data_seg [(addr - K_DATA_BOT) >> 2] = (mem_word) value;
  else
    bad_mem_write (addr, value, 0x3);
}


/* Handle the infrequent and erroneous cases in memory accesses. */

static instruction *
bad_text_read (mem_addr addr)
{
  RAISE_EXCEPTION (ExcCode_IBE, CP0_BadVAddr = addr);
  return (inst_decode (0));
}


static void
bad_text_write (mem_addr addr, instruction *inst)
{
  RAISE_EXCEPTION (ExcCode_IBE, CP0_BadVAddr = addr);
  set_mem_word (addr, ENCODING (inst));
}


static mem_word
bad_mem_read (mem_addr addr, int mask)
{
  mem_word tmp;

  if ((addr & mask) != 0)
    RAISE_EXCEPTION (ExcCode_AdEL, CP0_BadVAddr = addr)
  else if (addr >= TEXT_BOT && addr < text_top)
    switch (mask)
      {
      case 0x0:
	tmp = ENCODING (text_seg [(addr - TEXT_BOT) >> 2]);
#ifdef BIGENDIAN
	tmp = (unsigned)tmp >> (8 * (3 - (addr & 0x3)));
#else
	tmp = (unsigned)tmp >> (8 * (addr & 0x3));
#endif
	return (0xff & tmp);

      case 0x1:
	tmp = ENCODING (text_seg [(addr - TEXT_BOT) >> 2]);
#ifdef BIGENDIAN
	tmp = (unsigned)tmp >> (8 * (2 - (addr & 0x2)));
#else
	tmp = (unsigned)tmp >> (8 * (addr & 0x2));
#endif
	return (0xffff & tmp);

      case 0x3:
	{
	instruction *inst = text_seg [(addr - TEXT_BOT) >> 2];
	if (inst == NULL)
	  return 0;
	else
	  return (ENCODING (inst));
	}

      default:
	run_error ("Bad mask (0x%x) in bad_mem_read\n", mask);
      }
  else if (addr > data_top
	   && addr < stack_bot
	   /* If more than 16 MB below stack, probably is bad data ref */
	   && addr > stack_bot - 16*K*K)
    {
      /* Grow stack segment */
      expand_stack (stack_bot - addr + 4);
      return (0);
    }
  else if (MM_IO_BOT <= addr && addr <= MM_IO_TOP)
    return (read_memory_mapped_IO (addr));
  else
    /* Address out of range */
    RAISE_EXCEPTION (ExcCode_DBE, CP0_BadVAddr = addr)
  return (0);
}


static void
bad_mem_write (mem_addr addr, mem_word value, int mask)
{
  mem_word tmp;

  if ((addr & mask) != 0)
    /* Unaligned address fault */
    RAISE_EXCEPTION (ExcCode_AdES, CP0_BadVAddr = addr)
    else if (addr >= TEXT_BOT && addr < text_top)
  {
    switch (mask)
    {
    case 0x0:
      tmp = ENCODING (text_seg [(addr - TEXT_BOT) >> 2]);
#ifdef BIGENDIAN
      tmp = ((tmp & ~(0xff << (8 * (3 - (addr & 0x3)))))
	       | (value & 0xff) << (8 * (3 - (addr & 0x3))));
#else
      tmp = ((tmp & ~(0xff << (8 * (addr & 0x3))))
	       | (value & 0xff) << (8 * (addr & 0x3)));
#endif
      break;

    case 0x1:
      tmp = ENCODING (text_seg [(addr - TEXT_BOT) >> 2]);
#ifdef BIGENDIAN
      tmp = ((tmp & ~(0xffff << (8 * (2 - (addr & 0x2)))))
	       | (value & 0xffff) << (8 * (2 - (addr & 0x2))));
#else
      tmp = ((tmp & ~(0xffff << (8 * (addr & 0x2))))
	       | (value & 0xffff) << (8 * (addr & 0x2)));
#endif
      break;

    case 0x3:
      tmp = value;
      break;

    default:
      run_error ("Bad mask (0x%x) in bad_mem_read\n", mask);
    }

    if (text_seg [(addr - TEXT_BOT) >> 2] != NULL)
    {
      free_inst (text_seg[(addr - TEXT_BOT) >> 2]);
    }
    text_seg [(addr - TEXT_BOT) >> 2] = inst_decode (tmp);

    text_modified = 1;
  }
  else if (addr > data_top
	   && addr < stack_bot
	   /* If more than 16 MB below stack, probably is bad data ref */
	   && addr > stack_bot - 16*K*K)
  {
    /* Grow stack segment */
    expand_stack (stack_bot - addr + 4);
    if (addr >= stack_bot)
    {
      if (mask == 0)
	stack_seg_b [addr - stack_bot] = (char)value;
      else if (mask == 1)
	stack_seg_h [(addr - stack_bot) >> 1] = (short)value;
      else
	stack_seg [(addr - stack_bot) >> 2] = value;
    }
    else
      RAISE_EXCEPTION (ExcCode_DBE, CP0_BadVAddr = addr)

    data_modified = 1;
  }
  else if (MM_IO_BOT <= addr && addr <= MM_IO_TOP)
    write_memory_mapped_IO (addr, value);
  else
    /* Address out of range */
    RAISE_EXCEPTION (ExcCode_DBE, CP0_BadVAddr = addr)
}



/* Memory-mapped IO routines. */

static int recv_control = 0;	/* No input */
static int recv_buffer;
static int recv_buffer_full_timer = 0;

static int trans_control = TRANS_READY;	/* Ready to write */
static int trans_buffer;
static int trans_buffer_full_timer = 0;


/* Check if input is available and output is possible.  If so, update the
   memory-mapped control registers and buffers. */

void
check_memory_mapped_IO ()
{
  if (recv_buffer_full_timer > 0)
    {
      /* Do not check for more input until this interval expires. */
      recv_buffer_full_timer -= 1;
    }
  else if (console_input_available ())
    {
      /* Read new char into the buffer and raise an interrupt, if interrupts
	 are enabled for device. */
      /* assert(recv_buffer_full_timer == 0); */
      recv_buffer = get_console_char ();
      recv_control |= RECV_READY;
      recv_buffer_full_timer = RECV_INTERVAL;
      if (recv_control & RECV_INT_ENABLE)
	{
	  RAISE_INTERRUPT (RECV_INT_LEVEL);
	}
    }

  if (trans_buffer_full_timer > 0)
    {
      /* Do not allow output until this interval expires. */
      trans_buffer_full_timer -= 1;
    }
  else if (!(trans_control & TRANS_READY))
    {
      /* Done writing: empty the buffer and raise an interrupt, if interrupts
	 are enabled for device. */
      /* assert(trans_buffer_full_timer == 0); */
      trans_control |= TRANS_READY;
      if (trans_control & TRANS_INT_ENABLE)
	{
	  RAISE_INTERRUPT (TRANS_INT_LEVEL);
	}
    }
}


/* Invoked on a write to the memory-mapped IO area. */

static void
write_memory_mapped_IO (mem_addr addr, mem_word value)
{
  switch (addr)
    {
    case TRANS_CTRL_ADDR:
      /* Program can only set the interrupt enable, not ready, bit. */
      if ((value & TRANS_INT_ENABLE) != 0)
	{
	  /* Enable interrupts: */
	  trans_control |= TRANS_INT_ENABLE;
	  if (trans_control & TRANS_READY)
	    {
	      /* Raise interrupt on enabling a ready transmitter */
	      RAISE_INTERRUPT (TRANS_INT_LEVEL);
	    }
	}
      else
	{
	  /* Disable interrupts: */
	  trans_control &= ~TRANS_INT_ENABLE;
	  CLEAR_INTERRUPT (TRANS_INT_LEVEL); /* Clear IP bit in Cause */
	}
      break;

    case TRANS_BUFFER_ADDR:
      /* Ignore write if device is not ready. */
      if ((trans_control & TRANS_READY) != 0)
	{
	  /* Write char: */
	  trans_buffer = value & 0xff;
	  put_console_char ((char)trans_buffer);
	  /* Device is busy for a while: */
	  trans_control &= ~TRANS_READY;
	  trans_buffer_full_timer = TRANS_LATENCY;
          CLEAR_INTERRUPT (TRANS_INT_LEVEL); /* Clear IP bit in Cause */
	}
      break;

    case RECV_CTRL_ADDR:
      /* Program can only set the interrupt enable, not ready, bit. */
      if ((value & RECV_INT_ENABLE) != 0)
	{
	  /* Enable interrupts: */
	  recv_control |= RECV_INT_ENABLE;
	  if (recv_control & RECV_READY)
	    {
	      /* Raise interrupt on enabling a ready receiver */
	      RAISE_INTERRUPT (RECV_INT_LEVEL);
	    }
	}
      else
	{
	  /* Disable interrupts: */
	  recv_control &= ~RECV_INT_ENABLE;
	  CLEAR_INTERRUPT (RECV_INT_LEVEL); /* Clear IP bit in Cause */
	}
      break;

    case RECV_BUFFER_ADDR:
      /* Nop: program can't change buffer. */
      break;

    default:
      run_error ("Write to unused memory-mapped IO address (0x%x)\n", addr);
    }
}


/* Invoked on a read in the memory-mapped IO area. */

static mem_word
read_memory_mapped_IO (mem_addr addr)
{
  switch (addr)
    {
    case TRANS_CTRL_ADDR:
      return (trans_control);

    case TRANS_BUFFER_ADDR:
      return (trans_buffer & 0xff);

    case RECV_CTRL_ADDR:
      return (recv_control);

    case RECV_BUFFER_ADDR:
      recv_control &= ~RECV_READY; /* Buffer now empty */
      recv_buffer_full_timer = 0;
      CLEAR_INTERRUPT (RECV_INT_LEVEL); /* Clear IP bit in Cause */
      return (recv_buffer & 0xff);

    default:
      run_error ("Read from unused memory-mapped IO address (0x%x)\n", addr);
      return (0);
    }
}



/* Misc. routines */

void
print_mem (mem_addr addr)
{
  mem_word value;

  if ((addr & 0x3) != 0)
    addr &= ~0x3;		/* Address must be word-aligned */

  if (TEXT_BOT <= addr && addr < text_top)
    print_inst (addr);
  else if (DATA_BOT <= addr && addr < data_top)
    {
      value = read_mem_word (addr);
      write_output (message_out, "Data seg @ 0x%08x (%d) = 0x%08x (%d)\n",
		    addr, addr, value, value);
    }
  else if (stack_bot <= addr && addr < STACK_TOP)
    {
      value = read_mem_word (addr);
      write_output (message_out, "Stack seg @ 0x%08x (%d) = 0x%08x (%d)\n",
		    addr, addr, value, value);
    }
  else if (K_TEXT_BOT <= addr && addr < k_text_top)
    print_inst (addr);
  else if (K_DATA_BOT <= addr && addr < k_data_top)
    {
      value = read_mem_word (addr);
      write_output (message_out,
		    "Kernel Data seg @ 0x%08x (%d) = 0x%08x (%d)\n",
		    addr, addr, value, value);
    }
  else
    error ("Address 0x%08x (%d) to print_mem is out of bounds\n", addr, addr);
}
/* SPIM S20 MIPS simulator.
   Macros for accessing memory.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/*   $Header: /Software/SPIM/src/mem.h 12    3/21/04 11:18a Larus $
*/


/* A note on directions:  "Bottom" of memory is the direction of
   decreasing addresses.  "Top" is the direction of increasing addresses.*/


/* Type of contents of a memory word. */

typedef int32 /*@alt unsigned int @*/ mem_word;


/* The text segment and boundaries. */

extern instruction **text_seg;

extern int text_modified;	/* Non-zero means text segment was written */

#define TEXT_BOT ((mem_addr) 0x400000)

extern mem_addr text_top;


/* Amount to grow text segment when we run out of space for instructions. */

#define TEXT_CHUNK_SIZE	4096


/* The data segment and boundaries. */

extern mem_word *data_seg;

extern int data_modified;	/* Non-zero means a data segment was written */

extern short *data_seg_h;	/* Points to same vector as DATA_SEG */

#define BYTE_TYPE signed char


extern BYTE_TYPE *data_seg_b;	/* Ditto */

#define DATA_BOT ((mem_addr) 0x10000000)

extern mem_addr data_top;

extern mem_addr gp_midpoint;	/* Middle of $gp area */


/* The stack segment and boundaries. */

extern mem_word *stack_seg;

extern short *stack_seg_h;	/* Points to same vector as STACK_SEG */

extern BYTE_TYPE *stack_seg_b;	/* Ditto */

extern mem_addr stack_bot;

/* Exclusive, but include 4K at top of stack. */

#define STACK_TOP ((mem_addr) 0x80000000)


/* The kernel text segment and boundaries. */

extern instruction **k_text_seg;

#define K_TEXT_BOT ((mem_addr) 0x80000000)

extern mem_addr k_text_top;


/* Kernel data segment and boundaries. */

extern mem_word *k_data_seg;

extern short *k_data_seg_h;

extern BYTE_TYPE *k_data_seg_b;

#define K_DATA_BOT ((mem_addr) 0x90000000)

extern mem_addr k_data_top;


/* Memory-mapped IO area: */
#define MM_IO_BOT		((mem_addr) 0xffff0000)
#define MM_IO_TOP		((mem_addr) 0xffffffff)


/* Read from console: */
#define RECV_CTRL_ADDR		((mem_addr) 0xffff0000)
#define RECV_BUFFER_ADDR	((mem_addr) 0xffff0004)

#define RECV_READY		0x1
#define RECV_INT_ENABLE		0x2

#define RECV_INT_LEVEL		3 /* HW Interrupt 1 */


/* Write to console: */
#define TRANS_CTRL_ADDR		((mem_addr) 0xffff0008)
#define TRANS_BUFFER_ADDR	((mem_addr) 0xffff000c)

#define TRANS_READY		0x1
#define TRANS_INT_ENABLE	0x2

#define TRANS_INT_LEVEL		2 /* HW Interrupt 0 */




/* Exported functions: */

void check_memory_mapped_IO ();
void expand_data (int addl_bytes);
void expand_k_data (int addl_bytes);
void expand_stack (int addl_bytes);
void make_memory (int text_size, int data_size, int data_limit,
		  int stack_size, int stack_limit, int k_text_size,
		  int k_data_size, int k_data_limit);
void* mem_reference(mem_addr addr);
void print_mem (mem_addr addr);
instruction* read_mem_inst(mem_addr addr);
reg_word read_mem_byte(mem_addr addr);
reg_word read_mem_half(mem_addr addr);
reg_word read_mem_word(mem_addr addr);
void set_mem_inst(mem_addr addr, instruction* inst);
void set_mem_byte(mem_addr addr, reg_word value);
void set_mem_half(mem_addr addr, reg_word value);
void set_mem_word(mem_addr addr, reg_word value);
/* SPIM S20 MIPS simulator.
   This file describes the MIPS instructions, the assembler pseudo
   instructions, the assembler pseudo-ops, and the spim commands.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/op.h 42    11/13/04 11:19a Larus $
*/


/* Type of each entry: */

#define ASM_DIR			0
#define PSEUDO_OP		1

#define BC_TYPE_INST		10
#define B1_TYPE_INST		11
#define I1s_TYPE_INST		12
#define I1t_TYPE_INST		13
#define I2_TYPE_INST		14
#define B2_TYPE_INST		15
#define I2a_TYPE_INST		16

#define R1s_TYPE_INST		20
#define R1d_TYPE_INST		21
#define R2st_TYPE_INST		22
#define R2ds_TYPE_INST		23
#define R2td_TYPE_INST		24
#define R2sh_TYPE_INST		25
#define R3_TYPE_INST		26
#define R3sh_TYPE_INST		27

#define FP_I2a_TYPE_INST	30
#define FP_R2ds_TYPE_INST	31
#define FP_R2ts_TYPE_INST	32
#define FP_CMP_TYPE_INST	33
#define FP_R3_TYPE_INST		34
#define FP_R4_TYPE_INST		35
#define FP_MOVC_TYPE_INST	36

#define J_TYPE_INST		40
#define NOARG_TYPE_INST		42


/* Information on each keyword token that can be read by spim.	Must be
   sorted in alphabetical order. */

OP(".alias",	Y_ALIAS_DIR,	ASM_DIR,		-1)
OP(".align",	Y_ALIGN_DIR,	ASM_DIR,		-1)
OP(".ascii",	Y_ASCII_DIR,	ASM_DIR,		-1)
OP(".asciiz",	Y_ASCIIZ_DIR,	ASM_DIR,		-1)
OP(".asm0",	Y_ASM0_DIR,	ASM_DIR,		-1)
OP(".bgnb",	Y_BGNB_DIR,	ASM_DIR,		-1)
OP(".byte",	Y_BYTE_DIR,	ASM_DIR,		-1)
OP(".comm",	Y_COMM_DIR,	ASM_DIR,		-1)
OP(".data",	Y_DATA_DIR,	ASM_DIR,		-1)
OP(".double",	Y_DOUBLE_DIR,	ASM_DIR,		-1)
OP(".end",	Y_END_DIR,	ASM_DIR,		-1)
OP(".endb",	Y_ENDB_DIR,	ASM_DIR,		-1)
OP(".endr",	Y_ENDR_DIR,	ASM_DIR,		-1)
OP(".ent",	Y_ENT_DIR,	ASM_DIR,		-1)
OP(".err",	Y_ERR_DIR,	ASM_DIR,		-1)
OP(".extern",	Y_EXTERN_DIR,	ASM_DIR,		-1)
OP(".file",	Y_FILE_DIR,	ASM_DIR,		-1)
OP(".float",	Y_FLOAT_DIR,	ASM_DIR,		-1)
OP(".fmask",	Y_FMASK_DIR,	ASM_DIR,		-1)
OP(".frame",	Y_FRAME_DIR,	ASM_DIR,		-1)
OP(".globl",	Y_GLOBAL_DIR,	ASM_DIR,		-1)
OP(".half",	Y_HALF_DIR,	ASM_DIR,		-1)
OP(".kdata",	Y_K_DATA_DIR,	ASM_DIR,		-1)
OP(".ktext",	Y_K_TEXT_DIR,	ASM_DIR,		-1)
OP(".lab",	Y_LABEL_DIR,	ASM_DIR,		-1)
OP(".lcomm",	Y_LCOMM_DIR,	ASM_DIR,		-1)
OP(".livereg",	Y_LIVEREG_DIR,	ASM_DIR,		-1)
OP(".loc",	Y_LOC_DIR,	ASM_DIR,		-1)
OP(".mask",	Y_MASK_DIR,	ASM_DIR,		-1)
OP(".noalias",	Y_NOALIAS_DIR,	ASM_DIR,		-1)
OP(".option",	Y_OPTIONS_DIR,	ASM_DIR,		-1)
OP(".rdata",	Y_RDATA_DIR,	ASM_DIR,		-1)
OP(".repeat",	Y_REPEAT_DIR,	ASM_DIR,		-1)
OP(".sdata",	Y_SDATA_DIR,	ASM_DIR,		-1)
OP(".set",	Y_SET_DIR,	ASM_DIR,		-1)
OP(".space",	Y_SPACE_DIR,	ASM_DIR,		-1)
OP(".struct",	Y_STRUCT_DIR,	ASM_DIR,		-1)
OP(".text",	Y_TEXT_DIR,	ASM_DIR,		-1)
OP(".verstamp",Y_VERSTAMP_DIR,	ASM_DIR,		-1)
OP(".vreg",	Y_VREG_DIR,	ASM_DIR,		-1)
OP(".word",	Y_WORD_DIR,	ASM_DIR,		-1)

OP("abs",	Y_ABS_POP,	PSEUDO_OP,		-1)
OP("abs.d",	Y_ABS_D_OP,	FP_R2ds_TYPE_INST,	0x46200005)
OP("abs.ps",	Y_ABS_PS_OP,	FP_R2ds_TYPE_INST,	0x46600005)	/* MIPS32 Rev 2 */
OP("abs.s",	Y_ABS_S_OP,	FP_R2ds_TYPE_INST,	0x46000005)

OP("add",	Y_ADD_OP,	R3_TYPE_INST,		0x00000020)
OP("add.d",	Y_ADD_D_OP,	FP_R3_TYPE_INST,	0x46200000)
OP("add.ps",	Y_ADD_PS_OP,	FP_R3_TYPE_INST,	0x46600000)	/* MIPS32 Rev 2 */
OP("add.s",	Y_ADD_S_OP,	FP_R3_TYPE_INST,	0x46000000)
OP("addi",	Y_ADDI_OP,	I2_TYPE_INST,		0x20000000)
OP("addiu",	Y_ADDIU_OP,	I2_TYPE_INST,		0x24000000)
OP("addu",	Y_ADDU_OP,	R3_TYPE_INST,		0x00000021)

OP("alnv.ps",	Y_ALNV_PS_OP,	FP_R4_TYPE_INST,	0x4c00001e)	/* MIPS32 Rev 2 */

OP("and",	Y_AND_OP,	R3_TYPE_INST,		0x00000024)
OP("andi",	Y_ANDI_OP,	I2_TYPE_INST,		0x30000000)

OP("b",		Y_B_POP,	PSEUDO_OP,		-1)
OP("bal",	Y_BAL_POP,	PSEUDO_OP,		-1)

OP("bc1f",	Y_BC1F_OP,	BC_TYPE_INST,		0x45000000)
OP("bc1fl",	Y_BC1FL_OP,	BC_TYPE_INST,		0x45020000)	/* MIPS32 */
OP("bc1t",	Y_BC1T_OP,	BC_TYPE_INST,		0x45010000)
OP("bc1tl",	Y_BC1TL_OP,	BC_TYPE_INST,		0x45030000)	/* MIPS32 */

OP("bc2f",	Y_BC2F_OP,	BC_TYPE_INST,		0x49000000)
OP("bc2fl",	Y_BC2FL_OP,	BC_TYPE_INST,		0x49020000)	/* MIPS32 */
OP("bc2t",	Y_BC2T_OP,	BC_TYPE_INST,		0x49010000)
OP("bc2tl",	Y_BC2TL_OP,	BC_TYPE_INST,		0x49030000)	/* MIPS32 */

OP("beq",	Y_BEQ_OP,	B2_TYPE_INST,		0x10000000)
OP("beql",	Y_BEQL_OP,	B2_TYPE_INST,		0x50000000)	/* MIPS32 */
OP("beqz",	Y_BEQZ_POP,	PSEUDO_OP,		-1)
OP("bge",	Y_BGE_POP,	PSEUDO_OP,		-1)
OP("bgeu",	Y_BGEU_POP,	PSEUDO_OP,		-1)
OP("bgez",	Y_BGEZ_OP,	B1_TYPE_INST,		0x04010000)
OP("bgezal",	Y_BGEZAL_OP,	B1_TYPE_INST,		0x04110000)
OP("bgezall",	Y_BGEZALL_OP,	B1_TYPE_INST,		0x04130000)	/* MIPS32 */
OP("bgezl",	Y_BGEZL_OP,	B1_TYPE_INST,		0x04030000)	/* MIPS32 */
OP("bgt",	Y_BGT_POP,	PSEUDO_OP,		-1)
OP("bgtu",	Y_BGTU_POP,	PSEUDO_OP,		-1)
OP("bgtz",	Y_BGTZ_OP,	B1_TYPE_INST,		0x1c000000)
OP("bgtzl",	Y_BGTZL_OP,	B1_TYPE_INST,		0x5c000000)	/* MIPS32 */
OP("ble",	Y_BLE_POP,	PSEUDO_OP,		-1)
OP("bleu",	Y_BLEU_POP,	PSEUDO_OP,		-1)
OP("blez",	Y_BLEZ_OP,	B1_TYPE_INST,		0x18000000)
OP("blezl",	Y_BLEZL_OP,	B1_TYPE_INST,		0x58000000)	/* MIPS32 */
OP("blt",	Y_BLT_POP,	PSEUDO_OP,		-1)
OP("bltu",	Y_BLTU_POP,	PSEUDO_OP,		-1)
OP("bltz",	Y_BLTZ_OP,	B1_TYPE_INST,		0x04000000)
OP("bltzal",	Y_BLTZAL_OP,	B1_TYPE_INST,		0x04100000)
OP("bltzall",	Y_BLTZALL_OP,	B1_TYPE_INST,		0x04120000)	/* MIPS32 */
OP("bltzl",	Y_BLTZL_OP,	B1_TYPE_INST,		0x04020000)	/* MIPS32 */
OP("bne",	Y_BNE_OP,	B2_TYPE_INST,		0x14000000)
OP("bnel",	Y_BNEL_OP,	B2_TYPE_INST,		0x54000000)	/* MIPS32 */
OP("bnez",	Y_BNEZ_POP,	PSEUDO_OP,		-1)

OP("break",	Y_BREAK_OP,	R1d_TYPE_INST,		0x0000000d)

OP("c.eq.d",	Y_C_EQ_D_OP,	FP_CMP_TYPE_INST,	0x46200032)
OP("c.eq.ps",	Y_C_EQ_PS_OP,	FP_CMP_TYPE_INST,	0x46600032)	/* MIPS32 Rev 2 */
OP("c.eq.s",	Y_C_EQ_S_OP,	FP_CMP_TYPE_INST,	0x46000032)
OP("c.f.d",	Y_C_F_D_OP,	FP_CMP_TYPE_INST,	0x46200030)
OP("c.f.ps",	Y_C_F_PS_OP,	FP_CMP_TYPE_INST,	0x46600030)	/* MIPS32 Rev 2 */
OP("c.f.s",	Y_C_F_S_OP,	FP_CMP_TYPE_INST,	0x46000030)
OP("c.le.d",	Y_C_LE_D_OP,	FP_CMP_TYPE_INST,	0x4620003e)
OP("c.le.ps",	Y_C_LE_PS_OP,	FP_CMP_TYPE_INST,	0x4660003e)	/* MIPS32 Rev 2 */
OP("c.le.s",	Y_C_LE_S_OP,	FP_CMP_TYPE_INST,	0x4600003e)
OP("c.lt.d",	Y_C_LT_D_OP,	FP_CMP_TYPE_INST,	0x4620003c)
OP("c.lt.ps",	Y_C_LT_PS_OP,	FP_CMP_TYPE_INST,	0x4660003c)	/* MIPS32 Rev 2 */
OP("c.lt.s",	Y_C_LT_S_OP,	FP_CMP_TYPE_INST,	0x4600003c)
OP("c.nge.d",	Y_C_NGE_D_OP,	FP_CMP_TYPE_INST,	0x4620003d)
OP("c.nge.ps",	Y_C_NGE_PS_OP,	FP_CMP_TYPE_INST,	0x4660003d)	/* MIPS32 Rev 2 */
OP("c.nge.s",	Y_C_NGE_S_OP,	FP_CMP_TYPE_INST,	0x4600003d)
OP("c.ngl.d",	Y_C_NGL_D_OP,	FP_CMP_TYPE_INST,	0x4620003b)
OP("c.ngl.ps",	Y_C_NGL_PS_OP,	FP_CMP_TYPE_INST,	0x4660003b)	/* MIPS32 Rev 2 */
OP("c.ngl.s",	Y_C_NGL_S_OP,	FP_CMP_TYPE_INST,	0x4600003b)
OP("c.ngle.d",	Y_C_NGLE_D_OP,	FP_CMP_TYPE_INST,	0x46200039)
OP("c.ngle.ps",	Y_C_NGLE_PS_OP,	FP_CMP_TYPE_INST,	0x46600039)	/* MIPS32 Rev 2 */
OP("c.ngle.s",	Y_C_NGLE_S_OP,	FP_CMP_TYPE_INST,	0x46000039)
OP("c.ngt.d",	Y_C_NGT_D_OP,	FP_CMP_TYPE_INST,	0x4620003f)
OP("c.ngt.ps",	Y_C_NGT_PS_OP,	FP_CMP_TYPE_INST,	0x4660003f)	/* MIPS32 Rev 2 */
OP("c.ngt.s",	Y_C_NGT_S_OP,	FP_CMP_TYPE_INST,	0x4600003f)
OP("c.ole.d",	Y_C_OLE_D_OP,	FP_CMP_TYPE_INST,	0x46200036)
OP("c.ole.ps",	Y_C_OLE_PS_OP,	FP_CMP_TYPE_INST,	0x46600036)	/* MIPS32 Rev 2 */
OP("c.ole.s",	Y_C_OLE_S_OP,	FP_CMP_TYPE_INST,	0x46000036)
OP("c.olt.d",	Y_C_OLT_D_OP,	FP_CMP_TYPE_INST,	0x46200034)
OP("c.olt.ps",	Y_C_OLT_PS_OP,	FP_CMP_TYPE_INST,	0x46600034)	/* MIPS32 Rev 2 */
OP("c.olt.s",	Y_C_OLT_S_OP,	FP_CMP_TYPE_INST,	0x46000034)
OP("c.seq.d",	Y_C_SEQ_D_OP,	FP_CMP_TYPE_INST,	0x4620003a)
OP("c.seq.ps",	Y_C_SEQ_PS_OP,	FP_CMP_TYPE_INST,	0x4660003a)	/* MIPS32 Rev 2 */
OP("c.seq.s",	Y_C_SEQ_S_OP,	FP_CMP_TYPE_INST,	0x4600003a)
OP("c.sf.d",	Y_C_SF_D_OP,	FP_CMP_TYPE_INST,	0x46200038)
OP("c.sf.ps",	Y_C_SF_PS_OP,	FP_CMP_TYPE_INST,	0x46600038)	/* MIPS32 Rev 2 */
OP("c.sf.s",	Y_C_SF_S_OP,	FP_CMP_TYPE_INST,	0x46000038)
OP("c.ueq.d",	Y_C_UEQ_D_OP,	FP_CMP_TYPE_INST,	0x46200033)
OP("c.ueq.ps",	Y_C_UEQ_PS_OP,	FP_CMP_TYPE_INST,	0x46600033)	/* MIPS32 Rev 2 */
OP("c.ueq.s",	Y_C_UEQ_S_OP,	FP_CMP_TYPE_INST,	0x46000033)
OP("c.ule.d",	Y_C_ULE_D_OP,	FP_CMP_TYPE_INST,	0x46200037)
OP("c.ule.ps",	Y_C_ULE_PS_OP,	FP_CMP_TYPE_INST,	0x46600037)	/* MIPS32 Rev 2 */
OP("c.ule.s",	Y_C_ULE_S_OP,	FP_CMP_TYPE_INST,	0x46000037)
OP("c.ult.d",	Y_C_ULT_D_OP,	FP_CMP_TYPE_INST,	0x46200035)
OP("c.ult.ps",	Y_C_ULT_PS_OP,	FP_CMP_TYPE_INST,	0x46600035)	/* MIPS32 Rev 2 */
OP("c.ult.s",	Y_C_ULT_S_OP,	FP_CMP_TYPE_INST,	0x46000035)
OP("c.un.d",	Y_C_UN_D_OP,	FP_CMP_TYPE_INST,	0x46200031)
OP("c.un.ps",	Y_C_UN_PS_OP,	FP_CMP_TYPE_INST,	0x46600031)	/* MIPS32 Rev 2 */
OP("c.un.s",	Y_C_UN_S_OP,	FP_CMP_TYPE_INST,	0x46000031)

OP("cache",	Y_CACHE_OP,	I2_TYPE_INST,		0xbc000000)	/* MIPS32 */

OP("ceil.l.d",	Y_CEIL_L_D_OP,	FP_R2ds_TYPE_INST,	0x4620000a)	/* MIPS32 Rev 2 */
OP("ceil.l.s",	Y_CEIL_L_S_OP,	FP_R2ds_TYPE_INST,	0x4600000a)	/* MIPS32 Rev 2 */
OP("ceil.w.d",	Y_CEIL_W_D_OP,	FP_R2ds_TYPE_INST,	0x4620000e)	/* MIPS32 */
OP("ceil.w.s",	Y_CEIL_W_S_OP,	FP_R2ds_TYPE_INST,	0x4600000e)	/* MIPS32 */

OP("cfc0",	Y_CFC0_OP,	FP_R2ts_TYPE_INST,	0x40400000)
OP("cfc1",	Y_CFC1_OP,	FP_R2ts_TYPE_INST,	0x44400000)
OP("cfc2",	Y_CFC2_OP,	FP_R2ts_TYPE_INST,	0x48400000)

OP("clo",	Y_CLO_OP,	R3_TYPE_INST,		0x70000021)
OP("clz",	Y_CLZ_OP,	R3_TYPE_INST,		0x70000020)

OP("cop2",	Y_COP2_OP,	J_TYPE_INST,		0x4a000000)

OP("ctc0",	Y_CTC0_OP,	FP_R2ts_TYPE_INST,	0x40c00000)
OP("ctc1",	Y_CTC1_OP,	FP_R2ts_TYPE_INST,	0x44c00000)
OP("ctc2",	Y_CTC2_OP,	FP_R2ts_TYPE_INST,	0x48c00000)

OP("cvt.d.l",	Y_CVT_D_L_OP,	FP_R2ds_TYPE_INST,	0x46b00021)	/* MIPS32 Rev 2 */
OP("cvt.d.s",	Y_CVT_D_S_OP,	FP_R2ds_TYPE_INST,	0x46000021)
OP("cvt.d.w",	Y_CVT_D_W_OP,	FP_R2ds_TYPE_INST,	0x46200021)
OP("cvt.l.d",	Y_CVT_L_D_OP,	FP_R2ds_TYPE_INST,	0x46200025)	/* MIPS32 Rev 2 */
OP("cvt.l.s",	Y_CVT_L_S_OP,	FP_R2ds_TYPE_INST,	0x46000025)	/* MIPS32 Rev 2 */
OP("cvt.ps.s",	Y_CVT_PS_S_OP,	FP_R2ds_TYPE_INST,	0x46000026)	/* MIPS32 Rev 2 */
OP("cvt.s.d",	Y_CVT_S_D_OP,	FP_R2ds_TYPE_INST,	0x46200020)
OP("cvt.s.l",	Y_CVT_S_L_OP,	FP_R2ds_TYPE_INST,	0x46b00020)	/* MIPS32 Rev 2 */
OP("cvt.s.pl",	Y_CVT_S_PL_OP,	FP_R2ds_TYPE_INST,	0x46c00024)	/* MIPS32 Rev 2 */
OP("cvt.s.pu",	Y_CVT_S_PU_OP,	FP_R2ds_TYPE_INST,	0x46c00020)	/* MIPS32 Rev 2 */
OP("cvt.s.w",	Y_CVT_S_W_OP,	FP_R2ds_TYPE_INST,	0x46800020)
OP("cvt.w.d",	Y_CVT_W_D_OP,	FP_R2ds_TYPE_INST,	0x46200024)
OP("cvt.w.s",	Y_CVT_W_S_OP,	FP_R2ds_TYPE_INST,	0x46000024)

OP("deret",	Y_DERET_OP,	NOARG_TYPE_INST,	0x4200001f)	/* MIPS32 Rev 2 */
OP("di",	Y_DI_OP,	I1t_TYPE_INST,		0x41606000)	/* MIPS32 Rev 2 */

OP("div",	Y_DIV_OP,	R2st_TYPE_INST,		0x0000001a)
OP("div.d",	Y_DIV_D_OP,	FP_R3_TYPE_INST,	0x46200003)
OP("div.s",	Y_DIV_S_OP,	FP_R3_TYPE_INST,	0x46000003)
OP("divu",	Y_DIVU_OP,	R2st_TYPE_INST,		0x0000001b)

OP("ehb",	Y_EHB_OP,	NOARG_TYPE_INST,	0x000000c0)	/* MIPS32 Rev 2 */
OP("ei",	Y_EI_OP,	I1t_TYPE_INST,		0x41606020)	/* MIPS32 Rev 2 */
OP("eret",	Y_ERET_OP,	NOARG_TYPE_INST,	0x42000018)	/* MIPS32 */
OP("ext",	Y_EXT_OP,	FP_R2ds_TYPE_INST,	0x7c000000)	/* MIPS32 Rev 2 */

OP("floor.l.d",	Y_FLOOR_L_D_OP,	FP_R2ds_TYPE_INST,	0x4620000b)	/* MIPS32 Rev 2 */
OP("floor.l.s",	Y_FLOOR_L_S_OP,	FP_R2ds_TYPE_INST,	0x4600000b)	/* MIPS32 Rev 2 */
OP("floor.w.d",	Y_FLOOR_W_D_OP,	FP_R2ds_TYPE_INST,	0x4620000f)	/* MIPS32 */
OP("floor.w.s",	Y_FLOOR_W_S_OP,	FP_R2ds_TYPE_INST,	0x4600000f)	/* MIPS32 */

OP("ins",	Y_INS_OP,	FP_R2ds_TYPE_INST,	0x7c000004)	/* MIPS32 Rev 2 */

OP("j",		Y_J_OP,		J_TYPE_INST,		0x08000000)
OP("jal",	Y_JAL_OP,	J_TYPE_INST,		0x0c000000)
OP("jalr",	Y_JALR_OP,	R2ds_TYPE_INST,		0x00000009)
OP("jalr.hb",	Y_JALR_HB_OP,	R2ds_TYPE_INST,		0x00000409)	/* MIPS32 Rev 2 */

OP("jr",	Y_JR_OP,	R1s_TYPE_INST,		0x00000008)
OP("jr.hb",	Y_JR_HB_OP,	R1s_TYPE_INST,		0x00000408)	/* MIPS32 Rev 2 */

OP("l.d",	Y_L_D_POP,	PSEUDO_OP,		-1)
OP("l.s",	Y_L_S_POP,	PSEUDO_OP,		-1)

OP("la",	Y_LA_POP,	PSEUDO_OP,		-1)
OP("lb",	Y_LB_OP,	I2a_TYPE_INST,		0x80000000)
OP("lbu",	Y_LBU_OP,	I2a_TYPE_INST,		0x90000000)
OP("ld",	Y_LD_POP,	PSEUDO_OP,		-1)
OP("ldc1",	Y_LDC1_OP,	FP_I2a_TYPE_INST,	0xd4000000)	/* MIPS32 */
OP("ldc2",	Y_LDC2_OP,	I2a_TYPE_INST,		0xd8000000)	/* MIPS32 */
OP("ldxc1",	Y_LDXC1_OP,	FP_R3_TYPE_INST,	0x4c000001)	/* MIPS32 Rev 2 */
OP("lh",	Y_LH_OP,	I2a_TYPE_INST,		0x84000000)
OP("lhu",	Y_LHU_OP,	I2a_TYPE_INST,		0x94000000)

OP("li",	Y_LI_POP,	PSEUDO_OP,		-1)
OP("li.d",	Y_LI_D_POP,	PSEUDO_OP,		-1)
OP("li.s",	Y_LI_S_POP,	PSEUDO_OP,		-1)

OP("ll",	Y_LL_OP,	I2a_TYPE_INST,		0xc0000000)	/* MIPS32 */

OP("lui",	Y_LUI_OP,	I1t_TYPE_INST,		0x3c000000)
OP("luxc1",	Y_LUXC1_OP,	FP_R3_TYPE_INST,	0x4c000005)	/* MIPS32 Rev 2 */

OP("lw",	Y_LW_OP,	I2a_TYPE_INST,		0x8c000000)
OP("lwc1",	Y_LWC1_OP,	FP_I2a_TYPE_INST,	0xc4000000)
OP("lwc2",	Y_LWC2_OP,	I2a_TYPE_INST,		0xc8000000)
OP("lwl",	Y_LWL_OP,	I2a_TYPE_INST,		0x88000000)
OP("lwr",	Y_LWR_OP,	I2a_TYPE_INST,		0x98000000)
OP("lwxc1",	Y_LWXC1_OP,	FP_R3_TYPE_INST,	0x4c000000)	/* MIPS32 Rev 2 */

OP("madd",	Y_MADD_OP,	R2st_TYPE_INST,		0x70000000)	/* MIPS32 */
OP("madd.d",	Y_MADD_D_OP,	FP_R4_TYPE_INST,	0x4c000001)	/* MIPS32 Rev 2 */
OP("madd.ps",	Y_MADD_PS_OP,	FP_R4_TYPE_INST,	0x4c000006)	/* MIPS32 Rev 2 */
OP("madd.s",	Y_MADD_S_OP,	FP_R4_TYPE_INST,	0x4c000000)	/* MIPS32 Rev 2 */
OP("maddu",	Y_MADDU_OP,	R2st_TYPE_INST,		0x70000001)	/* MIPS32 */

OP("mfc0",	Y_MFC0_OP,	R2td_TYPE_INST,		0x40000000)
OP("mfc1",	Y_MFC1_OP,	FP_R2ts_TYPE_INST,	0x44000000)
OP("mfc1.d",	Y_MFC1_D_POP,	PSEUDO_OP,		-1)
OP("mfc2",	Y_MFC2_OP,	R2td_TYPE_INST,		0x48000000)
OP("mfhc1",	Y_MFHC1_OP,	FP_R2ts_TYPE_INST,	0x44600000)	/* MIPS32 Rev 2 */
OP("mfhc2",	Y_MFHC2_OP,	R2td_TYPE_INST,		0x48600000)	/* MIPS32 Rev 2 */
OP("mfhi",	Y_MFHI_OP,	R1d_TYPE_INST,		0x00000010)
OP("mflo",	Y_MFLO_OP,	R1d_TYPE_INST,		0x00000012)

OP("mov.d",	Y_MOV_D_OP,	FP_R2ds_TYPE_INST,	0x46200006)
OP("mov.ps",	Y_MOV_PS_OP,	FP_R2ds_TYPE_INST,	0x46c00006)	/* MIPS32 Rev 2 */
OP("mov.s",	Y_MOV_S_OP,	FP_R2ds_TYPE_INST,	0x46000006)
OP("move",	Y_MOVE_POP,	PSEUDO_OP,		-1)

OP("movf",	Y_MOVF_OP,	FP_MOVC_TYPE_INST,	0x00000001)	/* MIPS32 */
OP("movf.d",	Y_MOVF_D_OP,	FP_MOVC_TYPE_INST,	0x46200011)	/* MIPS32 */
OP("movf.ps",	Y_MOVF_PS_OP,	FP_MOVC_TYPE_INST,	0x46c00011)	/* MIPS32 Rev 2 */
OP("movf.s",	Y_MOVF_S_OP,	FP_MOVC_TYPE_INST,	0x46000011)	/* MIPS32 */

OP("movn",	Y_MOVN_OP,	R3_TYPE_INST,		0x0000000b)	/* MIPS32 */
OP("movn.d",	Y_MOVN_D_OP,	FP_MOVC_TYPE_INST,	0x46200013)	/* MIPS32 */
OP("movn.ps",	Y_MOVN_PS_OP,	FP_MOVC_TYPE_INST,	0x46c00013)	/* MIPS32 Rev 2 */
OP("movn.s",	Y_MOVN_S_OP,	FP_MOVC_TYPE_INST,	0x46000013)	/* MIPS32 */

OP("movt",	Y_MOVT_OP,	FP_MOVC_TYPE_INST,	0x00010001)	/* MIPS32 */
OP("movt.d",	Y_MOVT_D_OP,	FP_MOVC_TYPE_INST,	0x46210011)	/* MIPS32 */
OP("movt.ps",	Y_MOVT_PS_OP,	FP_MOVC_TYPE_INST,	0x46c10011)	/* MIPS32 Rev 2 */
OP("movt.s",	Y_MOVT_S_OP,	FP_MOVC_TYPE_INST,	0x46010011)	/* MIPS32 */

OP("movz",	Y_MOVZ_OP,	R3_TYPE_INST,		0x0000000a)	/* MIPS32 */
OP("movz.d",	Y_MOVZ_D_OP,	FP_MOVC_TYPE_INST,	0x46200012)	/* MIPS32 */
OP("movz.ps",	Y_MOVZ_PS_OP,	FP_MOVC_TYPE_INST,	0x46c00012)	/* MIPS32 Rev 2 */
OP("movz.s",	Y_MOVZ_S_OP,	FP_MOVC_TYPE_INST,	0x46000012)	/* MIPS32 */

OP("msub",	Y_MSUB_OP,	R2st_TYPE_INST,		0x70000004)	/* MIPS32 */
OP("msub.d",	Y_MSUB_D_OP,	FP_R4_TYPE_INST,	0x4c000021)	/* MIPS32 Rev 2 */
OP("msub.ps",	Y_MSUB_PS_OP,	FP_R4_TYPE_INST,	0x4c000026)	/* MIPS32 Rev 2 */
OP("msub.s",	Y_MSUB_S_OP,	FP_R4_TYPE_INST,	0x4c000020)	/* MIPS32 Rev 2 */
OP("msubu",	Y_MSUBU_OP,	R2st_TYPE_INST,		0x70000005)	/* MIPS32 */

OP("mtc0",	Y_MTC0_OP,	R2td_TYPE_INST,		0x40800000)
OP("mtc1",	Y_MTC1_OP,	FP_R2ts_TYPE_INST,	0x44800000)
OP("mtc1.d",	Y_MTC1_D_POP,	PSEUDO_OP,		-1)
OP("mtc2",	Y_MTC2_OP,	R2td_TYPE_INST,		0x48800000)
OP("mthc1",	Y_MTHC1_OP,	FP_R2ts_TYPE_INST,	0x44e00000)	/* MIPS32 Rev 2 */
OP("mthc2",	Y_MTHC2_OP,	R2td_TYPE_INST,		0x48e00000)	/* MIPS32 Rev 2 */

OP("mthi",	Y_MTHI_OP,	R1s_TYPE_INST,		0x00000011)
OP("mtlo",	Y_MTLO_OP,	R1s_TYPE_INST,		0x00000013)

OP("mul",	Y_MUL_OP,	R3_TYPE_INST,		0x70000002)	/* MIPS32 */
OP("mul.d",	Y_MUL_D_OP,	FP_R3_TYPE_INST,	0x46200002)
OP("mul.ps",	Y_MUL_PS_OP,	FP_R3_TYPE_INST,	0x46c00002)	/* MIPS32 Rev 2 */
OP("mul.s",	Y_MUL_S_OP,	FP_R3_TYPE_INST,	0x46000002)
OP("mulo",	Y_MULO_POP,	PSEUDO_OP,		-1)
OP("mulou",	Y_MULOU_POP,	PSEUDO_OP,		-1)
OP("mult",	Y_MULT_OP,	R2st_TYPE_INST,		0x00000018)
OP("multu",	Y_MULTU_OP,	R2st_TYPE_INST,		0x00000019)

OP("neg",	Y_NEG_POP,	PSEUDO_OP,		-1)
OP("neg.d",	Y_NEG_D_OP,	FP_R2ds_TYPE_INST,	0x46200007)
OP("neg.ps",	Y_NEG_PS_OP,	FP_R2ds_TYPE_INST,	0x46c00007)	/* MIPS32 Rev 2 */
OP("neg.s",	Y_NEG_S_OP,	FP_R2ds_TYPE_INST,	0x46000007)
OP("negu",	Y_NEGU_POP,	PSEUDO_OP,		-1)

OP("nmadd.d",	Y_NMADD_D_OP,	FP_R4_TYPE_INST,	0x4c000031)	/* MIPS32 Rev 2 */
OP("nmadd.ps",	Y_NMADD_PS_OP,	FP_R4_TYPE_INST,	0x4c000036)	/* MIPS32 Rev 2 */
OP("nmadd.s",	Y_NMADD_S_OP,	FP_R4_TYPE_INST,	0x4c000030)	/* MIPS32 Rev 2 */
OP("nmsub.d",	Y_NMSUB_D_OP,	FP_R4_TYPE_INST,	0x4c000039)	/* MIPS32 Rev 2 */
OP("nmsub.ps",	Y_NMSUB_PS_OP,	FP_R4_TYPE_INST,	0x4c00003e)	/* MIPS32 Rev 2 */
OP("nmsub.s",	Y_NMSUB_S_OP,	FP_R4_TYPE_INST,	0x4c000038)	/* MIPS32 Rev 2 */

OP("nop",	Y_NOP_POP,	PSEUDO_OP,		-1)
OP("nor",	Y_NOR_OP,	R3_TYPE_INST,		0x00000027)
OP("not",	Y_NOT_POP,	PSEUDO_OP,		-1)
OP("or",	Y_OR_OP,	R3_TYPE_INST,		0x00000025)
OP("ori",	Y_ORI_OP,	I2_TYPE_INST,		0x34000000)

OP("pll.ps",	Y_PLL_PS_OP,	FP_R3_TYPE_INST,	0x46c0002c)	/* MIPS32 Rev 2 */
OP("plu.ps",	Y_PLU_PS_OP,	FP_R3_TYPE_INST,	0x46c0002d)	/* MIPS32 Rev 2 */

OP("pref",	Y_PREF_OP,	I2_TYPE_INST,		0xcc000000)	/* MIPS32 */
OP("prefx",	Y_PREFX_OP,	R2st_TYPE_INST,		0x4600000f)	/* MIPS32 Rev 2 */
OP("pul.ps",	Y_PUL_PS_OP,	FP_R3_TYPE_INST,	0x46c0002e)	/* MIPS32 Rev 2 */
OP("puu.ps",	Y_PUU_PS_OP,	FP_R3_TYPE_INST,	0x46c0002f)	/* MIPS32 Rev 2 */

OP("rdhwr",	Y_RDHWR_OP,	R3_TYPE_INST,		0x7c00003b)	/* MIPS32 Rev 2 */
OP("rdpgpr",	Y_RDPGPR_OP,	R2td_TYPE_INST,		0x41400000)	/* MIPS32 Rev 2 */

OP("recip.d",	Y_RECIP_D_OP,	FP_R2ds_TYPE_INST,	0x46200015)	/* MIPS32 Rev 2 */
OP("recip.s",	Y_RECIP_S_OP,	FP_R2ds_TYPE_INST,	0x46000015)	/* MIPS32 Rev 2 */

OP("rem",	Y_REM_POP,	PSEUDO_OP,		-1)
OP("remu",	Y_REMU_POP,	PSEUDO_OP,		-1)

OP("rfe",	Y_RFE_OP,	NOARG_TYPE_INST,	0x42000010)

OP("rol",	Y_ROL_POP,	PSEUDO_OP,		-1)
OP("ror",	Y_ROR_POP,	PSEUDO_OP,		-1)
OP("rotr",	Y_ROTR_OP,	R2sh_TYPE_INST,		0x00200002)	/* MIPS32 Rev 2 */
OP("rotrv",	Y_ROTRV_OP,	R2sh_TYPE_INST,		0x00200003)	/* MIPS32 Rev 2 */

OP("round.l.d",	Y_ROUND_L_D_OP,	FP_R2ds_TYPE_INST,	0x46200008)	/* MIPS32 Rev 2 */
OP("round.l.s",	Y_ROUND_L_S_OP,	FP_R2ds_TYPE_INST,	0x46000008)	/* MIPS32 Rev 2 */
OP("round.w.d",	Y_ROUND_W_D_OP,	FP_R2ds_TYPE_INST,	0x4620000c)	/* MIPS32 */
OP("round.w.s",	Y_ROUND_W_S_OP,	FP_R2ds_TYPE_INST,	0x4600000c)	/* MIPS32 */

OP("rsqrt.d",	Y_RSQRT_D_OP,	FP_R2ds_TYPE_INST,	0x46200016)	/* MIPS32 Rev 2 */
OP("rsqrt.s",	Y_RSQRT_S_OP,	FP_R2ds_TYPE_INST,	0x46000016)	/* MIPS32 Rev 2 */

OP("s.d",	Y_S_D_POP,	PSEUDO_OP,		-1)
OP("s.s",	Y_S_S_POP,	PSEUDO_OP,		-1)

OP("sb",	Y_SB_OP,	I2a_TYPE_INST,		0xa0000000)
OP("sc",	Y_SC_OP,	I2a_TYPE_INST,		0xe0000000)	/* MIPS32 */
OP("sd",	Y_SD_POP,	PSEUDO_OP,		-1)
OP("sdbbp",	Y_SDBBP_OP,	NOARG_TYPE_INST,	0x7000003f)	/* MIPS32 Rev 2*/
OP("sdc1",	Y_SDC1_OP,	FP_I2a_TYPE_INST,	0xf4000000)	/* MIPS32 */
OP("sdc2",	Y_SDC2_OP,	I2a_TYPE_INST,		0xf8000000)	/* MIPS32 */
OP("sdxc1",	Y_SDXC1_OP,	FP_R3_TYPE_INST,	0x46000009)	/* MIPS32 Rev 2 */

OP("seb",	Y_SEB_OP,	R2td_TYPE_INST,		0x7c000420)	/* MIPS32 Rev 2 */
OP("seh",	Y_SEH_OP,	R2td_TYPE_INST,		0x7c000620)	/* MIPS32 Rev 2 */
OP("seq",	Y_SEQ_POP,	PSEUDO_OP,		-1)
OP("sge",	Y_SGE_POP,	PSEUDO_OP,		-1)
OP("sgeu",	Y_SGEU_POP,	PSEUDO_OP,		-1)
OP("sgt",	Y_SGT_POP,	PSEUDO_OP,		-1)
OP("sgtu",	Y_SGTU_POP,	PSEUDO_OP,		-1)

OP("sh",	Y_SH_OP,	I2a_TYPE_INST,		0xa4000000)
OP("sle",	Y_SLE_POP,	PSEUDO_OP,		-1)
OP("sleu",	Y_SLEU_POP,	PSEUDO_OP,		-1)
OP("sll",	Y_SLL_OP,	R2sh_TYPE_INST,		0x00000000)
OP("sllv",	Y_SLLV_OP,	R3sh_TYPE_INST,		0x00000004)

OP("slt",	Y_SLT_OP,	R3_TYPE_INST,		0x0000002a)
OP("slti",	Y_SLTI_OP,	I2_TYPE_INST,		0x28000000)
OP("sltiu",	Y_SLTIU_OP,	I2_TYPE_INST,		0x2c000000)
OP("sltu",	Y_SLTU_OP,	R3_TYPE_INST,		0x0000002b)
OP("sne",	Y_SNE_POP,	PSEUDO_OP,		-1)

OP("sqrt.d",	Y_SQRT_D_OP,	FP_R2ds_TYPE_INST,	0x46200004)	/* MIPS32 */
OP("sqrt.s",	Y_SQRT_S_OP,	FP_R2ds_TYPE_INST,	0x46000004)	/* MIPS32 */

OP("sra",	Y_SRA_OP,	R2sh_TYPE_INST,		0x00000003)
OP("srav",	Y_SRAV_OP,	R3sh_TYPE_INST,		0x00000007)
OP("srl",	Y_SRL_OP,	R2sh_TYPE_INST,		0x00000002)
OP("srlv",	Y_SRLV_OP,	R3sh_TYPE_INST,		0x00000006)

OP("ssnop",	Y_SSNOP_OP,	R2sh_TYPE_INST,		0x00000040)	/* MIPS32 */

OP("sub",	Y_SUB_OP,	R3_TYPE_INST,		0x00000022)
OP("sub.d",	Y_SUB_D_OP,	FP_R3_TYPE_INST,	0x46200001)
OP("sub.ps",	Y_SUB_PS_OP,	FP_R3_TYPE_INST,	0x46600001)	/* MIPS32 Rev 2 */
OP("sub.s",	Y_SUB_S_OP,	FP_R3_TYPE_INST,	0x46000001)
OP("subu",	Y_SUBU_OP,	R3_TYPE_INST,		0x00000023)

OP("suxc1",	Y_SUXC1_OP,	FP_R3_TYPE_INST,	0x4600000d)	/* MIPS32 Rev 2 */

OP("sw",	Y_SW_OP,	I2a_TYPE_INST,		0xac000000)
OP("swc1",	Y_SWC1_OP,	FP_I2a_TYPE_INST,	0xe4000000)
OP("swc2",	Y_SWC2_OP,	I2a_TYPE_INST,		0xe8000000)
OP("swl",	Y_SWL_OP,	I2a_TYPE_INST,		0xa8000000)
OP("swr",	Y_SWR_OP,	I2a_TYPE_INST,		0xb8000000)
OP("swxc1",	Y_SWXC1_OP,	FP_R3_TYPE_INST,	0x46000008)	/* MIPS32 Rev 2 */

OP("sync",	Y_SYNC_OP,	NOARG_TYPE_INST,	0x0000000f)	/* MIPS32 */
OP("synci",	Y_SYNCI_OP,	I2_TYPE_INST,		0x04140000)	/* MIPS32 Rev 2 */
OP("syscall",	Y_SYSCALL_OP,	NOARG_TYPE_INST,	0x0000000c)

OP("teq",	Y_TEQ_OP,	R2st_TYPE_INST,		0x00000034)	/* MIPS32 */
OP("teqi",	Y_TEQI_OP,	I1s_TYPE_INST,		0x040c0000)	/* MIPS32 */
OP("tge",	Y_TGE_OP,	R2st_TYPE_INST,		0x00000030)	/* MIPS32 */
OP("tgei",	Y_TGEI_OP,	I1s_TYPE_INST,		0x04080000)	/* MIPS32 */
OP("tgeiu",	Y_TGEIU_OP,	I1s_TYPE_INST,		0x04090000)	/* MIPS32 */
OP("tgeu",	Y_TGEU_OP,	R2st_TYPE_INST,		0x00000031)	/* MIPS32 */

OP("tlbp",	Y_TLBP_OP,	NOARG_TYPE_INST,	0x42000008)
OP("tlbr",	Y_TLBR_OP,	NOARG_TYPE_INST,	0x42000001)
OP("tlbwi",	Y_TLBWI_OP,	NOARG_TYPE_INST,	0x42000002)
OP("tlbwr",	Y_TLBWR_OP,	NOARG_TYPE_INST,	0x42000006)

OP("tlt",	Y_TLT_OP,	R2st_TYPE_INST,		0x00000032)	/* MIPS32 */
OP("tlti",	Y_TLTI_OP,	I1s_TYPE_INST,		0x040a0000)	/* MIPS32 */
OP("tltiu",	Y_TLTIU_OP,	I1s_TYPE_INST,		0x040b0000)	/* MIPS32 */
OP("tltu",	Y_TLTU_OP,	R2st_TYPE_INST,		0x00000033)	/* MIPS32 */
OP("tne",	Y_TNE_OP,	R2st_TYPE_INST,		0x00000036)	/* MIPS32 */
OP("tnei",	Y_TNEI_OP,	I1s_TYPE_INST,		0x040e0000)	/* MIPS32 */

OP("trunc.l.d",	Y_TRUNC_L_D_OP,	FP_R2ds_TYPE_INST,	0x46200009)	/* MIPS32 Rev 2 */
OP("trunc.l.s",	Y_TRUNC_L_S_OP,	FP_R2ds_TYPE_INST,	0x46000009)	/* MIPS32 Rev 2 */
OP("trunc.w.d",	Y_TRUNC_W_D_OP,	FP_R2ds_TYPE_INST,	0x4620000d)	/* MIPS32 */
OP("trunc.w.s",	Y_TRUNC_W_S_OP,	FP_R2ds_TYPE_INST,	0x4600000d)	/* MIPS32 */

OP("ulh",	Y_ULH_POP,	PSEUDO_OP,		-1)
OP("ulhu",	Y_ULHU_POP,	PSEUDO_OP,		-1)
OP("ulw",	Y_ULW_POP,	PSEUDO_OP,		-1)
OP("ush",	Y_USH_POP,	PSEUDO_OP,		-1)
OP("usw",	Y_USW_POP,	PSEUDO_OP,		-1)

OP("wrpgpr",	Y_WRPGPR_OP,	R2td_TYPE_INST,		0x41c00000)	/* MIPS32 Rev 2 */
OP("wsbh",	Y_WSBH_OP,	R2td_TYPE_INST,		0x7c0000a0)	/* MIPS32 Rev 2 */

OP("xor",	Y_XOR_OP,	R3_TYPE_INST,		0x00000026)
OP("xori",	Y_XORI_OP,	I2_TYPE_INST,		0x38000000)
/* SPIM S20 MIPS simulator.
   Interface to parser for instructions and assembler directives.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/parser.h 8     2/15/04 1:27p Larus $
*/


/* Exported functions: */

void fix_current_label_address (mem_addr new_addr);
int imm_op_to_op (int opcode);
void initialize_parser (char *file_name);
int op_to_imm_op (int opcode);
void yyerror (char *s);
int yyparse ();


/* Exported Variables: */

extern int data_dir;		/* Non-zero means item in data segment */

extern int text_dir;		/* Non-zero means item in text segment */

extern int parse_error_occurred;  /* Non-zero => parse resulted in error */
/* SPIM S20 MIPS simulator.
   Parser for instructions and assembler directives.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: $
*/



%start LINE

%token Y_EOF

%token Y_NL
%token Y_INT
%token Y_ID
%token Y_REG
%token Y_FP_REG
%token Y_STR
%token Y_FP

/* MIPS instructions op codes: */

%token Y_ABS_D_OP
%token Y_ABS_PS_OP
%token Y_ABS_S_OP
%token Y_ADD_D_OP
%token Y_ADD_OP
%token Y_ADD_PS_OP
%token Y_ADD_S_OP
%token Y_ADDI_OP
%token Y_ADDIU_OP
%token Y_ADDU_OP
%token Y_ALNV_PS_OP
%token Y_AND_OP
%token Y_ANDI_OP
%token Y_BC1F_OP
%token Y_BC1FL_OP
%token Y_BC1T_OP
%token Y_BC1TL_OP
%token Y_BC2F_OP
%token Y_BC2FL_OP
%token Y_BC2T_OP
%token Y_BC2TL_OP
%token Y_BEQ_OP
%token Y_BEQL_OP
%token Y_BGEZ_OP
%token Y_BGEZAL_OP
%token Y_BGEZALL_OP
%token Y_BGEZL_OP
%token Y_BGTZ_OP
%token Y_BGTZL_OP
%token Y_BLEZ_OP
%token Y_BLEZL_OP
%token Y_BLTZ_OP
%token Y_BLTZAL_OP
%token Y_BLTZALL_OP
%token Y_BLTZL_OP
%token Y_BNE_OP
%token Y_BNEL_OP
%token Y_BREAK_OP
%token Y_C_EQ_D_OP
%token Y_C_EQ_PS_OP
%token Y_C_EQ_S_OP
%token Y_C_F_D_OP
%token Y_C_F_PS_OP
%token Y_C_F_S_OP
%token Y_C_LE_D_OP
%token Y_C_LE_PS_OP
%token Y_C_LE_S_OP
%token Y_C_LT_D_OP
%token Y_C_LT_PS_OP
%token Y_C_LT_S_OP
%token Y_C_NGE_D_OP
%token Y_C_NGE_PS_OP
%token Y_C_NGE_S_OP
%token Y_C_NGL_D_OP
%token Y_C_NGL_PS_OP
%token Y_C_NGL_S_OP
%token Y_C_NGLE_D_OP
%token Y_C_NGLE_PS_OP
%token Y_C_NGLE_S_OP
%token Y_C_NGT_D_OP
%token Y_C_NGT_PS_OP
%token Y_C_NGT_S_OP
%token Y_C_OLE_D_OP
%token Y_C_OLE_PS_OP
%token Y_C_OLE_S_OP
%token Y_C_OLT_D_OP
%token Y_C_OLT_PS_OP
%token Y_C_OLT_S_OP
%token Y_C_SEQ_D_OP
%token Y_C_SEQ_PS_OP
%token Y_C_SEQ_S_OP
%token Y_C_SF_D_OP
%token Y_C_SF_PS_OP
%token Y_C_SF_S_OP
%token Y_C_UEQ_D_OP
%token Y_C_UEQ_PS_OP
%token Y_C_UEQ_S_OP
%token Y_C_ULE_D_OP
%token Y_C_ULE_PS_OP
%token Y_C_ULE_S_OP
%token Y_C_ULT_D_OP
%token Y_C_ULT_PS_OP
%token Y_C_ULT_S_OP
%token Y_C_UN_D_OP
%token Y_C_UN_PS_OP
%token Y_C_UN_S_OP
%token Y_CACHE_OP
%token Y_CEIL_L_D_OP
%token Y_CEIL_L_S_OP
%token Y_CEIL_W_D_OP
%token Y_CEIL_W_S_OP
%token Y_CFC0_OP
%token Y_CFC1_OP
%token Y_CFC2_OP
%token Y_CLO_OP
%token Y_CLZ_OP
%token Y_COP2_OP
%token Y_CTC0_OP
%token Y_CTC1_OP
%token Y_CTC2_OP
%token Y_CVT_D_L_OP
%token Y_CVT_D_S_OP
%token Y_CVT_D_W_OP
%token Y_CVT_L_D_OP
%token Y_CVT_L_S_OP
%token Y_CVT_PS_S_OP
%token Y_CVT_S_D_OP
%token Y_CVT_S_L_OP
%token Y_CVT_S_PL_OP
%token Y_CVT_S_PU_OP
%token Y_CVT_S_W_OP
%token Y_CVT_W_D_OP
%token Y_CVT_W_S_OP
%token Y_DERET_OP
%token Y_DI_OP
%token Y_DIV_D_OP
%token Y_DIV_OP
%token Y_DIV_S_OP
%token Y_DIVU_OP
%token Y_EHB_OP
%token Y_EI_OP
%token Y_ERET_OP
%token Y_EXT_OP
%token Y_FLOOR_L_D_OP
%token Y_FLOOR_L_S_OP
%token Y_FLOOR_W_D_OP
%token Y_FLOOR_W_S_OP
%token Y_INS_OP
%token Y_J_OP
%token Y_JAL_OP
%token Y_JALR_HB_OP
%token Y_JALR_OP
%token Y_JR_HB_OP
%token Y_JR_OP
%token Y_LB_OP
%token Y_LBU_OP
%token Y_LDC1_OP
%token Y_LDC2_OP
%token Y_LDXC1_OP
%token Y_LH_OP
%token Y_LHU_OP
%token Y_LL_OP
%token Y_LUI_OP
%token Y_LUXC1_OP
%token Y_LW_OP
%token Y_LWC1_OP
%token Y_LWC2_OP
%token Y_LWL_OP
%token Y_LWR_OP
%token Y_LWXC1_OP
%token Y_MADD_D_OP
%token Y_MADD_OP
%token Y_MADD_PS_OP
%token Y_MADD_S_OP
%token Y_MADDU_OP
%token Y_MFC0_OP
%token Y_MFC1_OP
%token Y_MFC2_OP
%token Y_MFHC1_OP
%token Y_MFHC2_OP
%token Y_MFHI_OP
%token Y_MFLO_OP
%token Y_MOV_D_OP
%token Y_MOV_PS_OP
%token Y_MOV_S_OP
%token Y_MOVF_D_OP
%token Y_MOVF_OP
%token Y_MOVF_PS_OP
%token Y_MOVF_S_OP
%token Y_MOVN_D_OP
%token Y_MOVN_OP
%token Y_MOVN_PS_OP
%token Y_MOVN_S_OP
%token Y_MOVT_D_OP
%token Y_MOVT_OP
%token Y_MOVT_PS_OP
%token Y_MOVT_S_OP
%token Y_MOVZ_D_OP
%token Y_MOVZ_OP
%token Y_MOVZ_PS_OP
%token Y_MOVZ_S_OP
%token Y_MSUB_D_OP
%token Y_MSUB_OP
%token Y_MSUB_PS_OP
%token Y_MSUB_S_OP
%token Y_MSUBU_OP
%token Y_MTC0_OP
%token Y_MTC1_OP
%token Y_MTC2_OP
%token Y_MTHC1_OP
%token Y_MTHC2_OP
%token Y_MTHI_OP
%token Y_MTLO_OP
%token Y_MUL_D_OP
%token Y_MUL_PS_OP
%token Y_MUL_S_OP
%token Y_MUL_OP
%token Y_MULT_OP
%token Y_MULTU_OP
%token Y_NEG_D_OP
%token Y_NEG_PS_OP
%token Y_NEG_S_OP
%token Y_NMADD_D_OP
%token Y_NMADD_PS_OP
%token Y_NMADD_S_OP
%token Y_NMSUB_D_OP
%token Y_NMSUB_PS_OP
%token Y_NMSUB_S_OP
%token Y_NOR_OP
%token Y_OR_OP
%token Y_ORI_OP
%token Y_PFW_OP
%token Y_PLL_PS_OP
%token Y_PLU_PS_OP
%token Y_PREF_OP
%token Y_PREFX_OP
%token Y_PUL_PS_OP
%token Y_PUU_PS_OP
%token Y_RDHWR_OP
%token Y_RDPGPR_OP
%token Y_RECIP_D_OP
%token Y_RECIP_S_OP
%token Y_RFE_OP
%token Y_ROTR_OP
%token Y_ROTRV_OP
%token Y_ROUND_L_D_OP
%token Y_ROUND_L_S_OP
%token Y_ROUND_W_D_OP
%token Y_ROUND_W_S_OP
%token Y_RSQRT_D_OP
%token Y_RSQRT_S_OP
%token Y_SB_OP
%token Y_SC_OP
%token Y_SDBBP_OP
%token Y_SDC1_OP
%token Y_SDC2_OP
%token Y_SDXC1_OP
%token Y_SEB_OP
%token Y_SEH_OP
%token Y_SH_OP
%token Y_SLL_OP
%token Y_SLLV_OP
%token Y_SLT_OP
%token Y_SLTI_OP
%token Y_SLTIU_OP
%token Y_SLTU_OP
%token Y_SQRT_D_OP
%token Y_SQRT_S_OP
%token Y_SRA_OP
%token Y_SRAV_OP
%token Y_SRL_OP
%token Y_SRLV_OP
%token Y_SSNOP_OP
%token Y_SUB_D_OP
%token Y_SUB_OP
%token Y_SUB_PS_OP
%token Y_SUB_S_OP
%token Y_SUBU_OP
%token Y_SUXC1_OP
%token Y_SW_OP
%token Y_SWC1_OP
%token Y_SWC2_OP
%token Y_SWL_OP
%token Y_SWR_OP
%token Y_SWXC1_OP
%token Y_SYNC_OP
%token Y_SYNCI_OP
%token Y_SYSCALL_OP
%token Y_TEQ_OP
%token Y_TEQI_OP
%token Y_TGE_OP
%token Y_TGEI_OP
%token Y_TGEIU_OP
%token Y_TGEU_OP
%token Y_TLBP_OP
%token Y_TLBR_OP
%token Y_TLBWI_OP
%token Y_TLBWR_OP
%token Y_TLT_OP
%token Y_TLTI_OP
%token Y_TLTIU_OP
%token Y_TLTU_OP
%token Y_TNE_OP
%token Y_TNEI_OP
%token Y_TRUNC_L_D_OP
%token Y_TRUNC_L_S_OP
%token Y_TRUNC_W_D_OP
%token Y_TRUNC_W_S_OP
%token Y_WRPGPR_OP
%token Y_WSBH_OP
%token Y_XOR_OP
%token Y_XORI_OP


/* Assembler pseudo operations op codes: */

%token Y_ABS_POP
%token Y_B_POP
%token Y_BAL_POP
%token Y_BEQZ_POP
%token Y_BGE_POP
%token Y_BGEU_POP
%token Y_BGT_POP
%token Y_BGTU_POP
%token Y_BLE_POP
%token Y_BLEU_POP
%token Y_BLT_POP
%token Y_BLTU_POP
%token Y_BNEZ_POP
%token Y_LA_POP
%token Y_LD_POP
%token Y_L_D_POP
%token Y_L_S_POP
%token Y_LI_D_POP
%token Y_LI_POP
%token Y_LI_S_POP
%token Y_MFC1_D_POP
%token Y_MOVE_POP
%token Y_MTC1_D_POP
%token Y_MULO_POP
%token Y_MULOU_POP
%token Y_NEG_POP
%token Y_NEGU_POP
%token Y_NOP_POP
%token Y_NOT_POP
%token Y_REM_POP
%token Y_REMU_POP
%token Y_ROL_POP
%token Y_ROR_POP
%token Y_S_D_POP
%token Y_S_S_POP
%token Y_SD_POP
%token Y_SEQ_POP
%token Y_SGE_POP
%token Y_SGEU_POP
%token Y_SGT_POP
%token Y_SGTU_POP
%token Y_SLE_POP
%token Y_SLEU_POP
%token Y_SNE_POP
%token Y_ULH_POP
%token Y_ULHU_POP
%token Y_ULW_POP
%token Y_USH_POP
%token Y_USW_POP

/* Assembler directives: */

%token Y_ALIAS_DIR
%token Y_ALIGN_DIR
%token Y_ASCII_DIR
%token Y_ASCIIZ_DIR
%token Y_ASM0_DIR
%token Y_BGNB_DIR
%token Y_BYTE_DIR
%token Y_COMM_DIR
%token Y_DATA_DIR
%token Y_DOUBLE_DIR
%token Y_END_DIR
%token Y_ENDB_DIR
%token Y_ENDR_DIR
%token Y_ENT_DIR
%token Y_ERR_DIR
%token Y_EXTERN_DIR
%token Y_FILE_DIR
%token Y_FLOAT_DIR
%token Y_FMASK_DIR
%token Y_FRAME_DIR
%token Y_GLOBAL_DIR
%token Y_HALF_DIR
%token Y_K_DATA_DIR
%token Y_K_TEXT_DIR
%token Y_LABEL_DIR
%token Y_LCOMM_DIR
%token Y_LIVEREG_DIR
%token Y_LOC_DIR
%token Y_MASK_DIR
%token Y_NOALIAS_DIR
%token Y_OPTIONS_DIR
%token Y_RDATA_DIR
%token Y_REPEAT_DIR
%token Y_SDATA_DIR
%token Y_SET_DIR
%token Y_SPACE_DIR
%token Y_STRUCT_DIR
%token Y_TEXT_DIR
%token Y_VERSTAMP_DIR
%token Y_VREG_DIR
%token Y_WORD_DIR

/* CS296: Honors project tokens */
%token Y_MACRO_START
%token Y_EQ_MACRO
%token Y_NEQ_MACRO

/* ADD MORE TOKENS HERE */

%{
#include <stdio.h>
#include <math.h>

#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "mem.h"
#include "sym-tbl.h"
#include "data.h"
#include "scanner.h"
#include "parser.h"


/* return (0) */
#define LINE_PARSE_DONE YYACCEPT

/* return (1) */
#define FILE_PARSE_DONE YYABORT

typedef struct ll
{
  label *head;
  struct ll *tail;
} label_list;


/* Exported Variables: */

int data_dir;		/* Non-zero means item in data segment */

int text_dir;		/* Non-zero means item in text segment */

int parse_error_occurred; /* Non-zero => parse resulted in error */


/* Local functions: */

static imm_expr *branch_offset (int n_inst);
static int cc_to_rt (int cc, int nd, int tf);
static void check_imm_range (imm_expr*, int32, int32);
static void check_uimm_range (imm_expr*, uint32, uint32);
static void clear_labels ();
static label_list *cons_label (label *head, label_list *tail);
static void div_inst (int op, int rd, int rs, int rt, int const_divisor);
static void mips32_r2_inst ();
static void mult_inst (int op, int rd, int rs, int rt);
static void nop_inst ();
static void set_eq_inst (int op, int rd, int rs, int rt);
static void set_ge_inst (int op, int rd, int rs, int rt);
static void set_gt_inst (int op, int rd, int rs, int rt);
static void set_le_inst (int op, int rd, int rs, int rt);
static void store_word_data (int value);
static void trap_inst ();
static void yywarn (char*);


/* Local variables: */

static int null_term;		/* Non-zero means string terminate by \0 */

static void (*store_op) ();	/* Function to store items in an EXPR_LST */

static label_list *this_line_labels = NULL; /* List of label for curent line */

static int noat_flag = 0;	/* Non-zero means program can use $1 */

static char *input_file_name;	/* Name of file being parsed */

%}



%%

LINE:		{parse_error_occurred = 0; scanner_start_line (); } LBL_CMD ;

LBL_CMD:	OPT_LBL CMD
	|	CMD
	;


OPT_LBL: ID ':' {
		  /* Call outside of cons_label, since an error sets that variable to NULL. */
		  label* l = record_label ((char*)$1.p,
					   text_dir ? current_text_pc () : current_data_pc (),
					   0);
		  this_line_labels = cons_label (l, this_line_labels);
		  free ((char*)$1.p);
		}

	|	ID '=' Y_INT
		{
		  label *l = record_label ((char*)$1.p, (mem_addr)$3.i, 1);
		  free ((char*)$1.p);

		  l->const_flag = 1;
		  clear_labels ();
		}
	;


CMD:		ASM_CODE
		{
		  clear_labels ();
		}
		TERM

	|	ASM_DIRECTIVE
		{
		  clear_labels ();
		}
		TERM

	|	TERM

	/* CS296: Honors project grammar addition */
	|	HONORS_RULES
    ;

/* CS296: A macro starts with Y_MACRO_START ("#@") followed by one of the available macros */
HONORS_RULES:	Y_MACRO_START MACROS

/* CS296: The skeleton code only provides you with an implementation of:
   #@ $reg1 == $reg2
   Note that you have to also implement #@ $reg1 == some_immediate_value
 */
MACROS:		MACRO_OPERAND1 Y_EQ_MACRO MACRO_OPERAND2
		{
			/* Construct the "Assertion Failed" message should the condition be violated */
			int size1 = (int) log($1.i) + 2, size2 = (int) log($3.i) + 2;
			char *assert_failed = "Assertion failed: ";
			char *assert_msg = malloc(strlen(assert_failed) + size1 + size2 + 7);
			assert_msg[0] = '\0';
			sprintf(assert_msg, "\n%s$%d == $%d\n %d \n", assert_failed, $1.i, $3.i);

			/* Store the current pointer to the data segment which will store the address
			 * of the assertion error string.				
			 */
			int cur_data_pc = current_data_pc();

			/* Store the assertion message on the data segment */
			store_string(assert_msg, strlen(assert_msg), 1);
						
			/* Branch 30 bytes forward if the assertion condition is not violated:
			 * That is, beq MACRO_OPERAND1, MACRO_OPERAND2, 30 bytes forward.				
			 */
			i_type_inst(Y_BEQ_OP, $1.i, const_imm_expr($3.i), const_imm_expr(30));

			/* Load the assertion error string address and store it in $a0 ($4) */
			i_type_inst(Y_ADDI_OP, 4, 0, const_imm_expr(cur_data_pc));

			/* ori $v0, $0, 4   (Equivalent to the pseudoinstruction: li $v0, 4) */
			i_type_inst(Y_ORI_OP, 2, 0, const_imm_expr(4));

			/* syscall (print string)*/
			r_type_inst(Y_SYSCALL_OP, 0, 0, 0);

			/* ori $v0, $0, 10   (Equivalent to the pseudoinstruction: li $v0, 10) */
			i_type_inst(Y_ORI_OP, 2, 0, const_imm_expr(10));

			/* syscall (exit)*/
			r_type_inst(Y_SYSCALL_OP, 0, 0, 0);

			/* We're done parsing the current line. */
			LINE_PARSE_DONE;
		}
        
 |      MACRO_OPERAND1 Y_NEQ_MACRO MACRO_OPERAND2
        {
            
			/* Construct the "Assertion Failed" message should the condition be violated */
			int size1 = (int) log($1.i) + 2, size2 = (int) log($3.i) + 2;
			char *assert_failed = "Assertion failed: ";
			char *assert_msg = malloc(strlen(assert_failed) + size1 + size2 + 7 + 100);
			assert_msg[0] = '\0';
			sprintf(assert_msg, "\n%s$%d != $%d\n", assert_failed, $1.i, $3.i);
			/* Store the current pointer to the data segment which will store the address
			 * of the assertion error string.				
			 */
			int cur_data_pc = current_data_pc();

			store_string(assert_msg, strlen(assert_msg), 1);
			i_type_inst_free(Y_BNE_OP, $1.i, $3.i, const_imm_expr(30));
			i_type_inst(Y_ADDI_OP, 4, 0, const_imm_expr(cur_data_pc));
			i_type_inst(Y_ORI_OP, 2, 0, const_imm_expr(4));
			r_type_inst(Y_SYSCALL_OP, 0, 0, 0);
			i_type_inst(Y_ORI_OP, 2, 0, const_imm_expr(10));
			r_type_inst(Y_SYSCALL_OP, 0, 0, 0);
			LINE_PARSE_DONE;
		}
        ;


/* CS296: Operand 1 of an assertion can only be a register */
MACRO_OPERAND1:	Y_REG 

/* CS296: Operand 2 of an assertion can be a register or an immediate integer. The skeleton
 * code assumes that the second operand is a register.
 */
MACRO_OPERAND2: Y_REG | Y_INT


TERM:		Y_NL
		{
			LINE_PARSE_DONE;
		}

	|	Y_EOF
		{
		  clear_labels ();
		  FILE_PARSE_DONE;
		}
	;



ASM_CODE:	LOAD_OPS	DEST	ADDRESS
		{
		  i_type_inst ($1.i == Y_LD_POP ? Y_LW_OP : $1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  if ($1.i == Y_LD_POP)
		    i_type_inst_free (Y_LW_OP,
				      $2.i + 1,
				      addr_expr_reg ((addr_expr *)$3.p),
				      incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
							4));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}

	|	LOADC_OPS	COP_REG	ADDRESS
		{
		  i_type_inst ($1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}

	|	LOADFP_OPS	F_SRC1	ADDRESS
		{
		  i_type_inst ($1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}

	|	LOADI_OPS	DEST	UIMM16
		{
		  i_type_inst_free ($1.i, $2.i, 0, (imm_expr *)$3.p);
		}


	|	Y_LA_POP	DEST	ADDRESS
		{
		  if (addr_expr_reg ((addr_expr *)$3.p))
		    i_type_inst (Y_ADDI_OP, $2.i,
				 addr_expr_reg ((addr_expr *)$3.p),
				 addr_expr_imm ((addr_expr *)$3.p));
		  else
		    i_type_inst (Y_ORI_OP, $2.i, 0,
				 addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	Y_LI_POP	DEST	IMM32
		{
		  i_type_inst_free (Y_ORI_OP, $2.i, 0, (imm_expr *)$3.p);
		}


	|	Y_LI_D_POP	F_DEST	Y_FP
		{
		  int *x = (int *) $3.p;

		  i_type_inst (Y_ORI_OP, 1, 0, const_imm_expr (*x));
		  r_co_type_inst (Y_MTC1_OP, 0, $2.i, 1);
		  i_type_inst (Y_ORI_OP, 1, 0, const_imm_expr (*(x+1)));
		  r_co_type_inst (Y_MTC1_OP, 0, $2.i + 1, 1);
		}


	|	Y_LI_S_POP	F_DEST	Y_FP
		{
		  float x = (float) *((double *) $3.p);
		  int *y = (int *) &x;

		  i_type_inst (Y_ORI_OP, 1, 0, const_imm_expr (*y));
		  r_co_type_inst (Y_MTC1_OP, 0, $2.i, 1);
		}


	|	Y_ULW_POP	DEST	ADDRESS
		{
#ifdef BIGENDIAN
		  i_type_inst (Y_LWL_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  i_type_inst_free (Y_LWR_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      3));
#else
		  i_type_inst_free (Y_LWL_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      3));
		  i_type_inst (Y_LWR_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
#endif
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	ULOADH_POPS	DEST	ADDRESS
		{
#ifdef BIGENDIAN
		  i_type_inst (($1.i == Y_ULH_POP ? Y_LB_OP : Y_LBU_OP),
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  i_type_inst_free (Y_LBU_OP, 1,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      1));
#else
		  i_type_inst_free (($1.i == Y_ULH_POP ? Y_LB_OP : Y_LBU_OP),
				    $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      1));
		  i_type_inst (Y_LBU_OP, 1,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
#endif
		  r_sh_type_inst (Y_SLL_OP, $2.i, $2.i, 8);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	LOADFP_INDEX_OPS F_DEST	ADDRESS
		{
		  mips32_r2_inst ();
		}


	|	STORE_OPS	SRC1	ADDRESS
		{
		  i_type_inst ($1.i == Y_SD_POP ? Y_SW_OP : $1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  if ($1.i == Y_SD_POP)
		    i_type_inst_free (Y_SW_OP, $2.i + 1,
				      addr_expr_reg ((addr_expr *)$3.p),
				      incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
							4));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	STOREC_OPS	COP_REG	ADDRESS
		{
		  i_type_inst ($1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	Y_USW_POP	SRC1	ADDRESS
		{
#ifdef BIGENDIAN
		  i_type_inst (Y_SWL_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  i_type_inst_free (Y_SWR_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      3));
#else
		  i_type_inst_free (Y_SWL_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      3));
		  i_type_inst (Y_SWR_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
#endif
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	Y_USH_POP	SRC1	ADDRESS
		{
		  i_type_inst (Y_SB_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));

		  /* ROL SRC, SRC, 8 */
		  r_sh_type_inst (Y_SLL_OP, 1, $2.i, 24);
		  r_sh_type_inst (Y_SRL_OP, $2.i, $2.i, 8);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);

		  i_type_inst_free (Y_SB_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      1));
		  /* ROR SRC, SRC, 8 */
		  r_sh_type_inst (Y_SRL_OP, 1, $2.i, 24);
		  r_sh_type_inst (Y_SLL_OP, $2.i, $2.i, 8);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);

		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	STOREFP_OPS	F_SRC1	ADDRESS
		{
		  i_type_inst ($1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	STOREFP_INDEX_OPS F_DEST	ADDRESS
		{
		  mips32_r2_inst ();
		}


	|	SYS_OPS
		{
		  r_type_inst ($1.i, 0, 0, 0);
		}


	|	PREFETCH_OPS	ADDRESS
		{
		  mips32_r2_inst ();
		}


	|	CACHE_OPS	Y_INT	ADDRESS
		{
		  i_type_inst_free ($1.i, $2.i, 0, (imm_expr *)$3.p);
		}


	|	TLB_OPS
		{
		  r_type_inst ($1.i, 0, 0, 0);
		}


	|	Y_SYNC_OP
		{
		  r_type_inst ($1.i, 0, 0, 0);
		}

	|	Y_SYNC_OP	Y_INT
		{
		  r_type_inst ($1.i, $2.i, 0, 0);
		}


	|	Y_BREAK_OP	Y_INT
		{
		  if ($2.i == 1)
		    yyerror ("Breakpoint 1 is reserved for debugger");
		  r_type_inst ($1.i, $2.i, 0, 0);
		}


	|	Y_NOP_POP
		{
		  nop_inst ();
		}


	|	Y_SSNOP_OP
		{
		  r_sh_type_inst (Y_SLL_OP, 0, 0, 1); /* SLL r0 r0 1 */
		}


	|	Y_ABS_POP	DEST	SRC1
		{
		  if ($2.i != $3.i)
		    r_type_inst (Y_ADDU_OP, $2.i, 0, $3.i);

		  i_type_inst_free (Y_BGEZ_OP, 0, $3.i, branch_offset (2));
		  r_type_inst (Y_SUB_OP, $2.i, 0, $3.i);
		}


	|	Y_NEG_POP	DEST	SRC1
		{
		  r_type_inst (Y_SUB_OP, $2.i, 0, $3.i);
		}


	|	Y_NEGU_POP	DEST	SRC1
		{
		  r_type_inst (Y_SUBU_OP, $2.i, 0, $3.i);
		}


	|	Y_NOT_POP	DEST	SRC1
		{
		  r_type_inst (Y_NOR_OP, $2.i, $3.i, 0);
		}


	|	Y_MOVE_POP	DEST	SRC1
		{
		  r_type_inst (Y_ADDU_OP, $2.i, 0, $3.i);
		}


	|	NULLARY_OPS
		{
		  r_type_inst ($1.i, 0, 0, 0);
		}


	|	NULLARY_OPS_REV2
		{
		  mips32_r2_inst ();
		}


	|	COUNT_LEADING_OPS DEST	SRC1
		{
		  /* RT must be equal to RD */
		  r_type_inst ($1.i, $2.i, $3.i, $2.i);
		}


	|	UNARY_OPS_REV2	DEST
		{
		  mips32_r2_inst ();
		}


	|	BINARYI_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	BINARYI_OPS	DEST	SRC1	IMM32
		{
		  i_type_inst_free (op_to_imm_op ($1.i), $2.i, $3.i,
				    (imm_expr *)$4.p);
		}

	|	BINARYI_OPS	DEST	IMM32
		{
		  i_type_inst_free (op_to_imm_op ($1.i), $2.i, $2.i,
				    (imm_expr *)$3.p);
		}


	|	BINARYIR_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $4.i, $3.i);
		}

	|	BINARYIR_OPS	DEST	SRC1	Y_INT
		{
		  r_sh_type_inst (op_to_imm_op ($1.i), $2.i, $3.i, $4.i);
		}

	|	BINARYIR_OPS	DEST	Y_INT
		{
		  r_sh_type_inst (op_to_imm_op ($1.i), $2.i, $2.i, $3.i);
		}


	|	BINARY_ARITHI_OPS DEST	SRC1	IMM16
		{
		  i_type_inst_free ($1.i, $2.i, $3.i, (imm_expr *)$4.p);
		}

	|	BINARY_ARITHI_OPS DEST	IMM16
		{
		  i_type_inst_free ($1.i, $2.i, $2.i, (imm_expr *)$3.p);
		}


	|	BINARY_LOGICALI_OPS DEST	SRC1	UIMM16
		{
		  i_type_inst_free ($1.i, $2.i, $3.i, (imm_expr *)$4.p);
		}

	|	BINARY_LOGICALI_OPS DEST	UIMM16
		{
		  i_type_inst_free ($1.i, $2.i, $2.i, (imm_expr *)$3.p);
		}


	|	SHIFT_OPS	DEST	SRC1	Y_INT
		{
		  if (($4.i < 0) || (31 < $4.i))
		    yywarn ("Shift distance can only be in the range 0..31");
		  r_sh_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SHIFT_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst (imm_op_to_op ($1.i), $2.i, $4.i, $3.i);
		}


	|	SHIFT_OPS_REV2	DEST	SRC1	Y_INT
		{
		  mips32_r2_inst ();
		}

	|	SHIFTV_OPS_REV2	DEST	SRC1	SRC2
		{
		  mips32_r2_inst ();
		}


	|	BINARY_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	BINARY_OPS	DEST	SRC1	IMM32
		{
		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    {
		      if (!zero_imm ((imm_expr *)$4.p))
			/* Use $at */
			i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		      r_type_inst ($1.i,
				   $2.i,
				   $3.i,
				   (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		    }
		  free ((imm_expr *)$4.p);
		}

	|	BINARY_OPS	DEST	IMM32
		{
		  check_uimm_range ((imm_expr *)$3.p, UIMM_MIN, UIMM_MAX);
		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    {
		      if (!zero_imm ((imm_expr *)$3.p))
			/* Use $at */
			i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$3.p);
		      r_type_inst ($1.i,
				   $2.i,
				   $2.i,
				   (zero_imm ((imm_expr *)$3.p) ? 0 : 1));
		    }
		  free ((imm_expr *)$3.p);
		}


	|	BINARY_OPS_REV2	DEST	SRC1
		{
		  mips32_r2_inst ();
		}


	|	SUB_OPS		DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SUB_OPS		DEST	SRC1	IMM32
		{
		  int val = eval_imm_expr ((imm_expr *)$4.p);

		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    i_type_inst ($1.i == Y_SUB_OP ? Y_ADDI_OP
				 : $1.i == Y_SUBU_OP ? Y_ADDIU_OP
				 : (fatal_error ("Bad SUB_OP\n"), 0),
				 $2.i,
				 $3.i,
				 make_imm_expr (-val, NULL, 0));
		  free ((imm_expr *)$4.p);
		}

	|	SUB_OPS		DEST	IMM32
		{
		  int val = eval_imm_expr ((imm_expr *)$3.p);

		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    i_type_inst ($1.i == Y_SUB_OP ? Y_ADDI_OP
				 : $1.i == Y_SUBU_OP ? Y_ADDIU_OP
				 : (fatal_error ("Bad SUB_OP\n"), 0),
				 $2.i,
				 $2.i,
				 make_imm_expr (-val, NULL, 0));
		  free ((imm_expr *)$3.p);
		}


	|	DIV_POPS	DEST	SRC1
		{
		  /* The hardware divide operation (ignore 1st arg) */
		  if ($1.i != Y_DIV_OP && $1.i != Y_DIVU_OP)
		    yyerror ("REM requires 3 arguments");
		  else
		    r_type_inst ($1.i, 0, $2.i, $3.i);
		}

	|	DIV_POPS	DEST	SRC1	SRC2
		{
		  /* Pseudo divide operations */
		  div_inst ($1.i, $2.i, $3.i, $4.i, 0);
		}

	|	DIV_POPS	DEST	SRC1	IMM32
		{
		  if (zero_imm ((imm_expr *)$4.p))
		    yyerror ("Divide by zero");
		  else
		    {
		      /* Use $at */
		      i_type_inst_free (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		      div_inst ($1.i, $2.i, $3.i, 1, 1);
		    }
		}


	|	MUL_POPS	DEST	SRC1	SRC2
		{
		  mult_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	MUL_POPS	DEST	SRC1	IMM32
		{
		  if (zero_imm ((imm_expr *)$4.p))
		    /* Optimize: n * 0 == 0 */
		    i_type_inst_free (Y_ORI_OP, $2.i, 0, (imm_expr *)$4.p);
		  else
		    {
		      /* Use $at */
		      i_type_inst_free (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		      mult_inst ($1.i, $2.i, $3.i, 1);
		    }
		}


	|	MULT_OPS	SRC1	SRC2
		{
		  r_type_inst ($1.i, 0, $2.i, $3.i);
		}


	|	MULT_OPS3	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	MULT_OPS3	DEST	SRC1	IMM32
		{
		  /* Special case, for backward compatibility with pseudo-op
		     MULT instruction */
		  i_type_inst_free (Y_ORI_OP, 1, 0, (imm_expr *)$4.p); /* Use $at */
		  r_type_inst ($1.i, $2.i, $3.i, 1);
		}


	|	Y_ROR_POP	DEST	SRC1	SRC2
		{
		  r_type_inst (Y_SUBU_OP, 1, 0, $4.i);
		  r_type_inst (Y_SLLV_OP, 1, 1, $3.i);
		  r_type_inst (Y_SRLV_OP, $2.i, $4.i, $3.i);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		}


	|	Y_ROL_POP	DEST	SRC1	SRC2
		{
		  r_type_inst (Y_SUBU_OP, 1, 0, $4.i);
		  r_type_inst (Y_SRLV_OP, 1, 1, $3.i);
		  r_type_inst (Y_SLLV_OP, $2.i, $4.i, $3.i);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		}


	|	Y_ROR_POP	DEST	SRC1	IMM32
		{
		  long dist = eval_imm_expr ((imm_expr *)$4.p);

		  check_imm_range ((imm_expr *)$4.p, 0, 31);
		  r_sh_type_inst (Y_SLL_OP, 1, $3.i, -dist);
		  r_sh_type_inst (Y_SRL_OP, $2.i, $3.i, dist);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		  free ((imm_expr *)$4.p);
		}


	|	Y_ROL_POP	DEST	SRC1	IMM32
		{
		  long dist = eval_imm_expr ((imm_expr *)$4.p);

		  check_imm_range ((imm_expr *)$4.p, 0, 31);
		  r_sh_type_inst (Y_SRL_OP, 1, $3.i, -dist);
		  r_sh_type_inst (Y_SLL_OP, $2.i, $3.i, dist);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		  free ((imm_expr *)$4.p);
		}


	|	BF_OPS_REV2	F_DEST	F_SRC2	Y_INT	Y_INT
		{
		  mips32_r2_inst ();
		}


	|	SET_LE_POPS	DEST	SRC1	SRC2
		{
		  set_le_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SET_LE_POPS	DEST	SRC1	IMM32
		{
		  if (!zero_imm ((imm_expr *)$4.p))
		    /* Use $at */
		    i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		  set_le_inst ($1.i, $2.i, $3.i,
			       (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		  free ((imm_expr *)$4.p);
		}


	|	SET_GT_POPS	DEST	SRC1	SRC2
		{
		  set_gt_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SET_GT_POPS	DEST	SRC1	IMM32
		{
		  if (!zero_imm ((imm_expr *)$4.p))
		    /* Use $at */
		    i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		  set_gt_inst ($1.i, $2.i, $3.i,
			       (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		  free ((imm_expr *)$4.p);
		}



	|	SET_GE_POPS	DEST	SRC1	SRC2
		{
		  set_ge_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SET_GE_POPS	DEST	SRC1	IMM32
		{
		  if (!zero_imm ((imm_expr *)$4.p))
		    /* Use $at */
		    i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		  set_ge_inst ($1.i, $2.i, $3.i,
			       (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		  free ((imm_expr *)$4.p);
		}


	|	SET_EQ_POPS	DEST	SRC1	SRC2
		{
		  set_eq_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SET_EQ_POPS	DEST	SRC1	IMM32
		{
		  if (!zero_imm ((imm_expr *)$4.p))
		    /* Use $at */
		    i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		  set_eq_inst ($1.i, $2.i, $3.i,
			       (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		  free ((imm_expr *)$4.p);
		}


	|	BR_COP_OPS	LABEL
		{
		  /* RS and RT fields contain information on test */
		  int nd = opcode_is_nullified_branch ($1.i);
		  int tf = opcode_is_true_branch ($1.i);
		  i_type_inst_free ($1.i,
				    cc_to_rt (0, nd, tf),
				    BIN_RS ($1.i),
				    (imm_expr *)$2.p);
		}

	|	BR_COP_OPS	CC_REG	LABEL
		{
		  /* RS and RT fields contain information on test */
		  int nd = opcode_is_nullified_branch ($1.i);
		  int tf = opcode_is_true_branch ($1.i);
		  i_type_inst_free ($1.i,
				    cc_to_rt ($2.i, nd, tf),
				    BIN_RS ($1.i),
				    (imm_expr *)$3.p);
		}


	|	UNARY_BR_OPS	SRC1	LABEL
		{
		  i_type_inst_free ($1.i, 0, $2.i, (imm_expr *)$3.p);
		}


	|	UNARY_BR_POPS	SRC1	LABEL
		{
		  i_type_inst_free ($1.i == Y_BEQZ_POP ? Y_BEQ_OP : Y_BNE_OP,
			       0, $2.i, (imm_expr *)$3.p);
		}


	|	BINARY_BR_OPS	SRC1	SRC2	LABEL
		{
		  i_type_inst_free ($1.i, $3.i, $2.i, (imm_expr *)$4.p);
		}

	|	BINARY_BR_OPS	SRC1	BR_IMM32	LABEL
		{
		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    {
		      if (zero_imm ((imm_expr *)$3.p))
			i_type_inst ($1.i, $2.i,
				     (zero_imm ((imm_expr *)$3.p) ? 0 : 1),
				     (imm_expr *)$4.p);
		      else
			{
			  /* Use $at */
			  i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$3.p);
			  i_type_inst ($1.i, $2.i,
				       (zero_imm ((imm_expr *)$3.p) ? 0 : 1),
				       (imm_expr *)$4.p);
			}
		    }
		  free ((imm_expr *)$3.p);
		  free ((imm_expr *)$4.p);
		}


	|	BR_GT_POPS	SRC1	SRC2	LABEL
		{
		  r_type_inst ($1.i == Y_BGT_POP ? Y_SLT_OP : Y_SLTU_OP,
			       1, $3.i, $2.i); /* Use $at */
		  i_type_inst_free (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		}

	|	BR_GT_POPS	SRC1	BR_IMM32	LABEL
		{
		  if ($1.i == Y_BGT_POP)
		    {
		      /* Use $at */
		      i_type_inst_free (Y_SLTI_OP, 1, $2.i,
					incr_expr_offset ((imm_expr *)$3.p, 1));
		      i_type_inst (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		    }
		  else
		    {
		      /* Use $at */
		      /* Can't add 1 to immediate since 0xffffffff+1 = 0 < 1 */
		      i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$3.p);
		      i_type_inst_free (Y_BEQ_OP, $2.i, 1, branch_offset (3));
		      r_type_inst (Y_SLTU_OP, 1, $2.i, 1);
		      i_type_inst (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		    }
		  free ((imm_expr *)$3.p);
		  free ((imm_expr *)$4.p);
		}


	|	BR_GE_POPS	SRC1	SRC2	LABEL
		{
		  r_type_inst ($1.i == Y_BGE_POP ? Y_SLT_OP : Y_SLTU_OP,
			       1, $2.i, $3.i); /* Use $at */
		  i_type_inst_free (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		}

	|	BR_GE_POPS	SRC1	BR_IMM32	LABEL
		{
		  i_type_inst ($1.i == Y_BGE_POP ? Y_SLTI_OP : Y_SLTIU_OP,
			       1, $2.i, (imm_expr *)$3.p); /* Use $at */
		  i_type_inst_free (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		  free ((imm_expr *)$3.p);
		}


	|	BR_LT_POPS	SRC1	SRC2	LABEL
		{
		  r_type_inst ($1.i == Y_BLT_POP ? Y_SLT_OP : Y_SLTU_OP,
			       1, $2.i, $3.i); /* Use $at */
		  i_type_inst_free (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		}

	|	BR_LT_POPS	SRC1	BR_IMM32	LABEL
		{
		  i_type_inst ($1.i == Y_BLT_POP ? Y_SLTI_OP : Y_SLTIU_OP,
			       1, $2.i, (imm_expr *)$3.p); /* Use $at */
		  i_type_inst_free (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		  free ((imm_expr *)$3.p);
		}


	|	BR_LE_POPS	SRC1	SRC2	LABEL
		{
		  r_type_inst ($1.i == Y_BLE_POP ? Y_SLT_OP : Y_SLTU_OP,
			       1, $3.i, $2.i); /* Use $at */
		  i_type_inst_free (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		}

	|	BR_LE_POPS	SRC1	BR_IMM32	LABEL
		{
		  if ($1.i == Y_BLE_POP)
		    {
		      /* Use $at */
		      i_type_inst_free (Y_SLTI_OP, 1, $2.i,
					incr_expr_offset ((imm_expr *)$3.p, 1));
		      i_type_inst (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		    }
		  else
		    {
		      /* Use $at */
		      /* Can't add 1 to immediate since 0xffffffff+1 = 0 < 1 */
		      i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$3.p);
		      i_type_inst (Y_BEQ_OP, $2.i, 1, (imm_expr *)$4.p);
		      r_type_inst (Y_SLTU_OP, 1, $2.i, 1);
		      i_type_inst (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		    }
		  free ((imm_expr *)$3.p);
		  free ((imm_expr *)$4.p);
		}


	|	J_OPS		LABEL
		{
		  if (($1.i == Y_J_OP) || ($1.i == Y_JR_OP))
		    j_type_inst (Y_J_OP, (imm_expr *)$2.p);
		  else if (($1.i == Y_JAL_OP) || ($1.i == Y_JALR_OP))
		    j_type_inst (Y_JAL_OP, (imm_expr *)$2.p);
		  free ((imm_expr *)$2.p);
		}

	|	J_OPS		SRC1
		{
		  if (($1.i == Y_J_OP) || ($1.i == Y_JR_OP))
		    r_type_inst (Y_JR_OP, 0, $2.i, 0);
		  else if (($1.i == Y_JAL_OP) || ($1.i == Y_JALR_OP))
		    r_type_inst (Y_JALR_OP, 31, $2.i, 0);
		}

	|	J_OPS		DEST	SRC1
		{
		  if (($1.i == Y_J_OP) || ($1.i == Y_JR_OP))
		    r_type_inst (Y_JR_OP, 0, $3.i, 0);
		  else if (($1.i == Y_JAL_OP) || ($1.i == Y_JALR_OP))
		    r_type_inst (Y_JALR_OP, $2.i, $3.i, 0);
		}


	|	B_OPS		LABEL
		{
		  i_type_inst_free (($1.i == Y_BAL_POP ? Y_BGEZAL_OP : Y_BGEZ_OP),
				    0, 0, (imm_expr *)$2.p);
		}


	|	UNARY_TRAP_OPS	SRC1	IMM16
		{
		  i_type_inst_free ($1.i, 0, $2.i, (imm_expr *)$3.p);
		}


	|	BINARY_TRAP_OPS	SRC1	SRC2
		{
		  r_type_inst ($1.i, 0, $2.i, $3.i);
		}


	|	FP_MOVE_OPS	F_DEST	F_SRC1
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, 0);
		}


	|	FP_MOVE_OPS_REV2 F_DEST	F_SRC1
		{
		  mips32_r2_inst ();
		}


	|	MOVEC_OPS	DEST	SRC1	CC_REG
		{
		  r_type_inst ($1.i, $2.i, $3.i, cc_to_rt ($4.i, 0, 0));
		}


	|	FP_MOVEC_OPS	F_DEST	F_SRC1	REG
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, $4.i);
		}


	|	FP_MOVECC_OPS	F_DEST	F_SRC1	CC_REG
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, cc_to_rt ($4.i, 0, 0));
		}


	|	FP_MOVECC_OPS_REV2 F_DEST	F_SRC1	CC_REG
		{
		  mips32_r2_inst ();
		}


	|	FP_MOVEC_OPS_REV2 F_DEST	F_SRC1	REG
		{
		  mips32_r2_inst ();
		}


	|	MOVE_FROM_HILO_OPS REG
		{
		  r_type_inst ($1.i, $2.i, 0, 0);
		}


	|	MOVE_TO_HILO_OPS REG
		{
		  r_type_inst ($1.i, 0, $2.i, 0);
		}


	|	MOVEC_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}


	|	MOVE_COP_OPS	REG	COP_REG
		{
		  if ($1.i == Y_MFC1_D_POP)
		    {
		      r_co_type_inst (Y_MFC1_OP, 0, $3.i, $2.i);
		      r_co_type_inst (Y_MFC1_OP, 0, $3.i + 1, $2.i + 1);
		    }
		  else if ($1.i == Y_MTC1_D_POP)
		    {
		      r_co_type_inst (Y_MTC1_OP, 0, $3.i, $2.i);
		      r_co_type_inst (Y_MTC1_OP, 0, $3.i + 1, $2.i + 1);
		    }
		  else
		    r_co_type_inst ($1.i, 0, $3.i, $2.i);
		}


	|	MOVE_COP_OPS_REV2 REG	COP_REG
		{
		  mips32_r2_inst ();
		}


	|	CTL_COP_OPS	REG	COP_REG
		{
		  r_co_type_inst ($1.i, 0, $3.i, $2.i);
		}


	|	FP_UNARY_OPS	F_DEST	F_SRC2
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, 0);
		}


	|	FP_UNARY_OPS_REV2 F_DEST	F_SRC2
		{
		  mips32_r2_inst ();
		}


	|	FP_BINARY_OPS	F_DEST	F_SRC1	F_SRC2
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, $4.i);
		}


	|	FP_BINARY_OPS_REV2 F_DEST	F_SRC1	F_SRC2
		{
		  mips32_r2_inst ();
		}


	|	FP_TERNARY_OPS_REV2 F_DEST	F_SRC1	F_SRC2	FP_REGISTER
		{
		  mips32_r2_inst ();
		}


	|	FP_CMP_OPS	F_SRC1	F_SRC2
		{
		  r_cond_type_inst ($1.i, $2.i, $3.i, 0);
		}


	|	FP_CMP_OPS	CC_REG	F_SRC1	F_SRC2
		{
		  r_cond_type_inst ($1.i, $3.i, $4.i, $2.i);
		}


	|	FP_CMP_OPS_REV2	F_SRC1	F_SRC2
		{
		  mips32_r2_inst ();
		}


	|	Y_COP2_OP	IMM32
		{
		  i_type_inst_free ($1.i, 0, 0, (imm_expr *)$2.p);
		}
	;



LOAD_OPS:	Y_LB_OP
	|	Y_LBU_OP
	|	Y_LH_OP
	|	Y_LHU_OP
	|	Y_LL_OP
	|	Y_LW_OP
	|	Y_LWL_OP
	|	Y_LWR_OP
	|	Y_PFW_OP
	|	Y_LD_POP
	;

LOADI_OPS:	Y_LUI_OP
	;

ULOADH_POPS:	Y_ULH_POP
	|	Y_ULHU_POP
	;

LOADC_OPS:	Y_LDC2_OP
	|	Y_LWC2_OP
	;

LOADFP_OPS:	Y_LDC1_OP
	|	Y_LWC1_OP
	|	Y_L_D_POP { $$.i = Y_LDC1_OP; }
	|	Y_L_S_POP { $$.i = Y_LWC1_OP; }
	;

LOADFP_INDEX_OPS:	Y_LDXC1_OP
	|	Y_LUXC1_OP
	|	Y_LWXC1_OP
	;

STORE_OPS:	Y_SB_OP
	|	Y_SC_OP
	|	Y_SH_OP
	|	Y_SW_OP
	|	Y_SWL_OP
	|	Y_SWR_OP
	|	Y_SD_POP
	;

STOREC_OPS:	Y_SWC2_OP
	|	Y_SDC2_OP
	|	Y_S_D_POP { $$.i = Y_SDC1_OP; }
	|	Y_S_S_POP { $$.i = Y_SWC1_OP; }
	;

STOREFP_OPS:	Y_SWC1_OP
	|	Y_SDC1_OP
	;

STOREFP_INDEX_OPS:	Y_SDXC1_OP
	|	Y_SUXC1_OP
	|	Y_SWXC1_OP
	;

SYS_OPS:	Y_RFE_OP
		{
#ifdef MIPS1
			yywarn ("RFE should only be used when SPIM is compiled as a MIPS-I processor");
#endif
		}
	|	Y_SYSCALL_OP
	;

PREFETCH_OPS:	Y_PREFX_OP
	|	Y_SYNCI_OP
	;

CACHE_OPS:	Y_CACHE_OP
	|	Y_PREF_OP
	;

TLB_OPS:	Y_TLBP_OP
	|	Y_TLBR_OP
	|	Y_TLBWI_OP
	|	Y_TLBWR_OP
	;

NULLARY_OPS:	Y_ERET_OP
		{
#ifdef MIPS1
			yywarn ("ERET should only be used when SPIM is compiled as a MIPS32 processor");
#endif
		}
	;

NULLARY_OPS_REV2:	Y_DERET_OP
	|	Y_EHB_OP
	|	Y_SDBBP_OP
	;

COUNT_LEADING_OPS:	Y_CLO_OP
	|	Y_CLZ_OP
	;

UNARY_OPS_REV2:	Y_DI_OP
	|	Y_EI_OP
	;

/* These binary operations have immediate analogues. */

BINARYI_OPS:	Y_ADD_OP
	|	Y_ADDU_OP
	|	Y_AND_OP
	|	Y_XOR_OP
	|	Y_OR_OP
	|	Y_SLT_OP
	|	Y_SLTU_OP
	;

BINARYIR_OPS:	Y_SLLV_OP
	|	Y_SRAV_OP
	|	Y_SRLV_OP
	;

BINARY_ARITHI_OPS:	Y_ADDI_OP
	|	Y_ADDIU_OP
	|	Y_SLTI_OP
	|	Y_SLTIU_OP
	;

BINARY_LOGICALI_OPS:	Y_ANDI_OP
	|	Y_ORI_OP
	|	Y_XORI_OP
	;

SHIFT_OPS:	Y_SLL_OP
	|	Y_SRA_OP
	|	Y_SRL_OP
	;

SHIFT_OPS_REV2:	Y_ROTR_OP
	;

SHIFTV_OPS_REV2:	Y_ROTRV_OP
	;


/* These binary operations do not have immediate analogues. */

BINARY_OPS:	Y_NOR_OP
	;

BINARY_OPS_REV2:	Y_RDHWR_OP
	|	Y_RDPGPR_OP
	|	Y_SEB_OP
	|	Y_SEH_OP
	|	Y_WRPGPR_OP
	|	Y_WSBH_OP
	;

SUB_OPS:	Y_SUB_OP
	|	Y_SUBU_OP
	;

DIV_POPS:	Y_DIV_OP
	|	Y_DIVU_OP
	|	Y_REM_POP
	|	Y_REMU_POP
	;

MUL_POPS:	Y_MULO_POP
	|	Y_MULOU_POP
	;

SET_LE_POPS:	Y_SLE_POP
	|	Y_SLEU_POP
	;

SET_GT_POPS:	Y_SGT_POP
	|	Y_SGTU_POP
	;

SET_GE_POPS:	Y_SGE_POP
	|	Y_SGEU_POP
	;

SET_EQ_POPS:	Y_SEQ_POP
	|	Y_SNE_POP
	;

MULT_OPS:	Y_MULT_OP
	|	Y_MULTU_OP
	|	Y_MADD_OP
	|	Y_MADDU_OP
	|	Y_MSUB_OP
	|	Y_MSUBU_OP
	;

MULT_OPS3: Y_MUL_OP
	;

BF_OPS_REV2:	Y_EXT_OP
	|	Y_INS_OP
	;

BR_COP_OPS:	Y_BC1F_OP
	|	Y_BC1FL_OP
	|	Y_BC1T_OP
	|	Y_BC1TL_OP
	|	Y_BC2F_OP
	|	Y_BC2FL_OP
	|	Y_BC2T_OP
	|	Y_BC2TL_OP
	;

UNARY_BR_OPS:	Y_BGEZ_OP
	|	Y_BGEZL_OP
	|	Y_BGEZAL_OP
	|	Y_BGEZALL_OP
	|	Y_BGTZ_OP
	|	Y_BGTZL_OP
	|	Y_BLEZ_OP
	|	Y_BLEZL_OP
	|	Y_BLTZ_OP
	|	Y_BLTZL_OP
	|	Y_BLTZAL_OP
	|	Y_BLTZALL_OP
	;

UNARY_BR_POPS:	Y_BEQZ_POP
	|	Y_BNEZ_POP
	;

BINARY_BR_OPS:	Y_BEQ_OP
	|	Y_BEQL_OP
	|	Y_BNE_OP
	|	Y_BNEL_OP
	;

BR_GT_POPS:	Y_BGT_POP
	|	Y_BGTU_POP

BR_GE_POPS:	Y_BGE_POP
	|	Y_BGEU_POP

BR_LT_POPS:	Y_BLT_POP
	|	Y_BLTU_POP

BR_LE_POPS:	Y_BLE_POP
	|	Y_BLEU_POP
	;

J_OPS:	Y_J_OP
	|	Y_JR_OP
	|	Y_JR_HB_OP { yywarn ("Warning:IPS32 Rev 2 '.HB' extension is not implemented and is ignored"); }
	|	Y_JAL_OP
	|	Y_JALR_OP
	|	Y_JALR_HB_OP { yywarn ("Warning:IPS32 Rev 2 '.HB' extension is not implemented and is ignored"); }
	;

B_OPS:	Y_B_POP
	|	Y_BAL_POP
	;


UNARY_TRAP_OPS:	Y_TEQI_OP
	|	Y_TGEI_OP
	|	Y_TGEIU_OP
	|	Y_TLTI_OP
	|	Y_TLTIU_OP
	|	Y_TNEI_OP
	;

BINARY_TRAP_OPS:	Y_TEQ_OP
	|	Y_TGE_OP
	|	Y_TGEU_OP
	|	Y_TLT_OP
	|	Y_TLTU_OP
	|	Y_TNE_OP
	;


MOVE_FROM_HILO_OPS:	Y_MFHI_OP
	|	Y_MFLO_OP
	;

MOVE_TO_HILO_OPS:	Y_MTHI_OP
	|	Y_MTLO_OP
	;

MOVEC_OPS:	Y_MOVN_OP
	|	Y_MOVZ_OP
	;

MOVE_COP_OPS:	Y_MFC0_OP
	|	Y_MFC1_OP
	|	Y_MFC1_D_POP
	|	Y_MFC2_OP
	|	Y_MTC0_OP
	|	Y_MTC1_OP
	|	Y_MTC1_D_POP
	|	Y_MTC2_OP
	;

MOVE_COP_OPS_REV2:	Y_MFHC1_OP
	|	Y_MFHC2_OP
	|	Y_MTHC1_OP
	|	Y_MTHC2_OP
	;

CTL_COP_OPS:	Y_CFC0_OP
	|	Y_CFC1_OP
	|	Y_CFC2_OP
	|	Y_CTC0_OP
	|	Y_CTC1_OP
	|	Y_CTC2_OP
	;

/* Floating point operations */

FP_MOVE_OPS:	Y_MOV_S_OP
	|	Y_MOV_D_OP
	;

FP_MOVE_OPS_REV2:	Y_MOV_PS_OP
	;


MOVEC_OPS:	Y_MOVF_OP
	|	Y_MOVT_OP
	;


FP_MOVEC_OPS:	Y_MOVN_D_OP
	|	Y_MOVN_S_OP
	|	Y_MOVZ_D_OP
	|	Y_MOVZ_S_OP
	;

FP_MOVEC_OPS_REV2:	Y_MOVN_PS_OP
	|	Y_MOVZ_PS_OP
	;


FP_MOVECC_OPS:	Y_MOVF_D_OP
	|	Y_MOVF_S_OP
	|	Y_MOVT_D_OP
	|	Y_MOVT_S_OP
	;

FP_MOVECC_OPS_REV2:	Y_MOVF_PS_OP
	|	Y_MOVT_PS_OP
	;

FP_UNARY_OPS:		Y_ABS_S_OP
	|	Y_ABS_D_OP
	|	Y_CEIL_W_D_OP
	|	Y_CEIL_W_S_OP
	|	Y_CVT_D_S_OP
	|	Y_CVT_D_W_OP
	|	Y_CVT_S_D_OP
	|	Y_CVT_S_W_OP
	|	Y_CVT_W_D_OP
	|	Y_CVT_W_S_OP
	|	Y_FLOOR_W_D_OP
	|	Y_FLOOR_W_S_OP
	|	Y_NEG_S_OP
	|	Y_NEG_D_OP
	|	Y_ROUND_W_D_OP
	|	Y_ROUND_W_S_OP
	|	Y_SQRT_D_OP
	|	Y_SQRT_S_OP
	|	Y_TRUNC_W_D_OP
	|	Y_TRUNC_W_S_OP
	;

FP_UNARY_OPS_REV2:	Y_ABS_PS_OP
	|	Y_CEIL_L_D_OP
	|	Y_CEIL_L_S_OP
	|	Y_CVT_D_L_OP
	|	Y_CVT_L_D_OP
	|	Y_CVT_L_S_OP
	|	Y_CVT_PS_S_OP
	|	Y_CVT_S_L_OP
	|	Y_CVT_S_PL_OP
	|	Y_CVT_S_PU_OP
	|	Y_FLOOR_L_D_OP
	|	Y_FLOOR_L_S_OP
	|	Y_NEG_PS_OP
	|	Y_RECIP_D_OP
	|	Y_RECIP_S_OP
	|	Y_ROUND_L_D_OP
	|	Y_ROUND_L_S_OP
	|	Y_RSQRT_D_OP
	|	Y_RSQRT_S_OP
	|	Y_TRUNC_L_D_OP
	|	Y_TRUNC_L_S_OP
	;

FP_BINARY_OPS:	Y_ADD_S_OP
	|	Y_ADD_D_OP
	|	Y_DIV_S_OP
	|	Y_DIV_D_OP
	|	Y_MUL_S_OP
	|	Y_MUL_D_OP
	|	Y_SUB_S_OP
	|	Y_SUB_D_OP
	;

FP_BINARY_OPS_REV2:	Y_ADD_PS_OP
	|	Y_MUL_PS_OP
	|	Y_PLL_PS_OP
	|	Y_PLU_PS_OP
	|	Y_PUL_PS_OP
	|	Y_PUU_PS_OP
	;

FP_TERNARY_OPS_REV2:	Y_ALNV_PS_OP
	|	Y_MADD_D_OP
	|	Y_MADD_PS_OP
	|	Y_MADD_S_OP
	|	Y_MSUB_D_OP
	|	Y_MSUB_PS_OP
	|	Y_MSUB_S_OP
	|	Y_NMADD_D_OP
	|	Y_NMADD_PS_OP
	|	Y_NMADD_S_OP
	|	Y_NMSUB_D_OP
	|	Y_NMSUB_PS_OP
	|	Y_NMSUB_S_OP
	;

FP_CMP_OPS:	Y_C_F_S_OP
	|	Y_C_UN_S_OP
	|	Y_C_EQ_S_OP
	|	Y_C_UEQ_S_OP
	|	Y_C_OLT_S_OP
	|	Y_C_OLE_S_OP
	|	Y_C_ULT_S_OP
	|	Y_C_ULE_S_OP
	|	Y_C_SF_S_OP
	|	Y_C_NGLE_S_OP
	|	Y_C_SEQ_S_OP
	|	Y_C_NGL_S_OP
	|	Y_C_LT_S_OP
	|	Y_C_NGE_S_OP
	|	Y_C_LE_S_OP
	|	Y_C_NGT_S_OP
	|	Y_C_F_D_OP
	|	Y_C_UN_D_OP
	|	Y_C_EQ_D_OP
	|	Y_C_UEQ_D_OP
	|	Y_C_OLT_D_OP
	|	Y_C_OLE_D_OP
	|	Y_C_ULT_D_OP
	|	Y_C_ULE_D_OP
	|	Y_C_SF_D_OP
	|	Y_C_NGLE_D_OP
	|	Y_C_SEQ_D_OP
	|	Y_C_NGL_D_OP
	|	Y_C_LT_D_OP
	|	Y_C_NGE_D_OP
	|	Y_C_LE_D_OP
	|	Y_C_NGT_D_OP
	;

FP_CMP_OPS_REV2:	Y_C_EQ_PS_OP
	|	Y_C_F_PS_OP
	|	Y_C_LT_PS_OP
	|	Y_C_LE_PS_OP
	|	Y_C_NGE_PS_OP
	|	Y_C_NGL_PS_OP
	|	Y_C_NGLE_PS_OP
	|	Y_C_NGT_PS_OP
	|	Y_C_OLE_PS_OP
	|	Y_C_OLT_PS_OP
	|	Y_C_SEQ_PS_OP
	|	Y_C_SF_PS_OP
	|	Y_C_UEQ_PS_OP
	|	Y_C_ULE_PS_OP
	|	Y_C_ULT_PS_OP
	|	Y_C_UN_PS_OP
	;



ASM_DIRECTIVE:	Y_ALIAS_DIR	Y_REG	Y_REG

	|	Y_ALIGN_DIR	EXPR
		{
		  align_data ($2.i);
		}

	|	Y_ASCII_DIR {null_term = 0;}	STR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}

	|	Y_ASCIIZ_DIR {null_term = 1;}	STR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_ASM0_DIR

	|	Y_BGNB_DIR	Y_INT


	|	Y_BYTE_DIR
		{store_op = store_byte;}
		EXPR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_COMM_DIR	ID	EXPR
		{
		  align_data (2);
		  if (lookup_label ((char*)$2.p)->addr == 0)
		  {
		    (void)record_label ((char*)$2.p, current_data_pc (), 1);
		    free ((char*)$2.p);
		  }
		  increment_data_pc ($3.i);
		}


	|	Y_DATA_DIR
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		}

	|	Y_DATA_DIR	Y_INT
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		  set_data_pc ($2.i);
		}


	|	Y_K_DATA_DIR
		{
		  user_kernel_data_segment (1);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		}

	|	Y_K_DATA_DIR	Y_INT
		{
		  user_kernel_data_segment (1);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		  set_data_pc ($2.i);
		}


	|	Y_DOUBLE_DIR
		{
		  store_op = store_double;
		  if (data_dir) set_data_alignment (3);
		}
		FP_EXPR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_END_DIR	OPTIONAL_ID

	|	Y_ENDB_DIR	Y_INT

	|	Y_ENDR_DIR

	|	Y_ENT_DIR	ID

	|	Y_ENT_DIR	ID	Y_INT


	|	Y_EXTERN_DIR	ID	EXPR
		{
		  extern_directive ((char*)$2.p, $3.i);
		}


	|	Y_ERR_DIR
		{
		  fatal_error ("File contains an .err directive\n");
		}


	|	Y_FILE_DIR	Y_INT	Y_STR


	|	Y_FLOAT_DIR
		{
		  store_op = store_float;
		  if (data_dir) set_data_alignment (2);
		}
		FP_EXPR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_FMASK_DIR	Y_INT	Y_INT

	|	Y_FRAME_DIR	REGISTER	Y_INT	REGISTER


	|	Y_GLOBAL_DIR	ID
		{
		  (void)make_label_global ((char*)$2.p);
		  free ((char*)$2.p);
		}


	|	Y_HALF_DIR
		{
		  store_op = store_half;
		  if (data_dir) set_data_alignment (1);
		}
		EXPR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_LABEL_DIR	ID
		{
		  (void)record_label ((char*)$2.p,
				      text_dir
				      ? current_text_pc ()
				      : current_data_pc (),
				      1);
		  free ((char*)$2.p);
		}


	|	Y_LCOMM_DIR	ID	EXPR
		{
		  lcomm_directive ((char*)$2.p, $3.i);
		}


		/* Produced by cc 2.10 */
	|	Y_LIVEREG_DIR	Y_INT	Y_INT


	|	Y_LOC_DIR	Y_INT	Y_INT

	|	Y_MASK_DIR	Y_INT	Y_INT

	|	Y_NOALIAS_DIR	Y_REG	Y_REG

	|	Y_OPTIONS_DIR	ID

	|	Y_REPEAT_DIR	EXPR
		{
		  yyerror ("Warning: repeat directive ignored");
		}


	|	Y_RDATA_DIR
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		}

	|	Y_RDATA_DIR	Y_INT
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		  set_data_pc ($2.i);
		}


	|	Y_SDATA_DIR
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		}

	|	Y_SDATA_DIR	Y_INT
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		  set_data_pc ($2.i);
		}


	|	Y_SET_DIR	ID
		{
		  if (streq ((char*)$2.p, "noat"))
		    noat_flag = 1;
		  else if (streq ((char*)$2.p, "at"))
		    noat_flag = 0;
		}


	|	Y_SPACE_DIR	EXPR
		{
		  if (data_dir)
		    increment_data_pc ($2.i);
		  else if (text_dir)
		    increment_text_pc ($2.i);
		}


	|	Y_STRUCT_DIR	EXPR
		{
		  yyerror ("Warning: struct directive ignored");
		}


	|	Y_TEXT_DIR
		{
		  user_kernel_text_segment (0);
		  data_dir = 0; text_dir = 1;
		  enable_data_alignment ();
		}

	|	Y_TEXT_DIR	Y_INT
		{
		  user_kernel_text_segment (0);
		  data_dir = 0; text_dir = 1;
		  enable_data_alignment ();
		  set_text_pc ($2.i);
		}


	|	Y_K_TEXT_DIR
		{
		  user_kernel_text_segment (1);
		  data_dir = 0; text_dir = 1;
		  enable_data_alignment ();
		}

	|	Y_K_TEXT_DIR	Y_INT
		{
		  user_kernel_text_segment (1);
		  data_dir = 0; text_dir = 1;
		  enable_data_alignment ();
		  set_text_pc ($2.i);
		}


	|	Y_VERSTAMP_DIR	Y_INT	Y_INT

	|	Y_VREG_DIR	REGISTER	Y_INT	Y_INT


	|	Y_WORD_DIR
		{
		  store_op = store_word_data;
		  if (data_dir) set_data_alignment (2);
		}
		EXPR_LST

	;



ADDRESS:	{only_id = 1;} ADDR {only_id = 0; $$ = $2;}

ADDR:		'(' REGISTER ')'
		{
		  $$.p = make_addr_expr (0, NULL, $2.i);
		}

	|	ABS_ADDR
		{
		  $$.p = make_addr_expr ($1.i, NULL, 0);
		}

	|	ABS_ADDR '(' REGISTER ')'
		{
		  $$.p = make_addr_expr ($1.i, NULL, $3.i);
		}

	|	Y_ID
		{
		  $$.p = make_addr_expr (0, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}

	|	Y_ID '(' REGISTER ')'
		{
		  $$.p = make_addr_expr (0, (char*)$1.p, $3.i);
		  free ((char*)$1.p);
		}

	|	Y_ID '+' ABS_ADDR
		{
		  $$.p = make_addr_expr ($3.i, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}

	|	ABS_ADDR '+' ID
		{
		  $$.p = make_addr_expr ($1.i, (char*)$3.p, 0);
		}

	|	Y_ID '-' ABS_ADDR
		{
		  $$.p = make_addr_expr (- $3.i, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}

	|	Y_ID '+' ABS_ADDR '(' REGISTER ')'
		{
		  $$.p = make_addr_expr ($3.i, (char*)$1.p, $5.i);
		  free ((char*)$1.p);
		}

	|	Y_ID '-' ABS_ADDR '(' REGISTER ')'
		{
		  $$.p = make_addr_expr (- $3.i, (char*)$1.p, $5.i);
		  free ((char*)$1.p);
		}
	;


BR_IMM32:	{only_id = 1;} IMM32 {only_id = 0; $$ = $2;}

IMM16:	IMM32
		{
		  check_imm_range ($1.p, IMM_MIN, IMM_MAX);
		  $$ = $1;
		}

UIMM16:	IMM32
		{
		  check_uimm_range ($1.p, UIMM_MIN, UIMM_MAX);
		  $$ = $1;
		}


IMM32:		ABS_ADDR
		{
		  $$.p = make_imm_expr ($1.i, NULL, 0);
		}

	|	'(' ABS_ADDR ')' '>' '>' Y_INT
		{
		  $$.p = make_imm_expr ($2.i >> $6.i, NULL, 0);
		}

	|	ID
		{
		  $$.p = make_imm_expr (0, (char*)$1.p, 0);
		}

	|	Y_ID '+' ABS_ADDR
		{
		  $$.p = make_imm_expr ($3.i, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}

	|	Y_ID '-' ABS_ADDR
		{
		  $$.p = make_imm_expr (- $3.i, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}
	;


ABS_ADDR:	Y_INT

	|	Y_INT '+' Y_INT
		{$$.i = $1.i + $3.i;}

	|	Y_INT Y_INT
		{
		  /* This is actually: Y_INT '-' Y_INT, since the binary
		     subtract operator gets scanned as a unary negation
		     operator. */
		  if ($2.i >= 0) yyerror ("Syntax error");
		  $$.i = $1.i - -$2.i;
		}
	;

SRC1:		REGISTER ;

SRC2:		REGISTER ;

DEST:		REGISTER ;

REG:		REGISTER ;

REGISTER:	Y_REG
		{
		  if ($1.i < 0 || $1.i > 31)
		    yyerror ("Register number out of range");
		  if ($1.i == 1 && !bare_machine && !noat_flag)
		    yyerror ("Register 1 is reserved for assembler");
		  $$ = $1;
		}

F_DEST:		FP_REGISTER ;

F_SRC1:		FP_REGISTER ;

F_SRC2:		FP_REGISTER ;

FP_REGISTER:	Y_FP_REG
		{
		  if ($1.i < 0 || $1.i > 31)
		    yyerror ("FP register number out of range");
		  $$ = $1;
		}


CC_REG:	       Y_INT
		{
		  if ($1.i < 0 || $1.i > 7)
		    yyerror ("CC register number out of range");
		  $$ = $1;
		}


COP_REG:	Y_REG

	|	Y_FP_REG

	;


LABEL:		ID
		{
		  $$.p = make_imm_expr (-(int)current_text_pc (), (char*)$1.p, 1);
		}


STR_LST:	STR_LST STR
	|	STR
	;


STR:		Y_STR
		{
		  store_string ((char*)$1.p, strlen((char*)$1.p), null_term);
		  free ((char*)$1.p);
		}
	|	Y_STR ':' Y_INT
		{
		  int i;

		  for (i = 0; i < $3.i; i ++)
		    store_string ((char*)$1.p, strlen((char*)$1.p), null_term);
		  free ((char*)$1.p);
		}
	;


EXPRESSION:	{only_id = 1;} EXPR {only_id = 0; $$ = $2;}

EXPR:		Y_INT

	|	ID
		{
		  label *l = lookup_label ((char*)$1.p);

		  if (l->addr == 0)
		    {
		      record_data_uses_symbol (current_data_pc (), l);
		      $$.p = NULL;
		    }
		  else
		    $$.i = l->addr;
		}


EXPR_LST:	EXPR_LST	EXPRESSION
		{
		  store_op ($2.p);
		}
	|	EXPRESSION
		{
		  store_op ($1.p);
		}
	|	EXPRESSION ':' Y_INT
		{
		  int i;

		  for (i = 0; i < $3.i; i ++)
		    store_op ($1.p);
		}
	;


FP_EXPR_LST:	FP_EXPR_LST Y_FP
		{
		  store_op ($2.p);
		}
	|	Y_FP
		{
		  store_op ($1.p);
		}
	;


OPTIONAL_ID:	{only_id = 1;} OPT_ID {only_id = 0; $$ = $2;}

OPT_ID:		ID
	|	{$$.p = (void*)NULL;}
	;


ID:		{only_id = 1;} Y_ID {only_id = 0; $$ = $2;}


%%

/* Maintain and update the address of labels for the current line. */

void
fix_current_label_address (mem_addr new_addr)
{
  label_list *l;

  for (l = this_line_labels; l != NULL; l = l->tail)
    {
      l->head->addr = new_addr;
    }
  clear_labels ();
}


static label_list *
cons_label (label *head, label_list *tail)
{
  label_list *c = (label_list *) malloc (sizeof (label_list));

  c->head = head;
  c->tail = tail;
  return (c);
}


static void
clear_labels ()
{
  label_list *n;

  for ( ; this_line_labels != NULL; this_line_labels = n)
    {
      resolve_label_uses (this_line_labels->head);
      n = this_line_labels->tail;
      free (this_line_labels);
    }
    this_line_labels = NULL;
}


/* Operations on op codes. */

int
op_to_imm_op (int opcode)
{
  switch (opcode)
    {
    case Y_ADD_OP: return (Y_ADDI_OP);
    case Y_ADDU_OP: return (Y_ADDIU_OP);
    case Y_AND_OP: return (Y_ANDI_OP);
    case Y_OR_OP: return (Y_ORI_OP);
    case Y_XOR_OP: return (Y_XORI_OP);
    case Y_SLT_OP: return (Y_SLTI_OP);
    case Y_SLTU_OP: return (Y_SLTIU_OP);
    case Y_SLLV_OP: return (Y_SLL_OP);
    case Y_SRAV_OP: return (Y_SRA_OP);
    case Y_SRLV_OP: return (Y_SRL_OP);
    default: fatal_error ("Can't convert op to immediate op\n"); return (0);
    }
}


int
imm_op_to_op (int opcode)
{
  switch (opcode)
    {
    case Y_ADDI_OP: return (Y_ADD_OP);
    case Y_ADDIU_OP: return (Y_ADDU_OP);
    case Y_ANDI_OP: return (Y_AND_OP);
    case Y_ORI_OP: return (Y_OR_OP);
    case Y_XORI_OP: return (Y_XOR_OP);
    case Y_SLTI_OP: return (Y_SLT_OP);
    case Y_SLTIU_OP: return (Y_SLTU_OP);
    case Y_J_OP: return (Y_JR_OP);
    case Y_LUI_OP: return (Y_ADDU_OP);
    case Y_SLL_OP: return (Y_SLLV_OP);
    case Y_SRA_OP: return (Y_SRAV_OP);
    case Y_SRL_OP: return (Y_SRLV_OP);
    default: fatal_error ("Can't convert immediate op to op\n"); return (0);
    }
}


static void
nop_inst ()
{
  r_type_inst (Y_SLL_OP, 0, 0, 0); /* = 0 */
}


static void
trap_inst ()
{
  r_type_inst (Y_BREAK_OP, 0, 0, 0);
}


static imm_expr *
branch_offset (int n_inst)
{
  return (const_imm_expr (n_inst << 2)); /* Later shifted right 2 places */
}


static void
div_inst (int op, int rd, int rs, int rt, int const_divisor)
{
  if (rd != 0 && !const_divisor)
    {
      i_type_inst_free (Y_BNE_OP, 0, rt, branch_offset (2));
      trap_inst ();
    }

  if (op == Y_DIV_OP || op == Y_REM_POP)
    r_type_inst (Y_DIV_OP, 0, rs, rt);
  else
    r_type_inst (Y_DIVU_OP, 0, rs, rt);

  if (rd != 0)
    {
      if (op == Y_DIV_OP || op == Y_DIVU_OP)
	/* Quotient */
	r_type_inst (Y_MFLO_OP, rd, 0, 0);
      else
	/* Remainder */
	r_type_inst (Y_MFHI_OP, rd, 0, 0);
    }
}


static void
mult_inst (int op, int rd, int rs, int rt)
{
  if (op == Y_MULOU_POP)
    r_type_inst (Y_MULTU_OP, 0, rs, rt);
  else
    r_type_inst (Y_MULT_OP, 0, rs, rt);
  if (op == Y_MULOU_POP && rd != 0)
    {
      r_type_inst (Y_MFHI_OP, 1, 0, 0);	/* Use $at */
      i_type_inst_free (Y_BEQ_OP, 0, 1, branch_offset (2));
      trap_inst ();
    }
  else if (op == Y_MULO_POP && rd != 0)
    {
      r_type_inst (Y_MFHI_OP, 1, 0, 0); /* use $at */
      r_type_inst (Y_MFLO_OP, rd, 0, 0);
      r_sh_type_inst (Y_SRA_OP, rd, rd, 31);
      i_type_inst_free (Y_BEQ_OP, rd, 1, branch_offset (2));
      trap_inst ();
    }
  if (rd != 0)
    r_type_inst (Y_MFLO_OP, rd, 0, 0);
}


static void
set_le_inst (int op, int rd, int rs, int rt)
{
  i_type_inst_free (Y_BNE_OP, rs, rt, branch_offset (3));
  i_type_inst_free (Y_ORI_OP, rd, 0, const_imm_expr (1));
  i_type_inst_free (Y_BEQ_OP, 0, 0, branch_offset (2));
  r_type_inst ((op == Y_SLE_POP ? Y_SLT_OP : Y_SLTU_OP), rd, rs, rt);
}


static void
set_gt_inst (int op, int rd, int rs, int rt)
{
  r_type_inst (op == Y_SGT_POP ? Y_SLT_OP : Y_SLTU_OP, rd, rt, rs);
}


static void
set_ge_inst (int op, int rd, int rs, int rt)
{
  i_type_inst_free (Y_BNE_OP, rs, rt, branch_offset (3));
  i_type_inst_free (Y_ORI_OP, rd, 0, const_imm_expr (1));
  i_type_inst_free (Y_BEQ_OP, 0, 0, branch_offset (2));
  r_type_inst (op == Y_SGE_POP ? Y_SLT_OP : Y_SLTU_OP, rd, rt, rs);
}


static void
set_eq_inst (int op, int rd, int rs, int rt)
{
  imm_expr *if_eq, *if_neq;

  if (op == Y_SEQ_POP)
    if_eq = const_imm_expr (1), if_neq = const_imm_expr (0);
  else
    if_eq = const_imm_expr (0), if_neq = const_imm_expr (1);

  i_type_inst_free (Y_BEQ_OP, rs, rt, branch_offset (3));
  /* RD <- 0 (if not equal) */
  i_type_inst_free (Y_ORI_OP, rd, 0, if_neq);
  i_type_inst_free (Y_BEQ_OP, 0, 0, branch_offset (2)); /* Branch always */
  /* RD <- 1 */
  i_type_inst_free (Y_ORI_OP, rd, 0, if_eq);
}


/* Store the value either as a datum or instruction. */

static void
store_word_data (int value)
{
  if (data_dir)
    store_word (value);
  else if (text_dir)
    store_instruction (inst_decode (value));
}



void
initialize_parser (char *file_name)
{
  input_file_name = file_name;
  only_id = 0;
  data_dir = 0;
  text_dir = 1;
}


static void
check_imm_range (imm_expr* expr, int32 min, int32 max)
{
  if (expr->symbol == NULL || SYMBOL_IS_DEFINED (expr->symbol))
    {
      /* If expression can be evaluated, compare its value against the limits
	 and complain if the value is out of bounds. */
      int32 value = eval_imm_expr (expr);

      if (value < min || max < value)
	{
	  char str[200];
	  sprintf (str, "immediate value (%d) out of range (%d .. %d)",
		   value, min, max);
	  yywarn (str);
	}
    }
}


static void
check_uimm_range (imm_expr* expr, uint32 min, uint32 max)
{
  if (expr->symbol == NULL || SYMBOL_IS_DEFINED (expr->symbol))
    {
      /* If expression can be evaluated, compare its value against the limits
	     and complain if the value is out of bounds. */
      uint32 value = (uint32)eval_imm_expr (expr);

      if (value < min || max < value)
	{
	  char str[200];
	  sprintf (str, "immediate value (%d) out of range (%d .. %d)",
		   (int32)value, (int32)min, (int32)max);
	  yywarn (str);
	}
    }
}

void
yyerror (char *s)
{
  parse_error_occurred = 1;
  clear_labels ();
  yywarn (s);
}


void
yywarn (char *s)
{
  error ("spim: (parser) %s on line %d of file %s\n", s, line_no, input_file_name);
  print_erroneous_line ();
}


static void
mips32_r2_inst ()
{
	yyerror ("Warning: MIPS32 Rev 2 instruction is not implemented. Instruction ignored.");
}


static int
cc_to_rt (int cc, int nd, int tf)
{
  return (cc << 2) | (nd << 1) | tf;
}
/* SPIM S20 MIPS simulator.
   Parser for instructions and assembler directives.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: $
*/



%start LINE

%token Y_EOF

%token Y_NL
%token Y_INT
%token Y_ID
%token Y_REG
%token Y_FP_REG
%token Y_STR
%token Y_FP

/* MIPS instructions op codes: */

%token Y_ABS_D_OP
%token Y_ABS_PS_OP
%token Y_ABS_S_OP
%token Y_ADD_D_OP
%token Y_ADD_OP
%token Y_ADD_PS_OP
%token Y_ADD_S_OP
%token Y_ADDI_OP
%token Y_ADDIU_OP
%token Y_ADDU_OP
%token Y_ALNV_PS_OP
%token Y_AND_OP
%token Y_ANDI_OP
%token Y_BC1F_OP
%token Y_BC1FL_OP
%token Y_BC1T_OP
%token Y_BC1TL_OP
%token Y_BC2F_OP
%token Y_BC2FL_OP
%token Y_BC2T_OP
%token Y_BC2TL_OP
%token Y_BEQ_OP
%token Y_BEQL_OP
%token Y_BGEZ_OP
%token Y_BGEZAL_OP
%token Y_BGEZALL_OP
%token Y_BGEZL_OP
%token Y_BGTZ_OP
%token Y_BGTZL_OP
%token Y_BLEZ_OP
%token Y_BLEZL_OP
%token Y_BLTZ_OP
%token Y_BLTZAL_OP
%token Y_BLTZALL_OP
%token Y_BLTZL_OP
%token Y_BNE_OP
%token Y_BNEL_OP
%token Y_BREAK_OP
%token Y_C_EQ_D_OP
%token Y_C_EQ_PS_OP
%token Y_C_EQ_S_OP
%token Y_C_F_D_OP
%token Y_C_F_PS_OP
%token Y_C_F_S_OP
%token Y_C_LE_D_OP
%token Y_C_LE_PS_OP
%token Y_C_LE_S_OP
%token Y_C_LT_D_OP
%token Y_C_LT_PS_OP
%token Y_C_LT_S_OP
%token Y_C_NGE_D_OP
%token Y_C_NGE_PS_OP
%token Y_C_NGE_S_OP
%token Y_C_NGL_D_OP
%token Y_C_NGL_PS_OP
%token Y_C_NGL_S_OP
%token Y_C_NGLE_D_OP
%token Y_C_NGLE_PS_OP
%token Y_C_NGLE_S_OP
%token Y_C_NGT_D_OP
%token Y_C_NGT_PS_OP
%token Y_C_NGT_S_OP
%token Y_C_OLE_D_OP
%token Y_C_OLE_PS_OP
%token Y_C_OLE_S_OP
%token Y_C_OLT_D_OP
%token Y_C_OLT_PS_OP
%token Y_C_OLT_S_OP
%token Y_C_SEQ_D_OP
%token Y_C_SEQ_PS_OP
%token Y_C_SEQ_S_OP
%token Y_C_SF_D_OP
%token Y_C_SF_PS_OP
%token Y_C_SF_S_OP
%token Y_C_UEQ_D_OP
%token Y_C_UEQ_PS_OP
%token Y_C_UEQ_S_OP
%token Y_C_ULE_D_OP
%token Y_C_ULE_PS_OP
%token Y_C_ULE_S_OP
%token Y_C_ULT_D_OP
%token Y_C_ULT_PS_OP
%token Y_C_ULT_S_OP
%token Y_C_UN_D_OP
%token Y_C_UN_PS_OP
%token Y_C_UN_S_OP
%token Y_CACHE_OP
%token Y_CEIL_L_D_OP
%token Y_CEIL_L_S_OP
%token Y_CEIL_W_D_OP
%token Y_CEIL_W_S_OP
%token Y_CFC0_OP
%token Y_CFC1_OP
%token Y_CFC2_OP
%token Y_CLO_OP
%token Y_CLZ_OP
%token Y_COP2_OP
%token Y_CTC0_OP
%token Y_CTC1_OP
%token Y_CTC2_OP
%token Y_CVT_D_L_OP
%token Y_CVT_D_S_OP
%token Y_CVT_D_W_OP
%token Y_CVT_L_D_OP
%token Y_CVT_L_S_OP
%token Y_CVT_PS_S_OP
%token Y_CVT_S_D_OP
%token Y_CVT_S_L_OP
%token Y_CVT_S_PL_OP
%token Y_CVT_S_PU_OP
%token Y_CVT_S_W_OP
%token Y_CVT_W_D_OP
%token Y_CVT_W_S_OP
%token Y_DERET_OP
%token Y_DI_OP
%token Y_DIV_D_OP
%token Y_DIV_OP
%token Y_DIV_S_OP
%token Y_DIVU_OP
%token Y_EHB_OP
%token Y_EI_OP
%token Y_ERET_OP
%token Y_EXT_OP
%token Y_FLOOR_L_D_OP
%token Y_FLOOR_L_S_OP
%token Y_FLOOR_W_D_OP
%token Y_FLOOR_W_S_OP
%token Y_INS_OP
%token Y_J_OP
%token Y_JAL_OP
%token Y_JALR_HB_OP
%token Y_JALR_OP
%token Y_JR_HB_OP
%token Y_JR_OP
%token Y_LB_OP
%token Y_LBU_OP
%token Y_LDC1_OP
%token Y_LDC2_OP
%token Y_LDXC1_OP
%token Y_LH_OP
%token Y_LHU_OP
%token Y_LL_OP
%token Y_LUI_OP
%token Y_LUXC1_OP
%token Y_LW_OP
%token Y_LWC1_OP
%token Y_LWC2_OP
%token Y_LWL_OP
%token Y_LWR_OP
%token Y_LWXC1_OP
%token Y_MADD_D_OP
%token Y_MADD_OP
%token Y_MADD_PS_OP
%token Y_MADD_S_OP
%token Y_MADDU_OP
%token Y_MFC0_OP
%token Y_MFC1_OP
%token Y_MFC2_OP
%token Y_MFHC1_OP
%token Y_MFHC2_OP
%token Y_MFHI_OP
%token Y_MFLO_OP
%token Y_MOV_D_OP
%token Y_MOV_PS_OP
%token Y_MOV_S_OP
%token Y_MOVF_D_OP
%token Y_MOVF_OP
%token Y_MOVF_PS_OP
%token Y_MOVF_S_OP
%token Y_MOVN_D_OP
%token Y_MOVN_OP
%token Y_MOVN_PS_OP
%token Y_MOVN_S_OP
%token Y_MOVT_D_OP
%token Y_MOVT_OP
%token Y_MOVT_PS_OP
%token Y_MOVT_S_OP
%token Y_MOVZ_D_OP
%token Y_MOVZ_OP
%token Y_MOVZ_PS_OP
%token Y_MOVZ_S_OP
%token Y_MSUB_D_OP
%token Y_MSUB_OP
%token Y_MSUB_PS_OP
%token Y_MSUB_S_OP
%token Y_MSUBU_OP
%token Y_MTC0_OP
%token Y_MTC1_OP
%token Y_MTC2_OP
%token Y_MTHC1_OP
%token Y_MTHC2_OP
%token Y_MTHI_OP
%token Y_MTLO_OP
%token Y_MUL_D_OP
%token Y_MUL_PS_OP
%token Y_MUL_S_OP
%token Y_MUL_OP
%token Y_MULT_OP
%token Y_MULTU_OP
%token Y_NEG_D_OP
%token Y_NEG_PS_OP
%token Y_NEG_S_OP
%token Y_NMADD_D_OP
%token Y_NMADD_PS_OP
%token Y_NMADD_S_OP
%token Y_NMSUB_D_OP
%token Y_NMSUB_PS_OP
%token Y_NMSUB_S_OP
%token Y_NOR_OP
%token Y_OR_OP
%token Y_ORI_OP
%token Y_PFW_OP
%token Y_PLL_PS_OP
%token Y_PLU_PS_OP
%token Y_PREF_OP
%token Y_PREFX_OP
%token Y_PUL_PS_OP
%token Y_PUU_PS_OP
%token Y_RDHWR_OP
%token Y_RDPGPR_OP
%token Y_RECIP_D_OP
%token Y_RECIP_S_OP
%token Y_RFE_OP
%token Y_ROTR_OP
%token Y_ROTRV_OP
%token Y_ROUND_L_D_OP
%token Y_ROUND_L_S_OP
%token Y_ROUND_W_D_OP
%token Y_ROUND_W_S_OP
%token Y_RSQRT_D_OP
%token Y_RSQRT_S_OP
%token Y_SB_OP
%token Y_SC_OP
%token Y_SDBBP_OP
%token Y_SDC1_OP
%token Y_SDC2_OP
%token Y_SDXC1_OP
%token Y_SEB_OP
%token Y_SEH_OP
%token Y_SH_OP
%token Y_SLL_OP
%token Y_SLLV_OP
%token Y_SLT_OP
%token Y_SLTI_OP
%token Y_SLTIU_OP
%token Y_SLTU_OP
%token Y_SQRT_D_OP
%token Y_SQRT_S_OP
%token Y_SRA_OP
%token Y_SRAV_OP
%token Y_SRL_OP
%token Y_SRLV_OP
%token Y_SSNOP_OP
%token Y_SUB_D_OP
%token Y_SUB_OP
%token Y_SUB_PS_OP
%token Y_SUB_S_OP
%token Y_SUBU_OP
%token Y_SUXC1_OP
%token Y_SW_OP
%token Y_SWC1_OP
%token Y_SWC2_OP
%token Y_SWL_OP
%token Y_SWR_OP
%token Y_SWXC1_OP
%token Y_SYNC_OP
%token Y_SYNCI_OP
%token Y_SYSCALL_OP
%token Y_TEQ_OP
%token Y_TEQI_OP
%token Y_TGE_OP
%token Y_TGEI_OP
%token Y_TGEIU_OP
%token Y_TGEU_OP
%token Y_TLBP_OP
%token Y_TLBR_OP
%token Y_TLBWI_OP
%token Y_TLBWR_OP
%token Y_TLT_OP
%token Y_TLTI_OP
%token Y_TLTIU_OP
%token Y_TLTU_OP
%token Y_TNE_OP
%token Y_TNEI_OP
%token Y_TRUNC_L_D_OP
%token Y_TRUNC_L_S_OP
%token Y_TRUNC_W_D_OP
%token Y_TRUNC_W_S_OP
%token Y_WRPGPR_OP
%token Y_WSBH_OP
%token Y_XOR_OP
%token Y_XORI_OP


/* Assembler pseudo operations op codes: */

%token Y_ABS_POP
%token Y_B_POP
%token Y_BAL_POP
%token Y_BEQZ_POP
%token Y_BGE_POP
%token Y_BGEU_POP
%token Y_BGT_POP
%token Y_BGTU_POP
%token Y_BLE_POP
%token Y_BLEU_POP
%token Y_BLT_POP
%token Y_BLTU_POP
%token Y_BNEZ_POP
%token Y_LA_POP
%token Y_LD_POP
%token Y_L_D_POP
%token Y_L_S_POP
%token Y_LI_D_POP
%token Y_LI_POP
%token Y_LI_S_POP
%token Y_MFC1_D_POP
%token Y_MOVE_POP
%token Y_MTC1_D_POP
%token Y_MULO_POP
%token Y_MULOU_POP
%token Y_NEG_POP
%token Y_NEGU_POP
%token Y_NOP_POP
%token Y_NOT_POP
%token Y_REM_POP
%token Y_REMU_POP
%token Y_ROL_POP
%token Y_ROR_POP
%token Y_S_D_POP
%token Y_S_S_POP
%token Y_SD_POP
%token Y_SEQ_POP
%token Y_SGE_POP
%token Y_SGEU_POP
%token Y_SGT_POP
%token Y_SGTU_POP
%token Y_SLE_POP
%token Y_SLEU_POP
%token Y_SNE_POP
%token Y_ULH_POP
%token Y_ULHU_POP
%token Y_ULW_POP
%token Y_USH_POP
%token Y_USW_POP

/* Assembler directives: */

%token Y_ALIAS_DIR
%token Y_ALIGN_DIR
%token Y_ASCII_DIR
%token Y_ASCIIZ_DIR
%token Y_ASM0_DIR
%token Y_BGNB_DIR
%token Y_BYTE_DIR
%token Y_COMM_DIR
%token Y_DATA_DIR
%token Y_DOUBLE_DIR
%token Y_END_DIR
%token Y_ENDB_DIR
%token Y_ENDR_DIR
%token Y_ENT_DIR
%token Y_ERR_DIR
%token Y_EXTERN_DIR
%token Y_FILE_DIR
%token Y_FLOAT_DIR
%token Y_FMASK_DIR
%token Y_FRAME_DIR
%token Y_GLOBAL_DIR
%token Y_HALF_DIR
%token Y_K_DATA_DIR
%token Y_K_TEXT_DIR
%token Y_LABEL_DIR
%token Y_LCOMM_DIR
%token Y_LIVEREG_DIR
%token Y_LOC_DIR
%token Y_MASK_DIR
%token Y_NOALIAS_DIR
%token Y_OPTIONS_DIR
%token Y_RDATA_DIR
%token Y_REPEAT_DIR
%token Y_SDATA_DIR
%token Y_SET_DIR
%token Y_SPACE_DIR
%token Y_STRUCT_DIR
%token Y_TEXT_DIR
%token Y_VERSTAMP_DIR
%token Y_VREG_DIR
%token Y_WORD_DIR

/* CS296: Honors project tokens */
%token Y_MACRO_START
%token Y_EQ_MACRO

/* ADD MORE TOKENS HERE */

%{
#include <stdio.h>
#include <math.h>

#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "mem.h"
#include "sym-tbl.h"
#include "data.h"
#include "scanner.h"
#include "parser.h"


/* return (0) */
#define LINE_PARSE_DONE YYACCEPT

/* return (1) */
#define FILE_PARSE_DONE YYABORT

typedef struct ll
{
  label *head;
  struct ll *tail;
} label_list;


/* Exported Variables: */

int data_dir;		/* Non-zero means item in data segment */

int text_dir;		/* Non-zero means item in text segment */

int parse_error_occurred; /* Non-zero => parse resulted in error */


/* Local functions: */

static imm_expr *branch_offset (int n_inst);
static int cc_to_rt (int cc, int nd, int tf);
static void check_imm_range (imm_expr*, int32, int32);
static void check_uimm_range (imm_expr*, uint32, uint32);
static void clear_labels ();
static label_list *cons_label (label *head, label_list *tail);
static void div_inst (int op, int rd, int rs, int rt, int const_divisor);
static void mips32_r2_inst ();
static void mult_inst (int op, int rd, int rs, int rt);
static void nop_inst ();
static void set_eq_inst (int op, int rd, int rs, int rt);
static void set_ge_inst (int op, int rd, int rs, int rt);
static void set_gt_inst (int op, int rd, int rs, int rt);
static void set_le_inst (int op, int rd, int rs, int rt);
static void store_word_data (int value);
static void trap_inst ();
static void yywarn (char*);


/* Local variables: */

static int null_term;		/* Non-zero means string terminate by \0 */

static void (*store_op) ();	/* Function to store items in an EXPR_LST */

static label_list *this_line_labels = NULL; /* List of label for curent line */

static int noat_flag = 0;	/* Non-zero means program can use $1 */

static char *input_file_name;	/* Name of file being parsed */

%}



%%

LINE:		{parse_error_occurred = 0; scanner_start_line (); } LBL_CMD ;

LBL_CMD:	OPT_LBL CMD
	|	CMD
	;


OPT_LBL: ID ':' {
		  /* Call outside of cons_label, since an error sets that variable to NULL. */
		  label* l = record_label ((char*)$1.p,
					   text_dir ? current_text_pc () : current_data_pc (),
					   0);
		  this_line_labels = cons_label (l, this_line_labels);
		  free ((char*)$1.p);
		}

	|	ID '=' Y_INT
		{
		  label *l = record_label ((char*)$1.p, (mem_addr)$3.i, 1);
		  free ((char*)$1.p);

		  l->const_flag = 1;
		  clear_labels ();
		}
	;


CMD:		ASM_CODE
		{
		  clear_labels ();
		}
		TERM

	|	ASM_DIRECTIVE
		{
		  clear_labels ();
		}
		TERM

	|	TERM

	/* CS296: Honors project grammar addition */
	|	HONORS_RULES
    ;

/* CS296: A macro starts with Y_MACRO_START ("#@") followed by one of the available macros */
HONORS_RULES:	Y_MACRO_START MACROS

/* CS296: The skeleton code only provides you with an implementation of:
   #@ $reg1 == $reg2
   Note that you have to also implement #@ $reg1 == some_immediate_value
 */
MACROS:		MACRO_OPERAND1 Y_EQ_MACRO MACRO_OPERAND2
		{
			/* Construct the "Assertion Failed" message should the condition be violated */
			int size1 = (int) log($1.i) + 2, size2 = (int) log($3.i) + 2;
			char *assert_failed = "Assertion failed: ";
			char *assert_msg = malloc(strlen(assert_failed) + size1 + size2 + 7);
			assert_msg[0] = '\0';
			sprintf(assert_msg, "\n%s$%d == $%d\n", assert_failed, $1.i, $3.i);

			/* Store the current pointer to the data segment which will store the address
			 * of the assertion error string.				
			 */
			int cur_data_pc = current_data_pc();

			/* Store the assertion message on the data segment */
			store_string(assert_msg, strlen(assert_msg), 1);
						
			/* Branch 26 bytes forward if the assertion condition is not violated:
			 * That is, beq MACRO_OPERAND1, MACRO_OPERAND2, 30 bytes forward.				
			 */
			i_type_inst(Y_BEQ_OP, $1.i, $3.i, const_imm_expr(30));

			/* Load the assertion error string address and store it in $a0 ($4) */
			i_type_inst(Y_ADDI_OP, 4, 0, const_imm_expr(cur_data_pc));

			/* ori $v0, $0, 4   (Equivalent to the pseudoinstruction: li $v0, 4) */
			i_type_inst(Y_ORI_OP, 2, 0, const_imm_expr(4));

			/* syscall (print string)*/
			r_type_inst(Y_SYSCALL_OP, 0, 0, 0);

			/* ori $v0, $0, 10   (Equivalent to the pseudoinstruction: li $v0, 10) */
			i_type_inst(Y_ORI_OP, 2, 0, const_imm_expr(10));

			/* syscall (exit)*/
			r_type_inst(Y_SYSCALL_OP, 0, 0, 0);

			/* We're done parsing the current line. */
			LINE_PARSE_DONE;
		}

/* CS296: Operand 1 of an assertion can only be a register */
MACRO_OPERAND1:	Y_REG 

/* CS296: Operand 2 of an assertion can be a register or an immediate integer. The skeleton
 * code assumes that the second operand is a register.
 */
MACRO_OPERAND2: Y_REG | Y_INT


TERM:		Y_NL
		{
			LINE_PARSE_DONE;
		}

	|	Y_EOF
		{
		  clear_labels ();
		  FILE_PARSE_DONE;
		}
	;



ASM_CODE:	LOAD_OPS	DEST	ADDRESS
		{
		  i_type_inst ($1.i == Y_LD_POP ? Y_LW_OP : $1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  if ($1.i == Y_LD_POP)
		    i_type_inst_free (Y_LW_OP,
				      $2.i + 1,
				      addr_expr_reg ((addr_expr *)$3.p),
				      incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
							4));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}

	|	LOADC_OPS	COP_REG	ADDRESS
		{
		  i_type_inst ($1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}

	|	LOADFP_OPS	F_SRC1	ADDRESS
		{
		  i_type_inst ($1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}

	|	LOADI_OPS	DEST	UIMM16
		{
		  i_type_inst_free ($1.i, $2.i, 0, (imm_expr *)$3.p);
		}


	|	Y_LA_POP	DEST	ADDRESS
		{
		  if (addr_expr_reg ((addr_expr *)$3.p))
		    i_type_inst (Y_ADDI_OP, $2.i,
				 addr_expr_reg ((addr_expr *)$3.p),
				 addr_expr_imm ((addr_expr *)$3.p));
		  else
		    i_type_inst (Y_ORI_OP, $2.i, 0,
				 addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	Y_LI_POP	DEST	IMM32
		{
		  i_type_inst_free (Y_ORI_OP, $2.i, 0, (imm_expr *)$3.p);
		}


	|	Y_LI_D_POP	F_DEST	Y_FP
		{
		  int *x = (int *) $3.p;

		  i_type_inst (Y_ORI_OP, 1, 0, const_imm_expr (*x));
		  r_co_type_inst (Y_MTC1_OP, 0, $2.i, 1);
		  i_type_inst (Y_ORI_OP, 1, 0, const_imm_expr (*(x+1)));
		  r_co_type_inst (Y_MTC1_OP, 0, $2.i + 1, 1);
		}


	|	Y_LI_S_POP	F_DEST	Y_FP
		{
		  float x = (float) *((double *) $3.p);
		  int *y = (int *) &x;

		  i_type_inst (Y_ORI_OP, 1, 0, const_imm_expr (*y));
		  r_co_type_inst (Y_MTC1_OP, 0, $2.i, 1);
		}


	|	Y_ULW_POP	DEST	ADDRESS
		{
#ifdef BIGENDIAN
		  i_type_inst (Y_LWL_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  i_type_inst_free (Y_LWR_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      3));
#else
		  i_type_inst_free (Y_LWL_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      3));
		  i_type_inst (Y_LWR_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
#endif
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	ULOADH_POPS	DEST	ADDRESS
		{
#ifdef BIGENDIAN
		  i_type_inst (($1.i == Y_ULH_POP ? Y_LB_OP : Y_LBU_OP),
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  i_type_inst_free (Y_LBU_OP, 1,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      1));
#else
		  i_type_inst_free (($1.i == Y_ULH_POP ? Y_LB_OP : Y_LBU_OP),
				    $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      1));
		  i_type_inst (Y_LBU_OP, 1,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
#endif
		  r_sh_type_inst (Y_SLL_OP, $2.i, $2.i, 8);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	LOADFP_INDEX_OPS F_DEST	ADDRESS
		{
		  mips32_r2_inst ();
		}


	|	STORE_OPS	SRC1	ADDRESS
		{
		  i_type_inst ($1.i == Y_SD_POP ? Y_SW_OP : $1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  if ($1.i == Y_SD_POP)
		    i_type_inst_free (Y_SW_OP, $2.i + 1,
				      addr_expr_reg ((addr_expr *)$3.p),
				      incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
							4));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	STOREC_OPS	COP_REG	ADDRESS
		{
		  i_type_inst ($1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	Y_USW_POP	SRC1	ADDRESS
		{
#ifdef BIGENDIAN
		  i_type_inst (Y_SWL_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  i_type_inst_free (Y_SWR_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      3));
#else
		  i_type_inst_free (Y_SWL_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      3));
		  i_type_inst (Y_SWR_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
#endif
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	Y_USH_POP	SRC1	ADDRESS
		{
		  i_type_inst (Y_SB_OP, $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));

		  /* ROL SRC, SRC, 8 */
		  r_sh_type_inst (Y_SLL_OP, 1, $2.i, 24);
		  r_sh_type_inst (Y_SRL_OP, $2.i, $2.i, 8);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);

		  i_type_inst_free (Y_SB_OP, $2.i,
				    addr_expr_reg ((addr_expr *)$3.p),
				    incr_expr_offset (addr_expr_imm ((addr_expr *)$3.p),
						      1));
		  /* ROR SRC, SRC, 8 */
		  r_sh_type_inst (Y_SRL_OP, 1, $2.i, 24);
		  r_sh_type_inst (Y_SLL_OP, $2.i, $2.i, 8);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);

		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	STOREFP_OPS	F_SRC1	ADDRESS
		{
		  i_type_inst ($1.i,
			       $2.i,
			       addr_expr_reg ((addr_expr *)$3.p),
			       addr_expr_imm ((addr_expr *)$3.p));
		  free (((addr_expr *)$3.p)->imm);
		  free ((addr_expr *)$3.p);
		}


	|	STOREFP_INDEX_OPS F_DEST	ADDRESS
		{
		  mips32_r2_inst ();
		}


	|	SYS_OPS
		{
		  r_type_inst ($1.i, 0, 0, 0);
		}


	|	PREFETCH_OPS	ADDRESS
		{
		  mips32_r2_inst ();
		}


	|	CACHE_OPS	Y_INT	ADDRESS
		{
		  i_type_inst_free ($1.i, $2.i, 0, (imm_expr *)$3.p);
		}


	|	TLB_OPS
		{
		  r_type_inst ($1.i, 0, 0, 0);
		}


	|	Y_SYNC_OP
		{
		  r_type_inst ($1.i, 0, 0, 0);
		}

	|	Y_SYNC_OP	Y_INT
		{
		  r_type_inst ($1.i, $2.i, 0, 0);
		}


	|	Y_BREAK_OP	Y_INT
		{
		  if ($2.i == 1)
		    yyerror ("Breakpoint 1 is reserved for debugger");
		  r_type_inst ($1.i, $2.i, 0, 0);
		}


	|	Y_NOP_POP
		{
		  nop_inst ();
		}


	|	Y_SSNOP_OP
		{
		  r_sh_type_inst (Y_SLL_OP, 0, 0, 1); /* SLL r0 r0 1 */
		}


	|	Y_ABS_POP	DEST	SRC1
		{
		  if ($2.i != $3.i)
		    r_type_inst (Y_ADDU_OP, $2.i, 0, $3.i);

		  i_type_inst_free (Y_BGEZ_OP, 0, $3.i, branch_offset (2));
		  r_type_inst (Y_SUB_OP, $2.i, 0, $3.i);
		}


	|	Y_NEG_POP	DEST	SRC1
		{
		  r_type_inst (Y_SUB_OP, $2.i, 0, $3.i);
		}


	|	Y_NEGU_POP	DEST	SRC1
		{
		  r_type_inst (Y_SUBU_OP, $2.i, 0, $3.i);
		}


	|	Y_NOT_POP	DEST	SRC1
		{
		  r_type_inst (Y_NOR_OP, $2.i, $3.i, 0);
		}


	|	Y_MOVE_POP	DEST	SRC1
		{
		  r_type_inst (Y_ADDU_OP, $2.i, 0, $3.i);
		}


	|	NULLARY_OPS
		{
		  r_type_inst ($1.i, 0, 0, 0);
		}


	|	NULLARY_OPS_REV2
		{
		  mips32_r2_inst ();
		}


	|	COUNT_LEADING_OPS DEST	SRC1
		{
		  /* RT must be equal to RD */
		  r_type_inst ($1.i, $2.i, $3.i, $2.i);
		}


	|	UNARY_OPS_REV2	DEST
		{
		  mips32_r2_inst ();
		}


	|	BINARYI_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	BINARYI_OPS	DEST	SRC1	IMM32
		{
		  i_type_inst_free (op_to_imm_op ($1.i), $2.i, $3.i,
				    (imm_expr *)$4.p);
		}

	|	BINARYI_OPS	DEST	IMM32
		{
		  i_type_inst_free (op_to_imm_op ($1.i), $2.i, $2.i,
				    (imm_expr *)$3.p);
		}


	|	BINARYIR_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $4.i, $3.i);
		}

	|	BINARYIR_OPS	DEST	SRC1	Y_INT
		{
		  r_sh_type_inst (op_to_imm_op ($1.i), $2.i, $3.i, $4.i);
		}

	|	BINARYIR_OPS	DEST	Y_INT
		{
		  r_sh_type_inst (op_to_imm_op ($1.i), $2.i, $2.i, $3.i);
		}


	|	BINARY_ARITHI_OPS DEST	SRC1	IMM16
		{
		  i_type_inst_free ($1.i, $2.i, $3.i, (imm_expr *)$4.p);
		}

	|	BINARY_ARITHI_OPS DEST	IMM16
		{
		  i_type_inst_free ($1.i, $2.i, $2.i, (imm_expr *)$3.p);
		}


	|	BINARY_LOGICALI_OPS DEST	SRC1	UIMM16
		{
		  i_type_inst_free ($1.i, $2.i, $3.i, (imm_expr *)$4.p);
		}

	|	BINARY_LOGICALI_OPS DEST	UIMM16
		{
		  i_type_inst_free ($1.i, $2.i, $2.i, (imm_expr *)$3.p);
		}


	|	SHIFT_OPS	DEST	SRC1	Y_INT
		{
		  if (($4.i < 0) || (31 < $4.i))
		    yywarn ("Shift distance can only be in the range 0..31");
		  r_sh_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SHIFT_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst (imm_op_to_op ($1.i), $2.i, $4.i, $3.i);
		}


	|	SHIFT_OPS_REV2	DEST	SRC1	Y_INT
		{
		  mips32_r2_inst ();
		}

	|	SHIFTV_OPS_REV2	DEST	SRC1	SRC2
		{
		  mips32_r2_inst ();
		}


	|	BINARY_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	BINARY_OPS	DEST	SRC1	IMM32
		{
		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    {
		      if (!zero_imm ((imm_expr *)$4.p))
			/* Use $at */
			i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		      r_type_inst ($1.i,
				   $2.i,
				   $3.i,
				   (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		    }
		  free ((imm_expr *)$4.p);
		}

	|	BINARY_OPS	DEST	IMM32
		{
		  check_uimm_range ((imm_expr *)$3.p, UIMM_MIN, UIMM_MAX);
		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    {
		      if (!zero_imm ((imm_expr *)$3.p))
			/* Use $at */
			i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$3.p);
		      r_type_inst ($1.i,
				   $2.i,
				   $2.i,
				   (zero_imm ((imm_expr *)$3.p) ? 0 : 1));
		    }
		  free ((imm_expr *)$3.p);
		}


	|	BINARY_OPS_REV2	DEST	SRC1
		{
		  mips32_r2_inst ();
		}


	|	SUB_OPS		DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SUB_OPS		DEST	SRC1	IMM32
		{
		  int val = eval_imm_expr ((imm_expr *)$4.p);

		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    i_type_inst ($1.i == Y_SUB_OP ? Y_ADDI_OP
				 : $1.i == Y_SUBU_OP ? Y_ADDIU_OP
				 : (fatal_error ("Bad SUB_OP\n"), 0),
				 $2.i,
				 $3.i,
				 make_imm_expr (-val, NULL, 0));
		  free ((imm_expr *)$4.p);
		}

	|	SUB_OPS		DEST	IMM32
		{
		  int val = eval_imm_expr ((imm_expr *)$3.p);

		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    i_type_inst ($1.i == Y_SUB_OP ? Y_ADDI_OP
				 : $1.i == Y_SUBU_OP ? Y_ADDIU_OP
				 : (fatal_error ("Bad SUB_OP\n"), 0),
				 $2.i,
				 $2.i,
				 make_imm_expr (-val, NULL, 0));
		  free ((imm_expr *)$3.p);
		}


	|	DIV_POPS	DEST	SRC1
		{
		  /* The hardware divide operation (ignore 1st arg) */
		  if ($1.i != Y_DIV_OP && $1.i != Y_DIVU_OP)
		    yyerror ("REM requires 3 arguments");
		  else
		    r_type_inst ($1.i, 0, $2.i, $3.i);
		}

	|	DIV_POPS	DEST	SRC1	SRC2
		{
		  /* Pseudo divide operations */
		  div_inst ($1.i, $2.i, $3.i, $4.i, 0);
		}

	|	DIV_POPS	DEST	SRC1	IMM32
		{
		  if (zero_imm ((imm_expr *)$4.p))
		    yyerror ("Divide by zero");
		  else
		    {
		      /* Use $at */
		      i_type_inst_free (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		      div_inst ($1.i, $2.i, $3.i, 1, 1);
		    }
		}


	|	MUL_POPS	DEST	SRC1	SRC2
		{
		  mult_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	MUL_POPS	DEST	SRC1	IMM32
		{
		  if (zero_imm ((imm_expr *)$4.p))
		    /* Optimize: n * 0 == 0 */
		    i_type_inst_free (Y_ORI_OP, $2.i, 0, (imm_expr *)$4.p);
		  else
		    {
		      /* Use $at */
		      i_type_inst_free (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		      mult_inst ($1.i, $2.i, $3.i, 1);
		    }
		}


	|	MULT_OPS	SRC1	SRC2
		{
		  r_type_inst ($1.i, 0, $2.i, $3.i);
		}


	|	MULT_OPS3	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	MULT_OPS3	DEST	SRC1	IMM32
		{
		  /* Special case, for backward compatibility with pseudo-op
		     MULT instruction */
		  i_type_inst_free (Y_ORI_OP, 1, 0, (imm_expr *)$4.p); /* Use $at */
		  r_type_inst ($1.i, $2.i, $3.i, 1);
		}


	|	Y_ROR_POP	DEST	SRC1	SRC2
		{
		  r_type_inst (Y_SUBU_OP, 1, 0, $4.i);
		  r_type_inst (Y_SLLV_OP, 1, 1, $3.i);
		  r_type_inst (Y_SRLV_OP, $2.i, $4.i, $3.i);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		}


	|	Y_ROL_POP	DEST	SRC1	SRC2
		{
		  r_type_inst (Y_SUBU_OP, 1, 0, $4.i);
		  r_type_inst (Y_SRLV_OP, 1, 1, $3.i);
		  r_type_inst (Y_SLLV_OP, $2.i, $4.i, $3.i);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		}


	|	Y_ROR_POP	DEST	SRC1	IMM32
		{
		  long dist = eval_imm_expr ((imm_expr *)$4.p);

		  check_imm_range ((imm_expr *)$4.p, 0, 31);
		  r_sh_type_inst (Y_SLL_OP, 1, $3.i, -dist);
		  r_sh_type_inst (Y_SRL_OP, $2.i, $3.i, dist);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		  free ((imm_expr *)$4.p);
		}


	|	Y_ROL_POP	DEST	SRC1	IMM32
		{
		  long dist = eval_imm_expr ((imm_expr *)$4.p);

		  check_imm_range ((imm_expr *)$4.p, 0, 31);
		  r_sh_type_inst (Y_SRL_OP, 1, $3.i, -dist);
		  r_sh_type_inst (Y_SLL_OP, $2.i, $3.i, dist);
		  r_type_inst (Y_OR_OP, $2.i, $2.i, 1);
		  free ((imm_expr *)$4.p);
		}


	|	BF_OPS_REV2	F_DEST	F_SRC2	Y_INT	Y_INT
		{
		  mips32_r2_inst ();
		}


	|	SET_LE_POPS	DEST	SRC1	SRC2
		{
		  set_le_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SET_LE_POPS	DEST	SRC1	IMM32
		{
		  if (!zero_imm ((imm_expr *)$4.p))
		    /* Use $at */
		    i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		  set_le_inst ($1.i, $2.i, $3.i,
			       (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		  free ((imm_expr *)$4.p);
		}


	|	SET_GT_POPS	DEST	SRC1	SRC2
		{
		  set_gt_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SET_GT_POPS	DEST	SRC1	IMM32
		{
		  if (!zero_imm ((imm_expr *)$4.p))
		    /* Use $at */
		    i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		  set_gt_inst ($1.i, $2.i, $3.i,
			       (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		  free ((imm_expr *)$4.p);
		}



	|	SET_GE_POPS	DEST	SRC1	SRC2
		{
		  set_ge_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SET_GE_POPS	DEST	SRC1	IMM32
		{
		  if (!zero_imm ((imm_expr *)$4.p))
		    /* Use $at */
		    i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		  set_ge_inst ($1.i, $2.i, $3.i,
			       (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		  free ((imm_expr *)$4.p);
		}


	|	SET_EQ_POPS	DEST	SRC1	SRC2
		{
		  set_eq_inst ($1.i, $2.i, $3.i, $4.i);
		}

	|	SET_EQ_POPS	DEST	SRC1	IMM32
		{
		  if (!zero_imm ((imm_expr *)$4.p))
		    /* Use $at */
		    i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$4.p);
		  set_eq_inst ($1.i, $2.i, $3.i,
			       (zero_imm ((imm_expr *)$4.p) ? 0 : 1));
		  free ((imm_expr *)$4.p);
		}


	|	BR_COP_OPS	LABEL
		{
		  /* RS and RT fields contain information on test */
		  int nd = opcode_is_nullified_branch ($1.i);
		  int tf = opcode_is_true_branch ($1.i);
		  i_type_inst_free ($1.i,
				    cc_to_rt (0, nd, tf),
				    BIN_RS ($1.i),
				    (imm_expr *)$2.p);
		}

	|	BR_COP_OPS	CC_REG	LABEL
		{
		  /* RS and RT fields contain information on test */
		  int nd = opcode_is_nullified_branch ($1.i);
		  int tf = opcode_is_true_branch ($1.i);
		  i_type_inst_free ($1.i,
				    cc_to_rt ($2.i, nd, tf),
				    BIN_RS ($1.i),
				    (imm_expr *)$3.p);
		}


	|	UNARY_BR_OPS	SRC1	LABEL
		{
		  i_type_inst_free ($1.i, 0, $2.i, (imm_expr *)$3.p);
		}


	|	UNARY_BR_POPS	SRC1	LABEL
		{
		  i_type_inst_free ($1.i == Y_BEQZ_POP ? Y_BEQ_OP : Y_BNE_OP,
			       0, $2.i, (imm_expr *)$3.p);
		}


	|	BINARY_BR_OPS	SRC1	SRC2	LABEL
		{
		  i_type_inst_free ($1.i, $3.i, $2.i, (imm_expr *)$4.p);
		}

	|	BINARY_BR_OPS	SRC1	BR_IMM32	LABEL
		{
		  if (bare_machine && !accept_pseudo_insts)
		    yyerror ("Immediate form not allowed in bare machine");
		  else
		    {
		      if (zero_imm ((imm_expr *)$3.p))
			i_type_inst ($1.i, $2.i,
				     (zero_imm ((imm_expr *)$3.p) ? 0 : 1),
				     (imm_expr *)$4.p);
		      else
			{
			  /* Use $at */
			  i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$3.p);
			  i_type_inst ($1.i, $2.i,
				       (zero_imm ((imm_expr *)$3.p) ? 0 : 1),
				       (imm_expr *)$4.p);
			}
		    }
		  free ((imm_expr *)$3.p);
		  free ((imm_expr *)$4.p);
		}


	|	BR_GT_POPS	SRC1	SRC2	LABEL
		{
		  r_type_inst ($1.i == Y_BGT_POP ? Y_SLT_OP : Y_SLTU_OP,
			       1, $3.i, $2.i); /* Use $at */
		  i_type_inst_free (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		}

	|	BR_GT_POPS	SRC1	BR_IMM32	LABEL
		{
		  if ($1.i == Y_BGT_POP)
		    {
		      /* Use $at */
		      i_type_inst_free (Y_SLTI_OP, 1, $2.i,
					incr_expr_offset ((imm_expr *)$3.p, 1));
		      i_type_inst (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		    }
		  else
		    {
		      /* Use $at */
		      /* Can't add 1 to immediate since 0xffffffff+1 = 0 < 1 */
		      i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$3.p);
		      i_type_inst_free (Y_BEQ_OP, $2.i, 1, branch_offset (3));
		      r_type_inst (Y_SLTU_OP, 1, $2.i, 1);
		      i_type_inst (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		    }
		  free ((imm_expr *)$3.p);
		  free ((imm_expr *)$4.p);
		}


	|	BR_GE_POPS	SRC1	SRC2	LABEL
		{
		  r_type_inst ($1.i == Y_BGE_POP ? Y_SLT_OP : Y_SLTU_OP,
			       1, $2.i, $3.i); /* Use $at */
		  i_type_inst_free (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		}

	|	BR_GE_POPS	SRC1	BR_IMM32	LABEL
		{
		  i_type_inst ($1.i == Y_BGE_POP ? Y_SLTI_OP : Y_SLTIU_OP,
			       1, $2.i, (imm_expr *)$3.p); /* Use $at */
		  i_type_inst_free (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		  free ((imm_expr *)$3.p);
		}


	|	BR_LT_POPS	SRC1	SRC2	LABEL
		{
		  r_type_inst ($1.i == Y_BLT_POP ? Y_SLT_OP : Y_SLTU_OP,
			       1, $2.i, $3.i); /* Use $at */
		  i_type_inst_free (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		}

	|	BR_LT_POPS	SRC1	BR_IMM32	LABEL
		{
		  i_type_inst ($1.i == Y_BLT_POP ? Y_SLTI_OP : Y_SLTIU_OP,
			       1, $2.i, (imm_expr *)$3.p); /* Use $at */
		  i_type_inst_free (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		  free ((imm_expr *)$3.p);
		}


	|	BR_LE_POPS	SRC1	SRC2	LABEL
		{
		  r_type_inst ($1.i == Y_BLE_POP ? Y_SLT_OP : Y_SLTU_OP,
			       1, $3.i, $2.i); /* Use $at */
		  i_type_inst_free (Y_BEQ_OP, 0, 1, (imm_expr *)$4.p);
		}

	|	BR_LE_POPS	SRC1	BR_IMM32	LABEL
		{
		  if ($1.i == Y_BLE_POP)
		    {
		      /* Use $at */
		      i_type_inst_free (Y_SLTI_OP, 1, $2.i,
					incr_expr_offset ((imm_expr *)$3.p, 1));
		      i_type_inst (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		    }
		  else
		    {
		      /* Use $at */
		      /* Can't add 1 to immediate since 0xffffffff+1 = 0 < 1 */
		      i_type_inst (Y_ORI_OP, 1, 0, (imm_expr *)$3.p);
		      i_type_inst (Y_BEQ_OP, $2.i, 1, (imm_expr *)$4.p);
		      r_type_inst (Y_SLTU_OP, 1, $2.i, 1);
		      i_type_inst (Y_BNE_OP, 0, 1, (imm_expr *)$4.p);
		    }
		  free ((imm_expr *)$3.p);
		  free ((imm_expr *)$4.p);
		}


	|	J_OPS		LABEL
		{
		  if (($1.i == Y_J_OP) || ($1.i == Y_JR_OP))
		    j_type_inst (Y_J_OP, (imm_expr *)$2.p);
		  else if (($1.i == Y_JAL_OP) || ($1.i == Y_JALR_OP))
		    j_type_inst (Y_JAL_OP, (imm_expr *)$2.p);
		  free ((imm_expr *)$2.p);
		}

	|	J_OPS		SRC1
		{
		  if (($1.i == Y_J_OP) || ($1.i == Y_JR_OP))
		    r_type_inst (Y_JR_OP, 0, $2.i, 0);
		  else if (($1.i == Y_JAL_OP) || ($1.i == Y_JALR_OP))
		    r_type_inst (Y_JALR_OP, 31, $2.i, 0);
		}

	|	J_OPS		DEST	SRC1
		{
		  if (($1.i == Y_J_OP) || ($1.i == Y_JR_OP))
		    r_type_inst (Y_JR_OP, 0, $3.i, 0);
		  else if (($1.i == Y_JAL_OP) || ($1.i == Y_JALR_OP))
		    r_type_inst (Y_JALR_OP, $2.i, $3.i, 0);
		}


	|	B_OPS		LABEL
		{
		  i_type_inst_free (($1.i == Y_BAL_POP ? Y_BGEZAL_OP : Y_BGEZ_OP),
				    0, 0, (imm_expr *)$2.p);
		}


	|	UNARY_TRAP_OPS	SRC1	IMM16
		{
		  i_type_inst_free ($1.i, 0, $2.i, (imm_expr *)$3.p);
		}


	|	BINARY_TRAP_OPS	SRC1	SRC2
		{
		  r_type_inst ($1.i, 0, $2.i, $3.i);
		}


	|	FP_MOVE_OPS	F_DEST	F_SRC1
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, 0);
		}


	|	FP_MOVE_OPS_REV2 F_DEST	F_SRC1
		{
		  mips32_r2_inst ();
		}


	|	MOVEC_OPS	DEST	SRC1	CC_REG
		{
		  r_type_inst ($1.i, $2.i, $3.i, cc_to_rt ($4.i, 0, 0));
		}


	|	FP_MOVEC_OPS	F_DEST	F_SRC1	REG
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, $4.i);
		}


	|	FP_MOVECC_OPS	F_DEST	F_SRC1	CC_REG
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, cc_to_rt ($4.i, 0, 0));
		}


	|	FP_MOVECC_OPS_REV2 F_DEST	F_SRC1	CC_REG
		{
		  mips32_r2_inst ();
		}


	|	FP_MOVEC_OPS_REV2 F_DEST	F_SRC1	REG
		{
		  mips32_r2_inst ();
		}


	|	MOVE_FROM_HILO_OPS REG
		{
		  r_type_inst ($1.i, $2.i, 0, 0);
		}


	|	MOVE_TO_HILO_OPS REG
		{
		  r_type_inst ($1.i, 0, $2.i, 0);
		}


	|	MOVEC_OPS	DEST	SRC1	SRC2
		{
		  r_type_inst ($1.i, $2.i, $3.i, $4.i);
		}


	|	MOVE_COP_OPS	REG	COP_REG
		{
		  if ($1.i == Y_MFC1_D_POP)
		    {
		      r_co_type_inst (Y_MFC1_OP, 0, $3.i, $2.i);
		      r_co_type_inst (Y_MFC1_OP, 0, $3.i + 1, $2.i + 1);
		    }
		  else if ($1.i == Y_MTC1_D_POP)
		    {
		      r_co_type_inst (Y_MTC1_OP, 0, $3.i, $2.i);
		      r_co_type_inst (Y_MTC1_OP, 0, $3.i + 1, $2.i + 1);
		    }
		  else
		    r_co_type_inst ($1.i, 0, $3.i, $2.i);
		}


	|	MOVE_COP_OPS_REV2 REG	COP_REG
		{
		  mips32_r2_inst ();
		}


	|	CTL_COP_OPS	REG	COP_REG
		{
		  r_co_type_inst ($1.i, 0, $3.i, $2.i);
		}


	|	FP_UNARY_OPS	F_DEST	F_SRC2
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, 0);
		}


	|	FP_UNARY_OPS_REV2 F_DEST	F_SRC2
		{
		  mips32_r2_inst ();
		}


	|	FP_BINARY_OPS	F_DEST	F_SRC1	F_SRC2
		{
		  r_co_type_inst ($1.i, $2.i, $3.i, $4.i);
		}


	|	FP_BINARY_OPS_REV2 F_DEST	F_SRC1	F_SRC2
		{
		  mips32_r2_inst ();
		}


	|	FP_TERNARY_OPS_REV2 F_DEST	F_SRC1	F_SRC2	FP_REGISTER
		{
		  mips32_r2_inst ();
		}


	|	FP_CMP_OPS	F_SRC1	F_SRC2
		{
		  r_cond_type_inst ($1.i, $2.i, $3.i, 0);
		}


	|	FP_CMP_OPS	CC_REG	F_SRC1	F_SRC2
		{
		  r_cond_type_inst ($1.i, $3.i, $4.i, $2.i);
		}


	|	FP_CMP_OPS_REV2	F_SRC1	F_SRC2
		{
		  mips32_r2_inst ();
		}


	|	Y_COP2_OP	IMM32
		{
		  i_type_inst_free ($1.i, 0, 0, (imm_expr *)$2.p);
		}
	;



LOAD_OPS:	Y_LB_OP
	|	Y_LBU_OP
	|	Y_LH_OP
	|	Y_LHU_OP
	|	Y_LL_OP
	|	Y_LW_OP
	|	Y_LWL_OP
	|	Y_LWR_OP
	|	Y_PFW_OP
	|	Y_LD_POP
	;

LOADI_OPS:	Y_LUI_OP
	;

ULOADH_POPS:	Y_ULH_POP
	|	Y_ULHU_POP
	;

LOADC_OPS:	Y_LDC2_OP
	|	Y_LWC2_OP
	;

LOADFP_OPS:	Y_LDC1_OP
	|	Y_LWC1_OP
	|	Y_L_D_POP { $$.i = Y_LDC1_OP; }
	|	Y_L_S_POP { $$.i = Y_LWC1_OP; }
	;

LOADFP_INDEX_OPS:	Y_LDXC1_OP
	|	Y_LUXC1_OP
	|	Y_LWXC1_OP
	;

STORE_OPS:	Y_SB_OP
	|	Y_SC_OP
	|	Y_SH_OP
	|	Y_SW_OP
	|	Y_SWL_OP
	|	Y_SWR_OP
	|	Y_SD_POP
	;

STOREC_OPS:	Y_SWC2_OP
	|	Y_SDC2_OP
	|	Y_S_D_POP { $$.i = Y_SDC1_OP; }
	|	Y_S_S_POP { $$.i = Y_SWC1_OP; }
	;

STOREFP_OPS:	Y_SWC1_OP
	|	Y_SDC1_OP
	;

STOREFP_INDEX_OPS:	Y_SDXC1_OP
	|	Y_SUXC1_OP
	|	Y_SWXC1_OP
	;

SYS_OPS:	Y_RFE_OP
		{
#ifdef MIPS1
			yywarn ("RFE should only be used when SPIM is compiled as a MIPS-I processor");
#endif
		}
	|	Y_SYSCALL_OP
	;

PREFETCH_OPS:	Y_PREFX_OP
	|	Y_SYNCI_OP
	;

CACHE_OPS:	Y_CACHE_OP
	|	Y_PREF_OP
	;

TLB_OPS:	Y_TLBP_OP
	|	Y_TLBR_OP
	|	Y_TLBWI_OP
	|	Y_TLBWR_OP
	;

NULLARY_OPS:	Y_ERET_OP
		{
#ifdef MIPS1
			yywarn ("ERET should only be used when SPIM is compiled as a MIPS32 processor");
#endif
		}
	;

NULLARY_OPS_REV2:	Y_DERET_OP
	|	Y_EHB_OP
	|	Y_SDBBP_OP
	;

COUNT_LEADING_OPS:	Y_CLO_OP
	|	Y_CLZ_OP
	;

UNARY_OPS_REV2:	Y_DI_OP
	|	Y_EI_OP
	;

/* These binary operations have immediate analogues. */

BINARYI_OPS:	Y_ADD_OP
	|	Y_ADDU_OP
	|	Y_AND_OP
	|	Y_XOR_OP
	|	Y_OR_OP
	|	Y_SLT_OP
	|	Y_SLTU_OP
	;

BINARYIR_OPS:	Y_SLLV_OP
	|	Y_SRAV_OP
	|	Y_SRLV_OP
	;

BINARY_ARITHI_OPS:	Y_ADDI_OP
	|	Y_ADDIU_OP
	|	Y_SLTI_OP
	|	Y_SLTIU_OP
	;

BINARY_LOGICALI_OPS:	Y_ANDI_OP
	|	Y_ORI_OP
	|	Y_XORI_OP
	;

SHIFT_OPS:	Y_SLL_OP
	|	Y_SRA_OP
	|	Y_SRL_OP
	;

SHIFT_OPS_REV2:	Y_ROTR_OP
	;

SHIFTV_OPS_REV2:	Y_ROTRV_OP
	;


/* These binary operations do not have immediate analogues. */

BINARY_OPS:	Y_NOR_OP
	;

BINARY_OPS_REV2:	Y_RDHWR_OP
	|	Y_RDPGPR_OP
	|	Y_SEB_OP
	|	Y_SEH_OP
	|	Y_WRPGPR_OP
	|	Y_WSBH_OP
	;

SUB_OPS:	Y_SUB_OP
	|	Y_SUBU_OP
	;

DIV_POPS:	Y_DIV_OP
	|	Y_DIVU_OP
	|	Y_REM_POP
	|	Y_REMU_POP
	;

MUL_POPS:	Y_MULO_POP
	|	Y_MULOU_POP
	;

SET_LE_POPS:	Y_SLE_POP
	|	Y_SLEU_POP
	;

SET_GT_POPS:	Y_SGT_POP
	|	Y_SGTU_POP
	;

SET_GE_POPS:	Y_SGE_POP
	|	Y_SGEU_POP
	;

SET_EQ_POPS:	Y_SEQ_POP
	|	Y_SNE_POP
	;

MULT_OPS:	Y_MULT_OP
	|	Y_MULTU_OP
	|	Y_MADD_OP
	|	Y_MADDU_OP
	|	Y_MSUB_OP
	|	Y_MSUBU_OP
	;

MULT_OPS3: Y_MUL_OP
	;

BF_OPS_REV2:	Y_EXT_OP
	|	Y_INS_OP
	;

BR_COP_OPS:	Y_BC1F_OP
	|	Y_BC1FL_OP
	|	Y_BC1T_OP
	|	Y_BC1TL_OP
	|	Y_BC2F_OP
	|	Y_BC2FL_OP
	|	Y_BC2T_OP
	|	Y_BC2TL_OP
	;

UNARY_BR_OPS:	Y_BGEZ_OP
	|	Y_BGEZL_OP
	|	Y_BGEZAL_OP
	|	Y_BGEZALL_OP
	|	Y_BGTZ_OP
	|	Y_BGTZL_OP
	|	Y_BLEZ_OP
	|	Y_BLEZL_OP
	|	Y_BLTZ_OP
	|	Y_BLTZL_OP
	|	Y_BLTZAL_OP
	|	Y_BLTZALL_OP
	;

UNARY_BR_POPS:	Y_BEQZ_POP
	|	Y_BNEZ_POP
	;

BINARY_BR_OPS:	Y_BEQ_OP
	|	Y_BEQL_OP
	|	Y_BNE_OP
	|	Y_BNEL_OP
	;

BR_GT_POPS:	Y_BGT_POP
	|	Y_BGTU_POP

BR_GE_POPS:	Y_BGE_POP
	|	Y_BGEU_POP

BR_LT_POPS:	Y_BLT_POP
	|	Y_BLTU_POP

BR_LE_POPS:	Y_BLE_POP
	|	Y_BLEU_POP
	;

J_OPS:	Y_J_OP
	|	Y_JR_OP
	|	Y_JR_HB_OP { yywarn ("Warning:IPS32 Rev 2 '.HB' extension is not implemented and is ignored"); }
	|	Y_JAL_OP
	|	Y_JALR_OP
	|	Y_JALR_HB_OP { yywarn ("Warning:IPS32 Rev 2 '.HB' extension is not implemented and is ignored"); }
	;

B_OPS:	Y_B_POP
	|	Y_BAL_POP
	;


UNARY_TRAP_OPS:	Y_TEQI_OP
	|	Y_TGEI_OP
	|	Y_TGEIU_OP
	|	Y_TLTI_OP
	|	Y_TLTIU_OP
	|	Y_TNEI_OP
	;

BINARY_TRAP_OPS:	Y_TEQ_OP
	|	Y_TGE_OP
	|	Y_TGEU_OP
	|	Y_TLT_OP
	|	Y_TLTU_OP
	|	Y_TNE_OP
	;


MOVE_FROM_HILO_OPS:	Y_MFHI_OP
	|	Y_MFLO_OP
	;

MOVE_TO_HILO_OPS:	Y_MTHI_OP
	|	Y_MTLO_OP
	;

MOVEC_OPS:	Y_MOVN_OP
	|	Y_MOVZ_OP
	;

MOVE_COP_OPS:	Y_MFC0_OP
	|	Y_MFC1_OP
	|	Y_MFC1_D_POP
	|	Y_MFC2_OP
	|	Y_MTC0_OP
	|	Y_MTC1_OP
	|	Y_MTC1_D_POP
	|	Y_MTC2_OP
	;

MOVE_COP_OPS_REV2:	Y_MFHC1_OP
	|	Y_MFHC2_OP
	|	Y_MTHC1_OP
	|	Y_MTHC2_OP
	;

CTL_COP_OPS:	Y_CFC0_OP
	|	Y_CFC1_OP
	|	Y_CFC2_OP
	|	Y_CTC0_OP
	|	Y_CTC1_OP
	|	Y_CTC2_OP
	;

/* Floating point operations */

FP_MOVE_OPS:	Y_MOV_S_OP
	|	Y_MOV_D_OP
	;

FP_MOVE_OPS_REV2:	Y_MOV_PS_OP
	;


MOVEC_OPS:	Y_MOVF_OP
	|	Y_MOVT_OP
	;


FP_MOVEC_OPS:	Y_MOVN_D_OP
	|	Y_MOVN_S_OP
	|	Y_MOVZ_D_OP
	|	Y_MOVZ_S_OP
	;

FP_MOVEC_OPS_REV2:	Y_MOVN_PS_OP
	|	Y_MOVZ_PS_OP
	;


FP_MOVECC_OPS:	Y_MOVF_D_OP
	|	Y_MOVF_S_OP
	|	Y_MOVT_D_OP
	|	Y_MOVT_S_OP
	;

FP_MOVECC_OPS_REV2:	Y_MOVF_PS_OP
	|	Y_MOVT_PS_OP
	;

FP_UNARY_OPS:		Y_ABS_S_OP
	|	Y_ABS_D_OP
	|	Y_CEIL_W_D_OP
	|	Y_CEIL_W_S_OP
	|	Y_CVT_D_S_OP
	|	Y_CVT_D_W_OP
	|	Y_CVT_S_D_OP
	|	Y_CVT_S_W_OP
	|	Y_CVT_W_D_OP
	|	Y_CVT_W_S_OP
	|	Y_FLOOR_W_D_OP
	|	Y_FLOOR_W_S_OP
	|	Y_NEG_S_OP
	|	Y_NEG_D_OP
	|	Y_ROUND_W_D_OP
	|	Y_ROUND_W_S_OP
	|	Y_SQRT_D_OP
	|	Y_SQRT_S_OP
	|	Y_TRUNC_W_D_OP
	|	Y_TRUNC_W_S_OP
	;

FP_UNARY_OPS_REV2:	Y_ABS_PS_OP
	|	Y_CEIL_L_D_OP
	|	Y_CEIL_L_S_OP
	|	Y_CVT_D_L_OP
	|	Y_CVT_L_D_OP
	|	Y_CVT_L_S_OP
	|	Y_CVT_PS_S_OP
	|	Y_CVT_S_L_OP
	|	Y_CVT_S_PL_OP
	|	Y_CVT_S_PU_OP
	|	Y_FLOOR_L_D_OP
	|	Y_FLOOR_L_S_OP
	|	Y_NEG_PS_OP
	|	Y_RECIP_D_OP
	|	Y_RECIP_S_OP
	|	Y_ROUND_L_D_OP
	|	Y_ROUND_L_S_OP
	|	Y_RSQRT_D_OP
	|	Y_RSQRT_S_OP
	|	Y_TRUNC_L_D_OP
	|	Y_TRUNC_L_S_OP
	;

FP_BINARY_OPS:	Y_ADD_S_OP
	|	Y_ADD_D_OP
	|	Y_DIV_S_OP
	|	Y_DIV_D_OP
	|	Y_MUL_S_OP
	|	Y_MUL_D_OP
	|	Y_SUB_S_OP
	|	Y_SUB_D_OP
	;

FP_BINARY_OPS_REV2:	Y_ADD_PS_OP
	|	Y_MUL_PS_OP
	|	Y_PLL_PS_OP
	|	Y_PLU_PS_OP
	|	Y_PUL_PS_OP
	|	Y_PUU_PS_OP
	;

FP_TERNARY_OPS_REV2:	Y_ALNV_PS_OP
	|	Y_MADD_D_OP
	|	Y_MADD_PS_OP
	|	Y_MADD_S_OP
	|	Y_MSUB_D_OP
	|	Y_MSUB_PS_OP
	|	Y_MSUB_S_OP
	|	Y_NMADD_D_OP
	|	Y_NMADD_PS_OP
	|	Y_NMADD_S_OP
	|	Y_NMSUB_D_OP
	|	Y_NMSUB_PS_OP
	|	Y_NMSUB_S_OP
	;

FP_CMP_OPS:	Y_C_F_S_OP
	|	Y_C_UN_S_OP
	|	Y_C_EQ_S_OP
	|	Y_C_UEQ_S_OP
	|	Y_C_OLT_S_OP
	|	Y_C_OLE_S_OP
	|	Y_C_ULT_S_OP
	|	Y_C_ULE_S_OP
	|	Y_C_SF_S_OP
	|	Y_C_NGLE_S_OP
	|	Y_C_SEQ_S_OP
	|	Y_C_NGL_S_OP
	|	Y_C_LT_S_OP
	|	Y_C_NGE_S_OP
	|	Y_C_LE_S_OP
	|	Y_C_NGT_S_OP
	|	Y_C_F_D_OP
	|	Y_C_UN_D_OP
	|	Y_C_EQ_D_OP
	|	Y_C_UEQ_D_OP
	|	Y_C_OLT_D_OP
	|	Y_C_OLE_D_OP
	|	Y_C_ULT_D_OP
	|	Y_C_ULE_D_OP
	|	Y_C_SF_D_OP
	|	Y_C_NGLE_D_OP
	|	Y_C_SEQ_D_OP
	|	Y_C_NGL_D_OP
	|	Y_C_LT_D_OP
	|	Y_C_NGE_D_OP
	|	Y_C_LE_D_OP
	|	Y_C_NGT_D_OP
	;

FP_CMP_OPS_REV2:	Y_C_EQ_PS_OP
	|	Y_C_F_PS_OP
	|	Y_C_LT_PS_OP
	|	Y_C_LE_PS_OP
	|	Y_C_NGE_PS_OP
	|	Y_C_NGL_PS_OP
	|	Y_C_NGLE_PS_OP
	|	Y_C_NGT_PS_OP
	|	Y_C_OLE_PS_OP
	|	Y_C_OLT_PS_OP
	|	Y_C_SEQ_PS_OP
	|	Y_C_SF_PS_OP
	|	Y_C_UEQ_PS_OP
	|	Y_C_ULE_PS_OP
	|	Y_C_ULT_PS_OP
	|	Y_C_UN_PS_OP
	;



ASM_DIRECTIVE:	Y_ALIAS_DIR	Y_REG	Y_REG

	|	Y_ALIGN_DIR	EXPR
		{
		  align_data ($2.i);
		}

	|	Y_ASCII_DIR {null_term = 0;}	STR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}

	|	Y_ASCIIZ_DIR {null_term = 1;}	STR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_ASM0_DIR

	|	Y_BGNB_DIR	Y_INT


	|	Y_BYTE_DIR
		{store_op = store_byte;}
		EXPR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_COMM_DIR	ID	EXPR
		{
		  align_data (2);
		  if (lookup_label ((char*)$2.p)->addr == 0)
		  {
		    (void)record_label ((char*)$2.p, current_data_pc (), 1);
		    free ((char*)$2.p);
		  }
		  increment_data_pc ($3.i);
		}


	|	Y_DATA_DIR
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		}

	|	Y_DATA_DIR	Y_INT
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		  set_data_pc ($2.i);
		}


	|	Y_K_DATA_DIR
		{
		  user_kernel_data_segment (1);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		}

	|	Y_K_DATA_DIR	Y_INT
		{
		  user_kernel_data_segment (1);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		  set_data_pc ($2.i);
		}


	|	Y_DOUBLE_DIR
		{
		  store_op = store_double;
		  if (data_dir) set_data_alignment (3);
		}
		FP_EXPR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_END_DIR	OPTIONAL_ID

	|	Y_ENDB_DIR	Y_INT

	|	Y_ENDR_DIR

	|	Y_ENT_DIR	ID

	|	Y_ENT_DIR	ID	Y_INT


	|	Y_EXTERN_DIR	ID	EXPR
		{
		  extern_directive ((char*)$2.p, $3.i);
		}


	|	Y_ERR_DIR
		{
		  fatal_error ("File contains an .err directive\n");
		}


	|	Y_FILE_DIR	Y_INT	Y_STR


	|	Y_FLOAT_DIR
		{
		  store_op = store_float;
		  if (data_dir) set_data_alignment (2);
		}
		FP_EXPR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_FMASK_DIR	Y_INT	Y_INT

	|	Y_FRAME_DIR	REGISTER	Y_INT	REGISTER


	|	Y_GLOBAL_DIR	ID
		{
		  (void)make_label_global ((char*)$2.p);
		  free ((char*)$2.p);
		}


	|	Y_HALF_DIR
		{
		  store_op = store_half;
		  if (data_dir) set_data_alignment (1);
		}
		EXPR_LST
		{
		  if (text_dir)
		    yyerror ("Can't put data in text segment");
		}


	|	Y_LABEL_DIR	ID
		{
		  (void)record_label ((char*)$2.p,
				      text_dir
				      ? current_text_pc ()
				      : current_data_pc (),
				      1);
		  free ((char*)$2.p);
		}


	|	Y_LCOMM_DIR	ID	EXPR
		{
		  lcomm_directive ((char*)$2.p, $3.i);
		}


		/* Produced by cc 2.10 */
	|	Y_LIVEREG_DIR	Y_INT	Y_INT


	|	Y_LOC_DIR	Y_INT	Y_INT

	|	Y_MASK_DIR	Y_INT	Y_INT

	|	Y_NOALIAS_DIR	Y_REG	Y_REG

	|	Y_OPTIONS_DIR	ID

	|	Y_REPEAT_DIR	EXPR
		{
		  yyerror ("Warning: repeat directive ignored");
		}


	|	Y_RDATA_DIR
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		}

	|	Y_RDATA_DIR	Y_INT
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		  set_data_pc ($2.i);
		}


	|	Y_SDATA_DIR
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		}

	|	Y_SDATA_DIR	Y_INT
		{
		  user_kernel_data_segment (0);
		  data_dir = 1; text_dir = 0;
		  enable_data_alignment ();
		  set_data_pc ($2.i);
		}


	|	Y_SET_DIR	ID
		{
		  if (streq ((char*)$2.p, "noat"))
		    noat_flag = 1;
		  else if (streq ((char*)$2.p, "at"))
		    noat_flag = 0;
		}


	|	Y_SPACE_DIR	EXPR
		{
		  if (data_dir)
		    increment_data_pc ($2.i);
		  else if (text_dir)
		    increment_text_pc ($2.i);
		}


	|	Y_STRUCT_DIR	EXPR
		{
		  yyerror ("Warning: struct directive ignored");
		}


	|	Y_TEXT_DIR
		{
		  user_kernel_text_segment (0);
		  data_dir = 0; text_dir = 1;
		  enable_data_alignment ();
		}

	|	Y_TEXT_DIR	Y_INT
		{
		  user_kernel_text_segment (0);
		  data_dir = 0; text_dir = 1;
		  enable_data_alignment ();
		  set_text_pc ($2.i);
		}


	|	Y_K_TEXT_DIR
		{
		  user_kernel_text_segment (1);
		  data_dir = 0; text_dir = 1;
		  enable_data_alignment ();
		}

	|	Y_K_TEXT_DIR	Y_INT
		{
		  user_kernel_text_segment (1);
		  data_dir = 0; text_dir = 1;
		  enable_data_alignment ();
		  set_text_pc ($2.i);
		}


	|	Y_VERSTAMP_DIR	Y_INT	Y_INT

	|	Y_VREG_DIR	REGISTER	Y_INT	Y_INT


	|	Y_WORD_DIR
		{
		  store_op = store_word_data;
		  if (data_dir) set_data_alignment (2);
		}
		EXPR_LST

	;



ADDRESS:	{only_id = 1;} ADDR {only_id = 0; $$ = $2;}

ADDR:		'(' REGISTER ')'
		{
		  $$.p = make_addr_expr (0, NULL, $2.i);
		}

	|	ABS_ADDR
		{
		  $$.p = make_addr_expr ($1.i, NULL, 0);
		}

	|	ABS_ADDR '(' REGISTER ')'
		{
		  $$.p = make_addr_expr ($1.i, NULL, $3.i);
		}

	|	Y_ID
		{
		  $$.p = make_addr_expr (0, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}

	|	Y_ID '(' REGISTER ')'
		{
		  $$.p = make_addr_expr (0, (char*)$1.p, $3.i);
		  free ((char*)$1.p);
		}

	|	Y_ID '+' ABS_ADDR
		{
		  $$.p = make_addr_expr ($3.i, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}

	|	ABS_ADDR '+' ID
		{
		  $$.p = make_addr_expr ($1.i, (char*)$3.p, 0);
		}

	|	Y_ID '-' ABS_ADDR
		{
		  $$.p = make_addr_expr (- $3.i, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}

	|	Y_ID '+' ABS_ADDR '(' REGISTER ')'
		{
		  $$.p = make_addr_expr ($3.i, (char*)$1.p, $5.i);
		  free ((char*)$1.p);
		}

	|	Y_ID '-' ABS_ADDR '(' REGISTER ')'
		{
		  $$.p = make_addr_expr (- $3.i, (char*)$1.p, $5.i);
		  free ((char*)$1.p);
		}
	;


BR_IMM32:	{only_id = 1;} IMM32 {only_id = 0; $$ = $2;}

IMM16:	IMM32
		{
		  check_imm_range ($1.p, IMM_MIN, IMM_MAX);
		  $$ = $1;
		}

UIMM16:	IMM32
		{
		  check_uimm_range ($1.p, UIMM_MIN, UIMM_MAX);
		  $$ = $1;
		}


IMM32:		ABS_ADDR
		{
		  $$.p = make_imm_expr ($1.i, NULL, 0);
		}

	|	'(' ABS_ADDR ')' '>' '>' Y_INT
		{
		  $$.p = make_imm_expr ($2.i >> $6.i, NULL, 0);
		}

	|	ID
		{
		  $$.p = make_imm_expr (0, (char*)$1.p, 0);
		}

	|	Y_ID '+' ABS_ADDR
		{
		  $$.p = make_imm_expr ($3.i, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}

	|	Y_ID '-' ABS_ADDR
		{
		  $$.p = make_imm_expr (- $3.i, (char*)$1.p, 0);
		  free ((char*)$1.p);
		}
	;


ABS_ADDR:	Y_INT

	|	Y_INT '+' Y_INT
		{$$.i = $1.i + $3.i;}

	|	Y_INT Y_INT
		{
		  /* This is actually: Y_INT '-' Y_INT, since the binary
		     subtract operator gets scanned as a unary negation
		     operator. */
		  if ($2.i >= 0) yyerror ("Syntax error");
		  $$.i = $1.i - -$2.i;
		}
	;

SRC1:		REGISTER ;

SRC2:		REGISTER ;

DEST:		REGISTER ;

REG:		REGISTER ;

REGISTER:	Y_REG
		{
		  if ($1.i < 0 || $1.i > 31)
		    yyerror ("Register number out of range");
		  if ($1.i == 1 && !bare_machine && !noat_flag)
		    yyerror ("Register 1 is reserved for assembler");
		  $$ = $1;
		}

F_DEST:		FP_REGISTER ;

F_SRC1:		FP_REGISTER ;

F_SRC2:		FP_REGISTER ;

FP_REGISTER:	Y_FP_REG
		{
		  if ($1.i < 0 || $1.i > 31)
		    yyerror ("FP register number out of range");
		  $$ = $1;
		}


CC_REG:	       Y_INT
		{
		  if ($1.i < 0 || $1.i > 7)
		    yyerror ("CC register number out of range");
		  $$ = $1;
		}


COP_REG:	Y_REG

	|	Y_FP_REG

	;


LABEL:		ID
		{
		  $$.p = make_imm_expr (-(int)current_text_pc (), (char*)$1.p, 1);
		}


STR_LST:	STR_LST STR
	|	STR
	;


STR:		Y_STR
		{
		  store_string ((char*)$1.p, strlen((char*)$1.p), null_term);
		  free ((char*)$1.p);
		}
	|	Y_STR ':' Y_INT
		{
		  int i;

		  for (i = 0; i < $3.i; i ++)
		    store_string ((char*)$1.p, strlen((char*)$1.p), null_term);
		  free ((char*)$1.p);
		}
	;


EXPRESSION:	{only_id = 1;} EXPR {only_id = 0; $$ = $2;}

EXPR:		Y_INT

	|	ID
		{
		  label *l = lookup_label ((char*)$1.p);

		  if (l->addr == 0)
		    {
		      record_data_uses_symbol (current_data_pc (), l);
		      $$.p = NULL;
		    }
		  else
		    $$.i = l->addr;
		}


EXPR_LST:	EXPR_LST	EXPRESSION
		{
		  store_op ($2.p);
		}
	|	EXPRESSION
		{
		  store_op ($1.p);
		}
	|	EXPRESSION ':' Y_INT
		{
		  int i;

		  for (i = 0; i < $3.i; i ++)
		    store_op ($1.p);
		}
	;


FP_EXPR_LST:	FP_EXPR_LST Y_FP
		{
		  store_op ($2.p);
		}
	|	Y_FP
		{
		  store_op ($1.p);
		}
	;


OPTIONAL_ID:	{only_id = 1;} OPT_ID {only_id = 0; $$ = $2;}

OPT_ID:		ID
	|	{$$.p = (void*)NULL;}
	;


ID:		{only_id = 1;} Y_ID {only_id = 0; $$ = $2;}


%%

/* Maintain and update the address of labels for the current line. */

void
fix_current_label_address (mem_addr new_addr)
{
  label_list *l;

  for (l = this_line_labels; l != NULL; l = l->tail)
    {
      l->head->addr = new_addr;
    }
  clear_labels ();
}


static label_list *
cons_label (label *head, label_list *tail)
{
  label_list *c = (label_list *) malloc (sizeof (label_list));

  c->head = head;
  c->tail = tail;
  return (c);
}


static void
clear_labels ()
{
  label_list *n;

  for ( ; this_line_labels != NULL; this_line_labels = n)
    {
      resolve_label_uses (this_line_labels->head);
      n = this_line_labels->tail;
      free (this_line_labels);
    }
    this_line_labels = NULL;
}


/* Operations on op codes. */

int
op_to_imm_op (int opcode)
{
  switch (opcode)
    {
    case Y_ADD_OP: return (Y_ADDI_OP);
    case Y_ADDU_OP: return (Y_ADDIU_OP);
    case Y_AND_OP: return (Y_ANDI_OP);
    case Y_OR_OP: return (Y_ORI_OP);
    case Y_XOR_OP: return (Y_XORI_OP);
    case Y_SLT_OP: return (Y_SLTI_OP);
    case Y_SLTU_OP: return (Y_SLTIU_OP);
    case Y_SLLV_OP: return (Y_SLL_OP);
    case Y_SRAV_OP: return (Y_SRA_OP);
    case Y_SRLV_OP: return (Y_SRL_OP);
    default: fatal_error ("Can't convert op to immediate op\n"); return (0);
    }
}


int
imm_op_to_op (int opcode)
{
  switch (opcode)
    {
    case Y_ADDI_OP: return (Y_ADD_OP);
    case Y_ADDIU_OP: return (Y_ADDU_OP);
    case Y_ANDI_OP: return (Y_AND_OP);
    case Y_ORI_OP: return (Y_OR_OP);
    case Y_XORI_OP: return (Y_XOR_OP);
    case Y_SLTI_OP: return (Y_SLT_OP);
    case Y_SLTIU_OP: return (Y_SLTU_OP);
    case Y_J_OP: return (Y_JR_OP);
    case Y_LUI_OP: return (Y_ADDU_OP);
    case Y_SLL_OP: return (Y_SLLV_OP);
    case Y_SRA_OP: return (Y_SRAV_OP);
    case Y_SRL_OP: return (Y_SRLV_OP);
    default: fatal_error ("Can't convert immediate op to op\n"); return (0);
    }
}


static void
nop_inst ()
{
  r_type_inst (Y_SLL_OP, 0, 0, 0); /* = 0 */
}


static void
trap_inst ()
{
  r_type_inst (Y_BREAK_OP, 0, 0, 0);
}


static imm_expr *
branch_offset (int n_inst)
{
  return (const_imm_expr (n_inst << 2)); /* Later shifted right 2 places */
}


static void
div_inst (int op, int rd, int rs, int rt, int const_divisor)
{
  if (rd != 0 && !const_divisor)
    {
      i_type_inst_free (Y_BNE_OP, 0, rt, branch_offset (2));
      trap_inst ();
    }

  if (op == Y_DIV_OP || op == Y_REM_POP)
    r_type_inst (Y_DIV_OP, 0, rs, rt);
  else
    r_type_inst (Y_DIVU_OP, 0, rs, rt);

  if (rd != 0)
    {
      if (op == Y_DIV_OP || op == Y_DIVU_OP)
	/* Quotient */
	r_type_inst (Y_MFLO_OP, rd, 0, 0);
      else
	/* Remainder */
	r_type_inst (Y_MFHI_OP, rd, 0, 0);
    }
}


static void
mult_inst (int op, int rd, int rs, int rt)
{
  if (op == Y_MULOU_POP)
    r_type_inst (Y_MULTU_OP, 0, rs, rt);
  else
    r_type_inst (Y_MULT_OP, 0, rs, rt);
  if (op == Y_MULOU_POP && rd != 0)
    {
      r_type_inst (Y_MFHI_OP, 1, 0, 0);	/* Use $at */
      i_type_inst_free (Y_BEQ_OP, 0, 1, branch_offset (2));
      trap_inst ();
    }
  else if (op == Y_MULO_POP && rd != 0)
    {
      r_type_inst (Y_MFHI_OP, 1, 0, 0); /* use $at */
      r_type_inst (Y_MFLO_OP, rd, 0, 0);
      r_sh_type_inst (Y_SRA_OP, rd, rd, 31);
      i_type_inst_free (Y_BEQ_OP, rd, 1, branch_offset (2));
      trap_inst ();
    }
  if (rd != 0)
    r_type_inst (Y_MFLO_OP, rd, 0, 0);
}


static void
set_le_inst (int op, int rd, int rs, int rt)
{
  i_type_inst_free (Y_BNE_OP, rs, rt, branch_offset (3));
  i_type_inst_free (Y_ORI_OP, rd, 0, const_imm_expr (1));
  i_type_inst_free (Y_BEQ_OP, 0, 0, branch_offset (2));
  r_type_inst ((op == Y_SLE_POP ? Y_SLT_OP : Y_SLTU_OP), rd, rs, rt);
}


static void
set_gt_inst (int op, int rd, int rs, int rt)
{
  r_type_inst (op == Y_SGT_POP ? Y_SLT_OP : Y_SLTU_OP, rd, rt, rs);
}


static void
set_ge_inst (int op, int rd, int rs, int rt)
{
  i_type_inst_free (Y_BNE_OP, rs, rt, branch_offset (3));
  i_type_inst_free (Y_ORI_OP, rd, 0, const_imm_expr (1));
  i_type_inst_free (Y_BEQ_OP, 0, 0, branch_offset (2));
  r_type_inst (op == Y_SGE_POP ? Y_SLT_OP : Y_SLTU_OP, rd, rt, rs);
}


static void
set_eq_inst (int op, int rd, int rs, int rt)
{
  imm_expr *if_eq, *if_neq;

  if (op == Y_SEQ_POP)
    if_eq = const_imm_expr (1), if_neq = const_imm_expr (0);
  else
    if_eq = const_imm_expr (0), if_neq = const_imm_expr (1);

  i_type_inst_free (Y_BEQ_OP, rs, rt, branch_offset (3));
  /* RD <- 0 (if not equal) */
  i_type_inst_free (Y_ORI_OP, rd, 0, if_neq);
  i_type_inst_free (Y_BEQ_OP, 0, 0, branch_offset (2)); /* Branch always */
  /* RD <- 1 */
  i_type_inst_free (Y_ORI_OP, rd, 0, if_eq);
}


/* Store the value either as a datum or instruction. */

static void
store_word_data (int value)
{
  if (data_dir)
    store_word (value);
  else if (text_dir)
    store_instruction (inst_decode (value));
}



void
initialize_parser (char *file_name)
{
  input_file_name = file_name;
  only_id = 0;
  data_dir = 0;
  text_dir = 1;
}


static void
check_imm_range (imm_expr* expr, int32 min, int32 max)
{
  if (expr->symbol == NULL || SYMBOL_IS_DEFINED (expr->symbol))
    {
      /* If expression can be evaluated, compare its value against the limits
	 and complain if the value is out of bounds. */
      int32 value = eval_imm_expr (expr);

      if (value < min || max < value)
	{
	  char str[200];
	  sprintf (str, "immediate value (%d) out of range (%d .. %d)",
		   value, min, max);
	  yywarn (str);
	}
    }
}


static void
check_uimm_range (imm_expr* expr, uint32 min, uint32 max)
{
  if (expr->symbol == NULL || SYMBOL_IS_DEFINED (expr->symbol))
    {
      /* If expression can be evaluated, compare its value against the limits
	     and complain if the value is out of bounds. */
      uint32 value = (uint32)eval_imm_expr (expr);

      if (value < min || max < value)
	{
	  char str[200];
	  sprintf (str, "immediate value (%d) out of range (%d .. %d)",
		   (int32)value, (int32)min, (int32)max);
	  yywarn (str);
	}
    }
}

void
yyerror (char *s)
{
  parse_error_occurred = 1;
  clear_labels ();
  yywarn (s);
}


void
yywarn (char *s)
{
  error ("spim: (parser) %s on line %d of file %s\n", s, line_no, input_file_name);
  print_erroneous_line ();
}


static void
mips32_r2_inst ()
{
	yyerror ("Warning: MIPS32 Rev 2 instruction is not implemented. Instruction ignored.");
}


static int
cc_to_rt (int cc, int nd, int tf)
{
  return (cc << 2) | (nd << 1) | tf;
}
		  README FILE FOR SPIM, XSPIM, and PCSPIM
		  =======================================

This directory contains part of SPIM--an assembly language MIPS R2000/R3000
simulator. It contains the MIPS CPU simulator, but no user interface.


SPIM is copyrighted by James R. Larus and distributed under the
following conditions:

    You may make copies of SPIM for your own use and modify those copies.

    All copies of SPIM must retain my name and copyright notice.

    You may not sell SPIM or distribute SPIM in conjunction with a
    commercial product or service without the expressed written consent of
    James Larus.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.




The files in this directory are:

Configure
	A shell script to configure SPIM.

README	This file.


data.c, data.h
	Code to handle data directives.

inst.c, inst.h
	Code to build instructions and manipulate symbol table.

mem.c, mem.h
	Code to maintain memory.

syscall.c, syscall.h
	Code to handle system calls and exceptions.

op.h
	Definition of operations.

parser.y, parser.h
	Assembly command parser (YACC).

reg.h
	Register access macros.

run.c, run.h
	Instruction simulator.

scanner.l, scanner.h
	Lexical analyzer (LEX).

spim-syscall.h
	System call numbers.

spim-utils.c, spim-utils.h
	Misc. routines.

spim.h
	Top-level interface.

sym-tbl.c, sym-tbl.h
	Symbol table.

exceptions.s
	Standard exception handler.
/* SPIM S20 MIPS simulator.
   Declarations of registers and code for accessing them.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/reg.h 15    4/21/04 9:19p Larus $
*/


typedef int32 /*@alt unsigned int @*/ reg_word;
typedef uint32 u_reg_word;


/* General purpose registers: */

#define R_LENGTH	32

extern reg_word R[R_LENGTH];

extern reg_word HI, LO;

extern mem_addr PC, nPC;


/* Argument passing registers */

#define REG_V0		2
#define REG_A0		4
#define REG_A1		5
#define REG_A2		6
#define REG_A3		7
#define REG_FA0		12
#define REG_SP		29


/* Result registers */

#define REG_RES		2
#define REG_FRES	0


/* $gp registers */

#define REG_GP		28



/* Coprocessor registers: */

extern reg_word CCR[4][32], CPR[4][32];



/* Exeception handling registers (Coprocessor 0): */

/* BadVAddr register: */
#define CP0_BadVAddr_Reg 8
#define CP0_BadVAddr	(CPR[0][CP0_BadVAddr_Reg])

/* Count register: */
#define CP0_Count_Reg	9
#define CP0_Count	(CPR[0][CP0_Count_Reg]) /* ToDo */

/* Compare register: */
#define CP0_Compare_Reg	11
#define CP0_Compare	(CPR[0][CP0_Compare_Reg]) /* ToDo */

/* Status register: */
#define CP0_Status_Reg	12
#define CP0_Status	(CPR[0][CP0_Status_Reg])
/* Implemented fields: */
#define CP0_Status_CU	0xf0000000
#define CP0_Status_IM	0x0000ff00
#define CP0_Status_IM7  0x00008000 /* HW Int 5 */
#define CP0_Status_IM6  0x00004000 /* HW Int 4 */
#define CP0_Status_IM5  0x00002000 /* HW Int 3 */
#define CP0_Status_IM4  0x00001000 /* HW Int 2 */
#define CP0_Status_IM3  0x00000800 /* HW Int 1 */
#define CP0_Status_IM2  0x00000400 /* HW Int 0 */
#define CP0_Status_IM1  0x00000200 /* SW Int 1 */
#define CP0_Status_IM0  0x00000100 /* SW Int 0 */
#define CP0_Status_UM	0x00000010
#define CP0_Status_EXL	0x00000002
#define CP0_Status_IE	0x00000001
#define CP0_Status_Mask (CP0_Status_CU		\
			 | CP0_Status_UM	\
			 | CP0_Status_IM	\
			 | CP0_Status_EXL	\
			 | CP0_Status_IE)

/* Cause register: */
#define CP0_Cause_Reg	13
#define CP0_Cause	(CPR[0][CP0_Cause_Reg])
/* Implemented fields: */
#define CP0_Cause_BD	0x80000000
#define CP0_Cause_IP	0x0000ff00
#define CP0_Cause_IP7   0x00008000 /* HW Int 5 */
#define CP0_Cause_IP6   0x00004000 /* HW Int 4 */
#define CP0_Cause_IP5   0x00002000 /* HW Int 3 */
#define CP0_Cause_IP4   0x00001000 /* HW Int 2 */
#define CP0_Cause_IP3   0x00000800 /* HW Int 1 */
#define CP0_Cause_IP2   0x00000400 /* HW Int 0 */
#define CP0_Cause_IP1   0x00000200 /* SW Int 1 */
#define CP0_Cause_IP0   0x00000100 /* SW Int 0 */
#define CP0_Cause_ExcCode 0x0000007c
#define CP0_Cause_Mask	(CP0_Cause_BD		\
			 | CP0_Cause_IP		\
			 | CP0_Cause_IP7	\
			 | CP0_Cause_IP6	\
			 | CP0_Cause_IP5	\
			 | CP0_Cause_IP4	\
			 | CP0_Cause_IP3	\
			 | CP0_Cause_IP2	\
			 | CP0_Cause_ExcCode)
#define CP0_ExCode	((CP0_Cause & CP0_Cause_ExcCode) >> 2)

/* EPC register: */
#define CP0_EPC_Reg	14
#define CP0_EPC		(CPR[0][CP0_EPC_Reg])

/* Config register: */
#define CP0_Config_Reg	16
#define CP0_Config	(CPR[0][CP0_Config_Reg])
/* Implemented fields: */
#define CP0_Config_BE	0x000080000
#define CP0_Config_AT	0x000060000
#define CP0_Config_AR	0x00001c000
#define CP0_Config_MT	0x000000380
#define CP0_Config_Mask (CP0_Config_BE		\
			 | CP0_Config_AT	\
			 | CP0_Config_AR	\
			 | CP0_Config_MT)



/* Floating Point Coprocessor (1) registers.

   This is the MIPS32, Revision 1 FPU register set. It contains 32, 32-bit
   registers (either 32 single or 16 double precision), as in the R2010.
   The MIPS32, Revision 2 or MIPS64 register set has 32 of each type of
   register. */

#define FGR_LENGTH	32
#define FPR_LENGTH	16

extern double *FPR;		/* Dynamically allocate so overlay */
extern float *FGR;		/* is possible */
extern int *FWR;		/* is possible */


#define FPR_S(REGNO)	(FGR[REGNO])

#define FPR_D(REGNO)	(((REGNO) & 0x1) \
			 ? (run_error ("Odd FP double register number\n") , 0.0) \
			 : FPR[(REGNO) / 2])

#define FPR_W(REGNO)	(FWR[REGNO])


#define SET_FPR_S(REGNO, VALUE)	{FGR[REGNO] = (float) (VALUE);}

#define SET_FPR_D(REGNO, VALUE) {if ((REGNO) & 0x1) \
				 run_error ("Odd FP double register number\n"); \
				 else FPR[(REGNO) / 2] = (double) (VALUE);}

#define SET_FPR_W(REGNO, VALUE) {FWR[REGNO] = (int32) (VALUE);}


/* Floating point control registers: */

#define FCR		(CPR[1])


#define FIR_REG		0
#define FIR		(FCR[FIR_REG])
/* Implemented fields: */
#define FIR_W		0x0008000
#define FIR_D		0x0001000
#define FIR_S		0x0000800
#define FIR_MASK	(FIR_W | FIR_D | FIR_S)

#define FCCR_REG	25
#define FCCR		(FCR[FCCR_REG])
/* Implemented fields: */
#define FCCR_FCC	0x000000ff
#define FCCR_MASK	(FCCR_FCC)

#define FEXR_REG	26
#define FEXR		(FCR[FEXR_REG])
/* No implemented fields */

#define FENR_REG	28
#define FENR		(FCR[FENR_REG])
/* No implemented fields */

#define FCSR_REG	31
#define FCSR		(FCR[FCSR_REG])
/* Implemented fields: */
#define FCSR_FCC	0xfe800000
#define FCSR_MASK	(FCSR_FCC)
/* Floating point Cause (not implemented): */
#define FCSR_Cause_E	0x00020000
#define FCSR_Cause_V	0x00010000
#define FCSR_Cause_Z	0x00008000
#define FCSR_Cause_O	0x00004000
#define FCSR_Cause_U	0x00002000
#define FCSR_Cause_I	0x00001000
/* Floating point Enables (not implemented): */
#define FCSR_Enable_V	0x00000800
#define FCSR_Enable_Z	0x00000400
#define FCSR_Enable_O	0x00000200
#define FCSR_Enable_U	0x00000100
#define FCSR_Enable_I	0x00000080
/* Floating point Flags (not implemented): */
#define FCSR_Flag_V	0x00000040
#define FCSR_Flag_Z	0x00000020
#define FCSR_Flag_O	0x00000010
#define FCSR_Flag_U	0x00000008
#define FCSR_Flag_I	0x00000004
/* SPIM S20 MIPS simulator.
   Execute SPIM instructions.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.
   Changes for DOS and Windows versions by David A. Carley (dac@cs.wisc.edu)

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/run.c 55    4/24/04 9:55a Larus $
*/


#ifdef mips
#define _IEEE 1
#include <nan.h>
#else
#define NaN(X) ((X) != (X))
#endif

#include <math.h>
#include <stdio.h>

#ifdef WIN32
#define _WIN32_WINDOWS 0x0500
#define VC_EXTRALEAN
#include <Windows.h>
#else
#include <errno.h>
#include <signal.h>
#include <sys/time.h>
#endif

#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "mem.h"
#include "sym-tbl.h"
#include "y.tab.h"
#include "syscall.h"
#include "run.h"

int force_break = 0;	/* For the execution env. to force an execution break */

#ifndef _MSC_VER
extern int errno;
long atol (const char *);
#endif




/* Local functions: */

static void bump_CP0_timer ();
static void set_fpu_cc (int cond, int cc, int less, int equal, int unordered);
static void signed_multiply (reg_word v1, reg_word v2);
static void start_CP0_timer ();
#ifdef WIN32
void CALLBACK timer_completion_routine(LPVOID lpArgToCompletionRoutine,
				       DWORD dwTimerLowValue, DWORD dwTimerHighValue);
#endif
static void unsigned_multiply (reg_word v1, reg_word v2);


#define SIGN_BIT(X) ((X) & 0x80000000)

#define ARITH_OVFL(RESULT, OP1, OP2) (SIGN_BIT (OP1) == SIGN_BIT (OP2) \
				      && SIGN_BIT (OP1) != SIGN_BIT (RESULT))



/* True when delayed_branches is true and instruction is executing in delay
slot of another instruction. */
static int running_in_delay_slot = 0;


/* Executed delayed branch and jump instructions by running the
   instruction from the delay slot before transfering control.  Note,
   in branches that don't jump, the instruction in the delay slot is
   executed by falling through normally.

   We take advantage of the MIPS architecture, which leaves undefined
   the result of executing a delayed instruction in a delay slot.  Here
   we execute the second branch. */

#define BRANCH_INST(TEST, TARGET, NULLIFY)			\
		{						\
		  if (TEST)					\
		    {						\
		      mem_addr target = (TARGET);		\
		      if (delayed_branches)			\
			{					\
			  /* +4 since jump in delay slot */	\
			  target += BYTES_PER_WORD;		\
			}					\
		      JUMP_INST(target)				\
		     }						\
		  else if (NULLIFY)				\
		    {						\
		      /* If test fails and nullify bit set, skip\
			 instruction in delay slot. */		\
		      PC += BYTES_PER_WORD;			\
		    }						\
		 }


#define JUMP_INST(TARGET)					\
		{						\
		  if (delayed_branches)				\
		    {						\
		      running_in_delay_slot = 1;		\
		      run_spim (PC + BYTES_PER_WORD, 1, display);\
		      running_in_delay_slot = 0;		\
		    }						\
		    /* -4 since PC is bumped after this inst */	\
		    PC = (TARGET) - BYTES_PER_WORD;		\
		 }


/* If the delayed_load flag is false, the result from a load is available
   immediate.  If the delayed_load flag is true, the result from a load is
   not available until the subsequent instruction has executed (as in the
   real machine). We need a two element shift register for the value and its
   destination, as the instruction following the load can itself be a load
   instruction. */

#define LOAD_INST(DEST_A, LD, MASK)				\
		 {						\
		  LOAD_INST_BASE (DEST_A, (LD & (MASK)))	\
		 }


#define LOAD_INST_BASE(DEST_A, VALUE)				\
		{						\
		  if (delayed_loads)				\
		    {						\
		      delayed_load_addr1 = (DEST_A);		\
		      delayed_load_value1 = (VALUE); 		\
		    }						\
		    else					\
		    {						\
		      *(DEST_A) = (VALUE);			\
		    }						\
		 }


#define DO_DELAYED_UPDATE()					\
		if (delayed_loads)				\
		  {						\
		    /* Check for delayed updates */		\
		    if (delayed_load_addr2 != NULL)		\
		      {						\
			*delayed_load_addr2 = delayed_load_value2; \
		      }						\
		    delayed_load_addr2 = delayed_load_addr1;	\
		    delayed_load_value2 = delayed_load_value1;	\
		    delayed_load_addr1 = NULL;			\
		   }



/* Run the program stored in memory, starting at address PC for
   STEPS_TO_RUN instruction executions.  If flag DISPLAY is non-zero, print
   each instruction before it executes. Return non-zero if program's
   execution can continue. */

int
run_spim (mem_addr initial_PC, int steps_to_run, int display)
{
  instruction *inst;
  static reg_word *delayed_load_addr1 = NULL, delayed_load_value1;
  static reg_word *delayed_load_addr2 = NULL, delayed_load_value2;
  int step, step_size, next_step;

  PC = initial_PC;
  if (!bare_machine && mapped_io)
    next_step = IO_INTERVAL;
  else
    next_step = steps_to_run;	/* Run to completion */

  /* Start a timer running */
  start_CP0_timer();

  for (step_size = MIN (next_step, steps_to_run);
       steps_to_run > 0;
       steps_to_run -= step_size, step_size = MIN (next_step, steps_to_run))
    {
      if (!bare_machine && mapped_io)
	/* Every IO_INTERVAL steps, check if memory-mapped IO registers
	   have changed. */
	check_memory_mapped_IO ();
      /* else run inner loop for all steps */

      if ((CP0_Status & CP0_Status_IE)
	  && !(CP0_Status & CP0_Status_EXL)
	  && ((CP0_Cause & CP0_Cause_IP) & (CP0_Status & CP0_Status_IM)))
	{
	  /* There is an interrupt to process if IE bit set, EXL bit not
	     set, and non-masked IP bit set */
	  raise_exception (ExcCode_Int);
	  /* Handle interrupt now, before instruction executes, so that
	     EPC points to unexecuted instructions, which is the one to
	     return to. */
	  handle_exception ();
	}

      for (step = 0; step < step_size; step += 1)
	{
	  if (force_break)
	    {
	      force_break = 0;
	      return (1);
	    }

	  R[0] = 0;		/* Maintain invariant value */

#ifdef WIN32
	  SleepEx(0, TRUE);	      /* Put thread in awaitable state for WaitableTimer */
#else
	  {
	    /* Poll for timer expiration */
	    struct itimerval time;
	    if (-1 == getitimer (ITIMER_REAL, &time))
	      {
		perror ("getitmer failed");
	      }
	    if (time.it_value.tv_usec == 0 && time.it_value.tv_sec == 0)
	      {
		/* Timer expired.*/
		bump_CP0_timer ();

		/* Restart timer for next interval. */
		time.it_interval.tv_sec = 0;
		time.it_interval.tv_usec = 0;
		time.it_value.tv_sec = 0;
		time.it_value.tv_usec = TIMER_TICK_MS * 1000;
		if (-1 == setitimer (ITIMER_REAL, &time, NULL))
		  {
		    perror ("setitmer failed");
		  }
	      }
	  }
#endif

	  exception_occurred = 0;
	  inst = read_mem_inst (PC);
	  if (exception_occurred) /* In reading instruction */
	    {
	      exception_occurred = 0;
	      handle_exception ();
	      continue;
	    }
	  else if (inst == NULL)
	    {
	      run_error ("Attempt to execute non-instruction at 0x%08x\n", PC);
	      return (0);
	    }
	  else if (EXPR (inst) != NULL
		   && EXPR (inst)->symbol != NULL
		   && EXPR (inst)->symbol->addr == 0)
	    {
	      error ("Instruction references undefined symbol at 0x%08x\n", PC);
	      print_inst (PC);
	      run_error ("");
	      return (0);
	    }

	  if (display)
	    print_inst (PC);

#ifdef TEST_ASM
	  test_assembly (inst);
#endif

	  DO_DELAYED_UPDATE ();

	  switch (OPCODE (inst))
	    {
	    case Y_ADD_OP:
	      {
		reg_word vs = R[RS (inst)], vt = R[RT (inst)];
		reg_word sum = vs + vt;

		if (ARITH_OVFL (sum, vs, vt))
		  RAISE_EXCEPTION (ExcCode_Ov, break);
		R[RD (inst)] = sum;
		break;
	      }

	    case Y_ADDI_OP:
	      {
		reg_word vs = R[RS (inst)], imm = (short) IMM (inst);
		reg_word sum = vs + imm;

		if (ARITH_OVFL (sum, vs, imm))
		  RAISE_EXCEPTION (ExcCode_Ov, break);
		R[RT (inst)] = sum;
		break;
	      }

	    case Y_ADDIU_OP:
	      R[RT (inst)] = R[RS (inst)] + (short) IMM (inst);
	      break;

	    case Y_ADDU_OP:
	      R[RD (inst)] = R[RS (inst)] + R[RT (inst)];
	      break;

	    case Y_AND_OP:
	      R[RD (inst)] = R[RS (inst)] & R[RT (inst)];
	      break;

	    case Y_ANDI_OP:
	      R[RT (inst)] = R[RS (inst)] & (0xffff & IMM (inst));
	      break;

	    case Y_BC2F_OP:
	    case Y_BC2FL_OP:
	    case Y_BC2T_OP:
	    case Y_BC2TL_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_BEQ_OP:
	      BRANCH_INST (R[RS (inst)] == R[RT (inst)],
			   PC + IDISP (inst),
			   0);
	      break;

	    case Y_BEQL_OP:
	      BRANCH_INST (R[RS (inst)] == R[RT (inst)],
			   PC + IDISP (inst),
			   1);
	      break;

	    case Y_BGEZ_OP:
	      BRANCH_INST (SIGN_BIT (R[RS (inst)]) == 0,
			   PC + IDISP (inst),
			   0);
	      break;

	    case Y_BGEZL_OP:
	      BRANCH_INST (SIGN_BIT (R[RS (inst)]) == 0,
			   PC + IDISP (inst),
			   1);
	      break;

	    case Y_BGEZAL_OP:
	      R[31] = PC + (delayed_branches ? 2 * BYTES_PER_WORD : BYTES_PER_WORD);
	      BRANCH_INST (SIGN_BIT (R[RS (inst)]) == 0,
			   PC + IDISP (inst),
			   0);
	      break;

	    case Y_BGEZALL_OP:
	      R[31] = PC + (delayed_branches ? 2 * BYTES_PER_WORD : BYTES_PER_WORD);
	      BRANCH_INST (SIGN_BIT (R[RS (inst)]) == 0,
			   PC + IDISP (inst),
			   1);
	      break;

	    case Y_BGTZ_OP:
	      BRANCH_INST (R[RS (inst)] != 0 && SIGN_BIT (R[RS (inst)]) == 0,
			   PC + IDISP (inst),
			   0);
	      break;

	    case Y_BGTZL_OP:
	      BRANCH_INST (R[RS (inst)] != 0 && SIGN_BIT (R[RS (inst)]) == 0,
			   PC + IDISP (inst),
			   1);
	      break;

	    case Y_BLEZ_OP:
	      BRANCH_INST (R[RS (inst)] == 0 || SIGN_BIT (R[RS (inst)]) != 0,
			   PC + IDISP (inst),
			   0);
	      break;

	    case Y_BLEZL_OP:
	      BRANCH_INST (R[RS (inst)] == 0 || SIGN_BIT (R[RS (inst)]) != 0,
			   PC + IDISP (inst),
			   1);
	      break;

	    case Y_BLTZ_OP:
	      BRANCH_INST (SIGN_BIT (R[RS (inst)]) != 0,
			   PC + IDISP (inst),
			   0);
	      break;

	    case Y_BLTZL_OP:
	      BRANCH_INST (SIGN_BIT (R[RS (inst)]) != 0,
			   PC + IDISP (inst),
			   1);
	      break;

	    case Y_BLTZAL_OP:
	      R[31] = PC + (delayed_branches ? 2 * BYTES_PER_WORD : BYTES_PER_WORD);
	      BRANCH_INST (SIGN_BIT (R[RS (inst)]) != 0,
			   PC + IDISP (inst),
			   0);
	      break;

	    case Y_BLTZALL_OP:
	      R[31] = PC + (delayed_branches ? 2 * BYTES_PER_WORD : BYTES_PER_WORD);
	      BRANCH_INST (SIGN_BIT (R[RS (inst)]) != 0,
			   PC + IDISP (inst),
			   1);
	      break;

	    case Y_BNE_OP:
	      BRANCH_INST (R[RS (inst)] != R[RT (inst)],
			   PC + IDISP (inst),
			   0);
	      break;

	    case Y_BNEL_OP:
	      BRANCH_INST (R[RS (inst)] != R[RT (inst)],
			   PC + IDISP (inst),
			   1);
	      break;

	    case Y_BREAK_OP:
	      if (RD (inst) == 1)
		/* Debugger breakpoint */
		RAISE_EXCEPTION (ExcCode_Bp, return (1))
	      else
		RAISE_EXCEPTION (ExcCode_Bp, break);

	    case Y_CACHE_OP:
	      break;		/* Memory details not implemented */

	    case Y_CFC0_OP:
	      R[RT (inst)] = CCR[0][RD (inst)];
	      break;

	    case Y_CFC2_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_CLO_OP:
	      {
		reg_word val = R[RS (inst)];
		int i;
		for (i = 31; 0 <= i; i -= 1)
		  if (((val >> i) & 0x1) == 0) break;

		R[RD (inst) ] = 31 - i;
		break;
	      }

	    case Y_CLZ_OP:
	      {
		reg_word val = R[RS (inst)];
		int i;
		for (i = 31; 0 <= i; i -= 1)
		  if (((val >> i) & 0x1) == 1) break;

		R[RD (inst) ] = 31 - i;
		break;
	      }

	    case Y_COP2_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_CTC0_OP:
	      CCR[0][RD (inst)] = R[RT (inst)];
	      break;

	    case Y_CTC2_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_DIV_OP:
	      /* The behavior of this instruction is undefined on divide by
		 zero or overflow. */
	      if (R[RT (inst)] != 0
		  && !(R[RS (inst)] == 0x80000000 && R[RT (inst)] == 0xffffffff))
		{
		  LO = (reg_word) R[RS (inst)] / (reg_word) R[RT (inst)];
		  HI = (reg_word) R[RS (inst)] % (reg_word) R[RT (inst)];
		}
	      break;

	    case Y_DIVU_OP:
	      /* The behavior of this instruction is undefined on divide by
		 zero or overflow. */
	      if (R[RT (inst)] != 0
		  && !(R[RS (inst)] == 0x80000000 && R[RT (inst)] == 0xffffffff))
		{
		  LO = (u_reg_word) R[RS (inst)] / (u_reg_word) R[RT (inst)];
		  HI = (u_reg_word) R[RS (inst)] % (u_reg_word) R[RT (inst)];
		}
	      break;

	    case Y_ERET_OP:
	      {
		CP0_Status &= ~CP0_Status_EXL;	/* Clear EXL bit */
		JUMP_INST (CP0_EPC); 		/* Jump to EPC */
	      }
	      break;

	    case Y_J_OP:
	      JUMP_INST (((PC & 0xf0000000) | TARGET (inst) << 2));
	      break;

	    case Y_JAL_OP:
	      if (delayed_branches)
		R[31] = PC + 2 * BYTES_PER_WORD;
	      else
		R[31] = PC + BYTES_PER_WORD;
	      JUMP_INST (((PC & 0xf0000000) | (TARGET (inst) << 2)));
	      break;

	    case Y_JALR_OP:
	      {
		mem_addr tmp = R[RS (inst)];

		if (delayed_branches)
		  R[RD (inst)] = PC + 2 * BYTES_PER_WORD;
		else
		  R[RD (inst)] = PC + BYTES_PER_WORD;
		JUMP_INST (tmp);
	      }
	      break;

	    case Y_JR_OP:
	      {
		mem_addr tmp = R[RS (inst)];

		JUMP_INST (tmp);
	      }
	      break;

	    case Y_LB_OP:
	      LOAD_INST (&R[RT (inst)],
			 read_mem_byte (R[BASE (inst)] + IOFFSET (inst)),
			 0xffffffff);
	      break;

	    case Y_LBU_OP:
	      LOAD_INST (&R[RT (inst)],
			 read_mem_byte (R[BASE (inst)] + IOFFSET (inst)),
			 0xff);
	      break;

	    case Y_LH_OP:
	      LOAD_INST (&R[RT (inst)],
			 read_mem_half (R[BASE (inst)] + IOFFSET (inst)),
			 0xffffffff);
	      break;

	    case Y_LHU_OP:
	      LOAD_INST (&R[RT (inst)],
			 read_mem_half (R[BASE (inst)] + IOFFSET (inst)),
			 0xffff);
	      break;

	    case Y_LL_OP:
	      /* Uniprocess, so this instruction is just a load */
	      LOAD_INST (&R[RT (inst)],
			 read_mem_word (R[BASE (inst)] + IOFFSET (inst)),
			 0xffffffff);
	      break;

	    case Y_LUI_OP:
	      R[RT (inst)] = (IMM (inst) << 16) & 0xffff0000;
	      break;

	    case Y_LW_OP:
	      LOAD_INST (&R[RT (inst)],
			 read_mem_word (R[BASE (inst)] + IOFFSET (inst)),
			 0xffffffff);
	      break;

	    case Y_LDC2_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_LWC2_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_LWL_OP:
	      {
		mem_addr addr = R[BASE (inst)] + IOFFSET (inst);
		reg_word word;	/* Can't be register */
		int byte = addr & 0x3;
		reg_word reg_val = R[RT (inst)];

		word = read_mem_word (addr & 0xfffffffc);
		if (!exception_occurred)
#ifdef BIGENDIAN
		  switch (byte)
		    {
		    case 0:
		      word = word;
		      break;

		    case 1:
		      word = ((word & 0xffffff) << 8) | (reg_val & 0xff);
		      break;

		    case 2:
		      word = ((word & 0xffff) << 16) | (reg_val & 0xffff);
		      break;

		    case 3:
		      word = ((word & 0xff) << 24) | (reg_val & 0xffffff);
		      break;
		    }
#else
		switch (byte)
		  {
		  case 0:
		    word = ((word & 0xff) << 24) | (reg_val & 0xffffff);
		    break;

		  case 1:
		    word = ((word & 0xffff) << 16) | (reg_val & 0xffff);
		    break;

		  case 2:
		    word = ((word & 0xffffff) << 8) | (reg_val & 0xff);
		    break;

		  case 3:
		    word = word;
		    break;
		  }
#endif
		LOAD_INST_BASE (&R[RT (inst)], word);
		break;
	      }

	    case Y_LWR_OP:
	      {
		mem_addr addr = R[BASE (inst)] + IOFFSET (inst);
		reg_word word;	/* Can't be register */
		int byte = addr & 0x3;
		reg_word reg_val = R[RT (inst)];

		word = read_mem_word (addr & 0xfffffffc);
		if (!exception_occurred)
#ifdef BIGENDIAN
		  switch (byte)
		    {
		    case 0:
		      word = (reg_val & 0xffffff00) | ((unsigned)(word & 0xff000000) >> 24);
		      break;

		    case 1:
		      word = (reg_val & 0xffff0000) | ((unsigned)(word & 0xffff0000) >> 16);
		      break;

		    case 2:
		      word = (reg_val & 0xff000000) | ((unsigned)(word & 0xffffff00) >> 8);
		      break;

		    case 3:
		      word = word;
		      break;
		    }
#else
		switch (byte)
		  {
		  case 0:
		    word = word;
		    break;

		  case 1:
		    word = (reg_val & 0xff000000) | ((word & 0xffffff00) >> 8);
		    break;

		  case 2:
		    word = (reg_val & 0xffff0000) | ((word & 0xffff0000) >> 16);
		    break;

		  case 3:
		    word = (reg_val & 0xffffff00) | ((word & 0xff000000) >> 24);
		    break;
		  }
#endif
		LOAD_INST_BASE (&R[RT (inst)], word);
		break;
	      }

	    case Y_MADD_OP:
	    case Y_MADDU_OP:
	      {
		reg_word lo = LO, hi = HI;
		reg_word tmp;
		if (OPCODE (inst) == Y_MADD_OP)
		  {
		    signed_multiply(R[RS (inst)], R[RT (inst)]);
		  }
		else		/* Y_MADDU_OP */
		  {
		    unsigned_multiply(R[RS (inst)], R[RT (inst)]);
		  }
		tmp = lo + LO;
		if ((unsigned)tmp < (unsigned)LO || (unsigned)tmp < (unsigned)lo)
		  {
		    /* Addition of low-order word overflows */
		    hi += 1;
		  }
		LO = tmp;
		HI = hi + HI;
		break;
	      }

	    case Y_MFC0_OP:
	      R[RT (inst)] = CPR[0][FS (inst)];
	      break;

	    case Y_MFC2_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_MFHI_OP:
	      R[RD (inst)] = HI;
	      break;

	    case Y_MFLO_OP:
	      R[RD (inst)] = LO;
	      break;

	    case Y_MOVN_OP:
	      if (R[RT (inst)] != 0)
		R[RD (inst)] = R[RS (inst)];
	      break;

	    case Y_MOVZ_OP:
	      if (R[RT (inst)] == 0)
		R[RD (inst)] = R[RS (inst)];
	      break;

	    case Y_MSUB_OP:
	    case Y_MSUBU_OP:
	      {
		reg_word lo = LO, hi = HI;
		reg_word tmp;

		if (OPCODE (inst) == Y_MSUB_OP)
		  {
		    signed_multiply(R[RS (inst)], R[RT (inst)]);
		  }
		else		/* Y_MSUBU_OP */
		  {
		    unsigned_multiply(R[RS (inst)], R[RT (inst)]);
		  }

		tmp = lo - LO;
		if ((unsigned)LO > (unsigned)lo)
		  {
		    /* Subtraction of low-order word borrows */
		    hi -= 1;
		  }
		LO = tmp;
		HI = hi - HI;
		break;
	      }

	    case Y_MTC0_OP:
	      CPR[0][FS (inst)] = R[RT (inst)];
	      switch (FS (inst))
		{
		case CP0_Compare_Reg:
		  CP0_Cause &= ~CP0_Cause_IP7;	/* Writing clears HW interrupt 5 */
		  break;

		case CP0_Status_Reg:
		  CP0_Status &= CP0_Status_Mask;
		  CP0_Status |= ((CP0_Status_CU & 0x30000000) | CP0_Status_UM);
		  break;

		case CP0_Cause_Reg:
		  CPR[0][FS (inst)] &= CP0_Cause_Mask;
		  break;

		case CP0_Config_Reg:
		  CPR[0][FS (inst)] &= CP0_Config_Mask;
		  break;

		default:
		  break;
		}
	      break;

	    case Y_MTC2_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_MTHI_OP:
	      HI = R[RS (inst)];
	      break;

	    case Y_MTLO_OP:
	      LO = R[RS (inst)];
	      break;

	    case Y_MUL_OP:
	      signed_multiply(R[RS (inst)], R[RT (inst)]);
	      R[RD (inst)] = LO;
	      break;

	    case Y_MULT_OP:
	      signed_multiply(R[RS (inst)], R[RT (inst)]);
	      break;

	    case Y_MULTU_OP:
	      unsigned_multiply (R[RS (inst)], R[RT (inst)]);
	      break;

	    case Y_NOR_OP:
	      R[RD (inst)] = ~ (R[RS (inst)] | R[RT (inst)]);
	      break;

	    case Y_OR_OP:
	      R[RD (inst)] = R[RS (inst)] | R[RT (inst)];
	      break;

	    case Y_ORI_OP:
	      R[RT (inst)] = R[RS (inst)] | (0xffff & IMM (inst));
	      break;

	    case Y_PREF_OP:
	      break;		/* Memory details not implemented */

	    case Y_RFE_OP:
#ifdef MIPS1
	      /* This is MIPS-I, not compatible with MIPS32 or the
		 definition of the bits in the CP0 Status register in that
		 architecture. */
	      CP0_Status = (CP0_Status & 0xfffffff0) | ((CP0_Status & 0x3c) >> 2);
#else
	      RAISE_EXCEPTION (ExcCode_RI, {}); /* Not MIPS32 instruction */
#endif
	      break;

	    case Y_SB_OP:
	      set_mem_byte (R[BASE (inst)] + IOFFSET (inst), R[RT (inst)]);
	      break;

	    case Y_SC_OP:
	      /* Uniprocessor, so instruction is just a store */
	      set_mem_word (R[BASE (inst)] + IOFFSET (inst), R[RT (inst)]);
	      break;

	    case Y_SDC2_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_SH_OP:
	      set_mem_half (R[BASE (inst)] + IOFFSET (inst), R[RT (inst)]);
	      break;

	    case Y_SLL_OP:
	      {
		int shamt = SHAMT (inst);

		if (shamt >= 0 && shamt < 32)
		  R[RD (inst)] = R[RT (inst)] << shamt;
		else
		  R[RD (inst)] = R[RT (inst)];
		break;
	      }

	    case Y_SLLV_OP:
	      {
		int shamt = (R[RS (inst)] & 0x1f);

		if (shamt >= 0 && shamt < 32)
		  R[RD (inst)] = R[RT (inst)] << shamt;
		else
		  R[RD (inst)] = R[RT (inst)];
		break;
	      }

	    case Y_SLT_OP:
	      if (R[RS (inst)] < R[RT (inst)])
		R[RD (inst)] = 1;
	      else
		R[RD (inst)] = 0;
	      break;

	    case Y_SLTI_OP:
	      if (R[RS (inst)] < (short) IMM (inst))
		R[RT (inst)] = 1;
	      else
		R[RT (inst)] = 0;
	      break;

	    case Y_SLTIU_OP:
	      {
		int x = (short) IMM (inst);

		if ((u_reg_word) R[RS (inst)] < (u_reg_word) x)
		  R[RT (inst)] = 1;
		else
		  R[RT (inst)] = 0;
		break;
	      }

	    case Y_SLTU_OP:
	      if ((u_reg_word) R[RS (inst)] < (u_reg_word) R[RT (inst)])
		R[RD (inst)] = 1;
	      else
		R[RD (inst)] = 0;
	      break;

	    case Y_SRA_OP:
	      {
		int shamt = SHAMT (inst);
		reg_word val = R[RT (inst)];

		if (shamt >= 0 && shamt < 32)
		  R[RD (inst)] = val >> shamt;
		else
		  R[RD (inst)] = val;
		break;
	      }

	    case Y_SRAV_OP:
	      {
		int shamt = R[RS (inst)] & 0x1f;
		reg_word val = R[RT (inst)];

		if (shamt >= 0 && shamt < 32)
		  R[RD (inst)] = val >> shamt;
		else
		  R[RD (inst)] = val;
		break;
	      }

	    case Y_SRL_OP:
	      {
		int shamt = SHAMT (inst);
		u_reg_word val = R[RT (inst)];

		if (shamt >= 0 && shamt < 32)
		  R[RD (inst)] = val >> shamt;
		else
		  R[RD (inst)] = val;
		break;
	      }

	    case Y_SRLV_OP:
	      {
		int shamt = R[RS (inst)] & 0x1f;
		u_reg_word val = R[RT (inst)];

		if (shamt >= 0 && shamt < 32)
		  R[RD (inst)] = val >> shamt;
		else
		  R[RD (inst)] = val;
		break;
	      }

	    case Y_SUB_OP:
	      {
		reg_word vs = R[RS (inst)], vt = R[RT (inst)];
		reg_word diff = vs - vt;

		if (SIGN_BIT (vs) != SIGN_BIT (vt)
		    && SIGN_BIT (vs) != SIGN_BIT (diff))
		  RAISE_EXCEPTION (ExcCode_Ov, break);
		R[RD (inst)] = diff;
		break;
	      }

	    case Y_SUBU_OP:
	      R[RD (inst)] = (u_reg_word)R[RS (inst)]-(u_reg_word)R[RT (inst)];
	      break;

	    case Y_SW_OP:
	      set_mem_word (R[BASE (inst)] + IOFFSET (inst), R[RT (inst)]);
	      break;

	    case Y_SWC2_OP:
	      RAISE_EXCEPTION (ExcCode_CpU, {}); /* No Coprocessor 2 */
	      break;

	    case Y_SWL_OP:
	      {
		mem_addr addr = R[BASE (inst)] + IOFFSET (inst);
		mem_word data;
		reg_word reg = R[RT (inst)];
		int byte = addr & 0x3;

		data = read_mem_word (addr & 0xfffffffc);
#ifdef BIGENDIAN
		switch (byte)
		  {
		  case 0:
		    data = reg;
		    break;

		  case 1:
		    data = (data & 0xff000000) | (reg >> 8 & 0xffffff);
		    break;

		  case 2:
		    data = (data & 0xffff0000) | (reg >> 16 & 0xffff);
		    break;

		  case 3:
		    data = (data & 0xffffff00) | (reg >> 24 & 0xff);
		    break;
		  }
#else
		switch (byte)
		  {
		  case 0:
		    data = (data & 0xffffff00) | (reg >> 24 & 0xff);
		    break;

		  case 1:
		    data = (data & 0xffff0000) | (reg >> 16 & 0xffff);
		    break;

		  case 2:
		    data = (data & 0xff000000) | (reg >> 8 & 0xffffff);
		    break;

		  case 3:
		    data = reg;
		    break;
		  }
#endif
		set_mem_word (addr & 0xfffffffc, data);
		break;
	      }

	    case Y_SWR_OP:
	      {
		mem_addr addr = R[BASE (inst)] + IOFFSET (inst);
		mem_word data;
		reg_word reg = R[RT (inst)];
		int byte = addr & 0x3;

		data = read_mem_word (addr & 0xfffffffc);
#ifdef BIGENDIAN
		switch (byte)
		  {
		  case 0:
		    data = ((reg << 24) & 0xff000000) | (data & 0xffffff);
		    break;

		  case 1:
		    data = ((reg << 16) & 0xffff0000) | (data & 0xffff);
		    break;

		  case 2:
		    data = ((reg << 8) & 0xffffff00) | (data & 0xff) ;
		    break;

		  case 3:
		    data = reg;
		    break;
		  }
#else
		switch (byte)
		  {
		  case 0:
		    data = reg;
		    break;

		  case 1:
		    data = ((reg << 8) & 0xffffff00) | (data & 0xff) ;
		    break;

		  case 2:
		    data = ((reg << 16) & 0xffff0000) | (data & 0xffff);
		    break;

		  case 3:
		    data = ((reg << 24) & 0xff000000) | (data & 0xffffff);
		    break;
		  }
#endif
		set_mem_word (addr & 0xfffffffc, data);
		break;
	      }

	    case Y_SYNC_OP:
	      break;		/* Memory details not implemented */

	    case Y_SYSCALL_OP:
	      if (!do_syscall ())
		return (0);
	      break;

	    case Y_TEQ_OP:
	      if (R[RS (inst)] == R[RT (inst)])
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TEQI_OP:
	      if (R[RS (inst)] == IMM (inst))
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TGE_OP:
	      if (R[RS (inst)] >= R[RT (inst)])
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TGEI_OP:
	      if (R[RS (inst)] >= IMM (inst))
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TGEIU_OP:
	      if ((u_reg_word)R[RS (inst)] >= (u_reg_word)IMM (inst))
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TGEU_OP:
	      if ((u_reg_word)R[RS (inst)] >= (u_reg_word)R[RT (inst)])
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TLBP_OP:
	      RAISE_EXCEPTION(ExcCode_RI, {}); /* TLB not implemented */
	      break;

	    case Y_TLBR_OP:
	      RAISE_EXCEPTION(ExcCode_RI, {}); /* TLB not implemented */
	      break;

	    case Y_TLBWI_OP:
	      RAISE_EXCEPTION(ExcCode_RI, {}); /* TLB not implemented */
	      break;

	    case Y_TLBWR_OP:
	      RAISE_EXCEPTION(ExcCode_RI, {}); /* TLB not implemented */
	      break;

	    case Y_TLT_OP:
	      if (R[RS (inst)] < R[RT (inst)])
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TLTI_OP:
	      if (R[RS (inst)] < IMM (inst))
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TLTIU_OP:
	      if ((u_reg_word)R[RS (inst)] < (u_reg_word)IMM (inst))
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TLTU_OP:
	      if ((u_reg_word)R[RS (inst)] < (u_reg_word)R[RT (inst)])
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TNE_OP:
	      if (R[RS (inst)] != R[RT (inst)])
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_TNEI_OP:
	      if (R[RS (inst)] != IMM (inst))
		RAISE_EXCEPTION(ExcCode_Tr, {});
	      break;

	    case Y_XOR_OP:
	      R[RD (inst)] = R[RS (inst)] ^ R[RT (inst)];
	      break;

	    case Y_XORI_OP:
	      R[RT (inst)] = R[RS (inst)] ^ (0xffff & IMM (inst));
	      break;


	      /* FPA Operations */

	    case Y_ABS_S_OP:
	      SET_FPR_S (FD (inst), fabs (FPR_S (FS (inst))));
	      break;

	    case Y_ABS_D_OP:
	      SET_FPR_D (FD (inst), fabs (FPR_D (FS (inst))));
	      break;

	    case Y_ADD_S_OP:
	      SET_FPR_S (FD (inst), FPR_S (FS (inst)) + FPR_S (FT (inst)));
	      /* Should trap on inexact/overflow/underflow */
	      break;

	    case Y_ADD_D_OP:
	      SET_FPR_D (FD (inst), FPR_D (FS (inst)) + FPR_D (FT (inst)));
	      /* Should trap on inexact/overflow/underflow */
	      break;

	    case Y_BC1F_OP:
	    case Y_BC1FL_OP:
	    case Y_BC1T_OP:
	    case Y_BC1TL_OP:
	      {
		int cc = CC (inst);
		int nd = ND (inst);	/* 1 => nullify */
		int tf = TF (inst);	/* 0 => BC1F, 1 => BC1T */
		BRANCH_INST ((FCCR & (1 << cc)) == (tf << cc),
			     PC + IDISP (inst),
			     nd);
		break;
	      }

	    case Y_C_F_S_OP:
	    case Y_C_UN_S_OP:
	    case Y_C_EQ_S_OP:
	    case Y_C_UEQ_S_OP:
	    case Y_C_OLT_S_OP:
	    case Y_C_OLE_S_OP:
	    case Y_C_ULT_S_OP:
	    case Y_C_ULE_S_OP:
	    case Y_C_SF_S_OP:
	    case Y_C_NGLE_S_OP:
	    case Y_C_SEQ_S_OP:
	    case Y_C_NGL_S_OP:
	    case Y_C_LT_S_OP:
	    case Y_C_NGE_S_OP:
	    case Y_C_LE_S_OP:
	    case Y_C_NGT_S_OP:
	      {
		float v1 = FPR_S (FS (inst)), v2 = FPR_S (FT (inst));
		double dv1 = v1, dv2 = v2;
		int cond = COND (inst);
		int cc = FD (inst);

		if (NaN (dv1) || NaN (dv2))
		  {
		    if (cond & COND_IN)
		      {
			RAISE_EXCEPTION (ExcCode_FPE, break);
		      }
		    set_fpu_cc (cond, cc, 0, 0, 1);
		  }
		else
		  {
		    set_fpu_cc (cond, cc, v1 < v2, v1 == v2, 0);
		  }
	      }
	      break;

	    case Y_C_F_D_OP:
	    case Y_C_UN_D_OP:
	    case Y_C_EQ_D_OP:
	    case Y_C_UEQ_D_OP:
	    case Y_C_OLT_D_OP:
	    case Y_C_OLE_D_OP:
	    case Y_C_ULT_D_OP:
	    case Y_C_ULE_D_OP:
	    case Y_C_SF_D_OP:
	    case Y_C_NGLE_D_OP:
	    case Y_C_SEQ_D_OP:
	    case Y_C_NGL_D_OP:
	    case Y_C_LT_D_OP:
	    case Y_C_NGE_D_OP:
	    case Y_C_LE_D_OP:
	    case Y_C_NGT_D_OP:
	      {
		double v1 = FPR_D (FS (inst)), v2 = FPR_D (FT (inst));
		int cond = COND (inst);
		int cc = FD (inst);

		if (NaN (v1) || NaN (v2))
		  {
		    if (cond & COND_IN)
		      {
			RAISE_EXCEPTION (ExcCode_FPE, break);
		      }
		    set_fpu_cc (cond, cc, 0, 0, 1);
		  }
		else
		  {
		    set_fpu_cc (cond, cc, v1 < v2, v1 == v2, 0);
		  }
	      }
	      break;

	    case Y_CFC1_OP:
	      R[RT (inst)] = FCR[FS (inst)];
	      break;

	    case Y_CTC1_OP:
	      FCR[FS (inst)] = R[RT (inst)];

	      if (FIR_REG == FS (inst))
		{
		  /* Read only register */
		  FIR = FIR_MASK;
		}
	      else if (FCCR_REG == FS (inst))
		{
		  /* FCC bits in FCSR and FCCR linked */
		  FCSR = (FCSR & ~0xfe400000)
		    | ((FCCR & 0xfe) << 24)
		    | ((FCCR & 0x1) << 23);
		  FCCR &= FCCR_MASK;
		}
	      else if (FCSR_REG == FS (inst))
		{
		  /* FCC bits in FCSR and FCCR linked */
		  FCCR = ((FCSR >> 24) & 0xfe) | ((FCSR >> 23) & 0x1);
		  FCSR &= FCSR_MASK;
		  if ((R[RT (inst)] & ~FCSR_MASK) != 0)
		    /* Trying to set unsupported mode */
		    RAISE_EXCEPTION (ExcCode_FPE, {});
		}
	      break;

	    case Y_CEIL_W_D_OP:
	      {
		double val = FPR_D (FS (inst));

		SET_FPR_W (FD (inst), (int32)ceil (val));
		break;
	      }

	    case Y_CEIL_W_S_OP:
	      {
		double val = (double)FPR_S (FS (inst));

		SET_FPR_W (FD (inst), (int32)ceil (val));
		break;
	      }

	    case Y_CVT_D_S_OP:
	      {
		double val = FPR_S (FS (inst));

		SET_FPR_D (FD (inst), val);
		break;
	      }

	    case Y_CVT_D_W_OP:
	      {
		double val = (double)FPR_W (FS (inst));

		SET_FPR_D (FD (inst), val);
		break;
	      }

	    case Y_CVT_S_D_OP:
	      {
		float val = (float)FPR_D (FS (inst));

		SET_FPR_S (FD (inst), val);
		break;
	      }

	    case Y_CVT_S_W_OP:
	      {
		float val = (float)FPR_W (FS (inst));

		SET_FPR_S (FD (inst), val);
		break;
	      }

	    case Y_CVT_W_D_OP:
	      {
		int val = (int32)FPR_D (FS (inst));

		SET_FPR_W (FD (inst), val);
		break;
	      }

	    case Y_CVT_W_S_OP:
	      {
		int val = (int32)FPR_S (FS (inst));

		SET_FPR_W (FD (inst), val);
		break;
	      }

	    case Y_DIV_S_OP:
	      SET_FPR_S (FD (inst), FPR_S (FS (inst)) / FPR_S (FT (inst)));
	      break;

	    case Y_DIV_D_OP:
	      SET_FPR_D (FD (inst), FPR_D (FS (inst)) / FPR_D (FT (inst)));
	      break;

	    case Y_FLOOR_W_D_OP:
	      {
		double val = FPR_D (FS (inst));

		SET_FPR_W (FD (inst), (int32)floor (val));
		break;
	      }

	    case Y_FLOOR_W_S_OP:
	      {
		double val = (double)FPR_S (FS (inst));

		SET_FPR_W (FD (inst), (int32)floor (val));
		break;
	      }

	    case Y_LDC1_OP:
	      {
		mem_addr addr = R[BASE (inst)] + IOFFSET (inst);
		if ((addr & 0x3) != 0)
		  RAISE_EXCEPTION (ExcCode_AdEL, CP0_BadVAddr = addr);

		LOAD_INST ((reg_word *) &FPR_S(FT (inst)),
			   read_mem_word (addr),
			   0xffffffff);
		LOAD_INST ((reg_word *) &FPR_S(FT (inst) + 1),
			   read_mem_word (addr + sizeof(mem_word)),
			   0xffffffff);
		break;
	      }

	    case Y_LWC1_OP:
	      LOAD_INST ((reg_word *) &FPR_S(FT (inst)),
			 read_mem_word (R[BASE (inst)] + IOFFSET (inst)),
			 0xffffffff);
	      break;

	    case Y_MFC1_OP:
	      {
		float val = FPR_S(FS (inst));
		reg_word *vp = (reg_word *) &val;

		R[RT (inst)] = *vp; /* Fool coercion */
		break;
	      }

	    case Y_MOV_S_OP:
	      SET_FPR_S (FD (inst), FPR_S (FS (inst)));
	      break;

	    case Y_MOV_D_OP:
	      SET_FPR_D (FD (inst), FPR_D (FS (inst)));
	      break;

	    case Y_MOVF_OP:
	      {
		int cc = CC (inst);
		if ((FCCR & (1 << cc)) == 0)
		  R[RD (inst)] = R[RS (inst)];
		break;
	      }

	    case Y_MOVF_D_OP:
	      {
		int cc = CC (inst);
		if ((FCCR & (1 << cc)) == 0)
		  SET_FPR_D (FD (inst), FPR_D (FS (inst)));
		break;
	      }

	    case Y_MOVF_S_OP:
	      {
		int cc = CC (inst);
		if ((FCCR & (1 << cc)) == 0)
		  SET_FPR_S (FD (inst), FPR_S (FS (inst)));
		break;

	      }

	    case Y_MOVN_D_OP:
	      {
		if (R[RT (inst)] != 0)
		  SET_FPR_D (FD (inst), FPR_D (FS (inst)));
		break;
	      }

	    case Y_MOVN_S_OP:
	      {
		if (R[RT (inst)] != 0)
		  SET_FPR_S (FD (inst), FPR_S (FS (inst)));
		break;
	      }

	    case Y_MOVT_OP:
	      {
		int cc = CC (inst);
		if ((FCCR & (1 << cc)) != 0)
		  R[RD (inst)] = R[RS (inst)];
		break;
	      }

	    case Y_MOVT_D_OP:
	      {
		int cc = CC (inst);
		if ((FCCR & (1 << cc)) != 0)
		  SET_FPR_D (FD (inst), FPR_D (FS (inst)));
		break;
	      }

	    case Y_MOVT_S_OP:
	      {
		int cc = CC (inst);
		if ((FCCR & (1 << cc)) != 0)
		  SET_FPR_S (FD (inst), FPR_S (FS (inst)));
		break;

	      }

	    case Y_MOVZ_D_OP:
	      {
		if (R[RT (inst)] == 0)
		  SET_FPR_D (FD (inst), FPR_D (FS (inst)));
		break;
	      }

	    case Y_MOVZ_S_OP:
	      {
		if (R[RT (inst)] == 0)
		  SET_FPR_S (FD (inst), FPR_S (FS (inst)));
		break;

	      }

	    case Y_MTC1_OP:
	      {
		reg_word word = R[RT (inst)];
		float *wp = (float *) &word;

		SET_FPR_S(FS (inst), *wp); /* fool coercion */
		break;
	      }

	    case Y_MUL_S_OP:
	      SET_FPR_S (FD (inst), FPR_S (FS (inst)) * FPR_S (FT (inst)));
	      break;

	    case Y_MUL_D_OP:
	      SET_FPR_D (FD (inst), FPR_D (FS (inst)) * FPR_D (FT (inst)));
	      break;

	    case Y_NEG_S_OP:
	      SET_FPR_S (FD (inst), -FPR_S (FS (inst)));
	      break;

	    case Y_NEG_D_OP:
	      SET_FPR_D (FD (inst), -FPR_D (FS (inst)));
	      break;

	    case Y_ROUND_W_D_OP:
	      {
		double val = FPR_D (FS (inst));

		SET_FPR_W (FD (inst), (int32)(val + 0.5)); /* Casting truncates */
		break;
	      }

	    case Y_ROUND_W_S_OP:
	      {
		double val = (double)FPR_S (FS (inst));

		SET_FPR_W (FD (inst), (int32)(val + 0.5)); /* Casting truncates */
		break;
	      }

	    case Y_SDC1_OP:
	      {
		double val = FPR_D (RT (inst));
		reg_word *vp = (reg_word *) &val;
		mem_addr addr = R[BASE (inst)] + IOFFSET (inst);
		if ((addr & 0x3) != 0)
		  RAISE_EXCEPTION (ExcCode_AdEL, CP0_BadVAddr = addr);

		set_mem_word (addr, *vp);
		set_mem_word (addr + sizeof(mem_word), *(vp + 1));
		break;
	      }

	    case Y_SQRT_D_OP:
	      SET_FPR_D (FD (inst), sqrt (FPR_D (FS (inst))));
	      break;

	    case Y_SQRT_S_OP:
	      SET_FPR_S (FD (inst), sqrt (FPR_S (FS (inst))));
	      break;

	    case Y_SUB_S_OP:
	      SET_FPR_S (FD (inst), FPR_S (FS (inst)) - FPR_S (FT (inst)));
	      break;

	    case Y_SUB_D_OP:
	      SET_FPR_D (FD (inst), FPR_D (FS (inst)) - FPR_D (FT (inst)));
	      break;

	    case Y_SWC1_OP:
	      {
		float val = FPR_S(RT (inst));
		reg_word *vp = (reg_word *) &val;

		set_mem_word (R[BASE (inst)] + IOFFSET (inst), *vp);
		break;
	      }

	    case Y_TRUNC_W_D_OP:
	      {
		double val = FPR_D (FS (inst));

		SET_FPR_W (FD (inst), (int32)val); /* Casting truncates */
		break;
	      }

	    case Y_TRUNC_W_S_OP:
	      {
		double val = (double)FPR_S (FS (inst));

		SET_FPR_W (FD (inst), (int32)val); /* Casting truncates */
		break;
	      }

	    default:
	      fatal_error ("Unknown instruction type: %d\n", OPCODE (inst));
	      break;
	    }

	  /* After instruction executes: */
	  PC += BYTES_PER_WORD;

	  if (exception_occurred)
	    {
	      handle_exception ();
	    }
	}			/* End: for (step = 0; ... */
    }				/* End: for ( ; steps_to_run > 0 ... */

  /* Executed enought steps, return, but are able to continue. */
  return (1);
}


#ifdef WIN32
static void CALLBACK
timer_completion_routine(LPVOID lpArgToCompletionRoutine, DWORD dwTimerLowValue, DWORD dwTimerHighValue)
{
  bump_CP0_timer ();
}
#endif


/* Increment CP0 Count register and test if it matches the Compare
   register. If so, cause an interrupt. */

static void
bump_CP0_timer ()
{
  CP0_Count += 1;
  if (CP0_Count == CP0_Compare)
    {
      RAISE_INTERRUPT (7);
    }
}


static void
start_CP0_timer ()
{
#ifdef WIN32
  HANDLE timer = CreateWaitableTimer(NULL, TRUE, "SPIMTimer");
  if (NULL == timer)
    {
      error ("CreateWaitableTimer failed");
    }
  else
    {
      LARGE_INTEGER interval;
      interval.QuadPart = -10000 * TIMER_TICK_MS;  /* Unit is 100 nsec */

      if (!SetWaitableTimer (timer, &interval, 1, timer_completion_routine, 0, FALSE))
	{
	  error ("SetWaitableTimer failed");
	}
    }
#else
  /* Should use ITIMER_VIRTUAL delivering SIGVTALRM, but that does not seem
     to work under Cygwin, so we'll adopt the lowest common denominator.

     We ignore these signals, however, and read the timer with getitimer,
     since signals interrupt I/O calls, such as read, and make user
     interaction with SPIM work very poorly. Since speed isn't an important
     aspect of SPIM, polling isn't a big deal. */
  if (-1 == (int)signal (SIGALRM, SIG_IGN))
    {
      perror ("signal failed");
    }
  else
    {
      /* Start a non-periodic timer for TIMER_TICK_MS microseconds. */
      struct itimerval time;
      time.it_interval.tv_sec = 0;
      time.it_interval.tv_usec = 0;
      time.it_value.tv_sec = 0;
      time.it_value.tv_usec = TIMER_TICK_MS * 1000;
      if (-1 == setitimer (ITIMER_REAL, &time, NULL))
	{
	  perror ("setitmer failed");
	}
    }
#endif
}


/* Multiply two 32-bit numbers, V1 and V2, to produce a 64 bit result in
   the HI/LO registers.	 The algorithm is high-school math:

	 A B
       x C D
       ------
       AD || BD
 AC || CB || 0

 where A and B are the high and low short words of V1, C and D are the short
 words of V2, AD is the product of A and D, and X || Y is (X << 16) + Y.
 Since the algorithm is programmed in C, we need to be careful not to
 overflow. */

static void
unsigned_multiply (reg_word v1, reg_word v2)
{
  u_reg_word a, b, c, d;
  u_reg_word bd, ad, cb, ac;
  u_reg_word mid, mid2, carry_mid = 0;

  a = (v1 >> 16) & 0xffff;
  b = v1 & 0xffff;
  c = (v2 >> 16) & 0xffff;
  d = v2 & 0xffff;

  bd = b * d;
  ad = a * d;
  cb = c * b;
  ac = a * c;

  mid = ad + cb;
  if (mid < ad || mid < cb)
    /* Arithmetic overflow or carry-out */
    carry_mid = 1;

  mid2 = mid + ((bd >> 16) & 0xffff);
  if (mid2 < mid || mid2 < ((bd >> 16) & 0xffff))
    /* Arithmetic overflow or carry-out */
    carry_mid += 1;

  LO = (bd & 0xffff) | ((mid2 & 0xffff) << 16);
  HI = ac + (carry_mid << 16) + ((mid2 >> 16) & 0xffff);
}


static void
signed_multiply (reg_word v1, reg_word v2)
{
  int neg_sign = 0;

  if (v1 < 0)
    {
      v1 = - v1;
      neg_sign = 1;
    }
  if (v2 < 0)
    {
      v2 = - v2;
      neg_sign = ! neg_sign;
    }

  unsigned_multiply (v1, v2);
  if (neg_sign)
    {
      LO = ~ LO;
      HI = ~ HI;
      LO += 1;
      if (LO == 0)
	HI += 1;
    }
}

static void
set_fpu_cc (int cond, int cc, int less, int equal, int unordered)
{
  int result;
  int fcsr_bit;

  result = 0;
  if (cond & COND_LT) result |= less;
  if (cond & COND_EQ) result |= equal;
  if (cond & COND_UN) result |= unordered;

  FCCR = (FCCR & ~(1 << cc)) | (result << cc);
  if (0 == cc)
    {
      fcsr_bit = 23;
    }
  else
    {
      fcsr_bit = 24 + cc;
    }
  FCSR = (FCSR & ~(1 << fcsr_bit)) | (result << fcsr_bit);
}


void
raise_exception (int excode)
{
  if (ExcCode_Int != excode
      || ((CP0_Status & CP0_Status_IE) /* Allow interrupt if IE and !EXL */
	  && !(CP0_Status & CP0_Status_EXL)))
    {
      /* Ignore interrupt exception when interrupts disabled.  */
      exception_occurred = 1;
      if (running_in_delay_slot)
	{
	  /* In delay slot */
	  if ((CP0_Status & CP0_Status_EXL) == 0)
	    {
	      /* Branch's addr */
	      CP0_EPC = ROUND_DOWN (PC - BYTES_PER_WORD, BYTES_PER_WORD);
	      /* Set BD bit to record that instruction is in delay slot */
	      CP0_Cause |= CP0_Cause_BD;
	    }
	}
      else
	{
	  /* Not in delay slot */
	  if ((CP0_Status & CP0_Status_EXL) == 0)
	    {
	      /* Faulting instruction's address */
	      CP0_EPC = ROUND_DOWN (PC, BYTES_PER_WORD);
	    }
	}
      /* ToDo: set CE field of Cause register to coprocessor causing exception */

      /* Record cause of exception */
      CP0_Cause = (CP0_Cause & ~CP0_Cause_ExcCode) | (excode << 2);

      /* Turn on EXL bit to prevent subsequent interrupts from affecting EPC */
      CP0_Status |= CP0_Status_EXL;

#ifdef MIPS1
      CP0_Status = (CP0_Status & 0xffffffc0) | ((CP0_Status & 0xf) << 2);
#endif
    }
}
/* SPIM S20 MIPS simulator.
   Execute SPIM instructions.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/run.h 5     2/15/04 1:27p Larus $
*/


/* Exported functions: */

int run_spim (mem_addr initial_PC, register int steps, int display);
/* SPIM S20 MIPS simulator.
   Interface to lexical scanner.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/scanner.h 7     2/23/04 4:42a Larus $
*/


/* Exported functions (besides yylex): */

void initialize_scanner (FILE *in_file);
void print_erroneous_line ();
void scanner_start_line ();
int register_name_to_number (char *name);
char *source_line ();
int yylex ();

/* Exported Variables: */

/* This flag tells the scanner to treat the next sequence of letters
   etc as an identifier and not look it up as an opcode. It permits us
   to use opcodes as symbols in most places.  However, because of the
   LALR(1) lookahead, it does not work for labels. */

extern int only_id;

typedef intptr_union yylval_t;
#define YYSTYPE yylval_t
extern YYSTYPE yylval;		/* Value of token from YYLEX */

extern int line_no;		/* Line number in input file*/
%{
/* SPIM S20 MIPS simulator.
   Lexical scanner.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: $
*/


#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "sym-tbl.h"
#include "parser.h"
#include "scanner.h"
#include "y.tab.h"

#ifndef YY_CHAR
#define YY_CHAR char
#endif
#define YY_NO_UNISTD_H

/* Exported Variables: */

int only_id;
int line_no;		/* Line number in input file*/


/* Local Variables: */

/* Track which line we are reading and where it began in the buffer. */
static int current_line_no = 0;

static YY_CHAR *current_line = NULL;


static double scan_float;	/* Where FP values are kept */

static int line_returned = 0;	/* Returned current line yet? */

static int eof_returned = 0;	/* Return EOF token yet? */


/* Local functions: */

static int check_keyword (YY_CHAR *id, int allow_pseudo_ops);
static YY_CHAR *copy_str (YY_CHAR *str, int chop);
static YY_CHAR scan_escape (YY_CHAR **str);


#undef yywrap

%}

%%

[ \t]		       {
		        if (current_line == NULL)
			  {
			    current_line_no = line_no;
			    current_line = yytext;
			  }
		       }


[\n]			{
			 line_no += 1;
			 return (Y_NL);
			}

[\r]			{ /* Ignore carrage returns */ }

[;]			{
			 return (Y_NL);
			}


[\001]		{	/* Marker character inserted to allow scanner to
				   return Y_EOF before returning hard EOF. */
			  return (Y_EOF);
			}

"#@"			{
				/* CS296: The special form of a comment "#@" should not be ignored */
				return (Y_MACRO_START);
			}

("#"[^@\n].*)|("#\n")
			{
			/* CS296: A comment is anything that starts with a '#' character such that 
			 * the next character is not '@'. Comments are ignored so we do nothing here.
 			 */
			}

"=="			{
				/* CS296: The skeleton code only implements the '==' assertion so 
				 * we need this token.
				 */
				return (Y_EQ_MACRO);
			}

"!="        {
                return (Y_NEQ_MACRO);
            }

(-[0-9]+)|([0-9]+)	{
			 if (current_line == NULL)
			   {
			     current_line_no = line_no;
			     current_line = yytext;
			   }
			 yylval.i = atoi (yytext);
			 return (Y_INT);
			}


((0x)|(-0x))[0-9A-Fa-f]+ {
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  if (*yytext == '-')
			    {
			      sscanf(yytext+3, "%x", &(yylval.i));
			      yylval.i = -yylval.i;
			    }
			  else
			    {
			      sscanf(yytext+2, "%x", &(yylval.i));
			    }
			  return (Y_INT);
			}


(\+|\-)?[0-9]+\.[0-9]*(e)?(\+|\-)?[0-9]* {
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  scan_float = atof (yytext);
			  yylval.p = (double*) &scan_float;
			  return (Y_FP);
			}


[a-zA-Z_\.][a-zA-Z0-9_\.]* {
			  int token = check_keyword (yytext,
						     !bare_machine
						     && accept_pseudo_insts);
			  label *l;

			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }

			  if (!only_id && token != 0)
			    {
			      /* Keyword */
			      yylval.i = token;
			      current_line = yytext;
			      return (token);
			    }

			  if (only_id && token != 0)
			    yyerror ("Cannot use opcodes as labels");

			  if ((l = label_is_defined (yytext)) != NULL
			      && l->const_flag)
			    {
			      /* Defined label */
			      yylval.i = (int) l->addr;
			      return (Y_INT);
			    }
			  else
			    {
			      /* Not-yet defined label */
			      yylval.p = (char*) str_copy (yytext);
			      return (Y_ID);
			    }
			}


\$[a-zA-Z0-9_\.$]+	{
			  int reg_no = register_name_to_number (yytext + 1);

			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }

			  if (reg_no != -1
			      && *(yytext + 1) == 'f'
			      && *(yytext + 2) != 'p')
			    {
			      /* Floating point register ($f0) */
			      yylval.i = reg_no;
			      return (Y_FP_REG);
			    }

			  if (0 <= reg_no && reg_no < R_LENGTH)
			    {
			      /* Register ($r0) */
			      yylval.i = reg_no;
			      return (Y_REG);
			    }
			  else
			    {
			      /* Otherwise, an integer or identifier */
			      label *l = label_is_defined (yytext);

			      if (l != NULL && l->const_flag)
				{
				  yylval.i = (int) l->addr;
				  return (Y_INT);
				}
			      else
				{
				  yylval.p = (char*) str_copy (yytext);
				  return (Y_ID);
				}
			    }
			}


[:()+-]|">"|"="		{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  return (*yytext);
			}


","			{
			 if (current_line == NULL)
			   {
			     current_line_no = line_no;
			     current_line = yytext;
			   }
			 /* Skip commas */
		        }

"?"			{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  yylval.p = (char*) str_copy (yytext);
			  /* For top level */
			  return (Y_ID);
			}


\"(([^""])|(\\\"))*\"	{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  yylval.p = (char*) copy_str (yytext + 1, 1);
			  return (Y_STR);
			}

\'(([^''])|(\\[^'']))\'	{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }

			    if (*(yytext + 1) == '\\')
			      {
				YY_CHAR *escape = yytext + 1;
				yylval.i = (int) scan_escape (&escape);
			      }
			    else
			      {
				yylval.i = (int) *(yytext + 1);
				return (Y_INT);
			      }
			}

.			{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  yyerror ("Unknown character");
			}


%%



void
initialize_scanner (FILE *in_file)
{
  yyin = in_file;
#ifdef FLEX_SCANNER
  yyrestart(in_file);
#if (YY_FLEX_MAJOR_VERSION==2 && YY_FLEX_MINOR_VERSION==5 && YY_FLEX_SUBMINOR_VERSION>=33)
  /* flex 2.5.33 flipped the polarity of this flag (sigh) */
  yy_init = 0;
#else
  yy_init = 1;
#endif
#endif
  line_no = 1;
  current_line = NULL;
  line_returned = 0;
  eof_returned = 0;
}


void
scanner_start_line ()
{
  current_line = NULL;
  line_returned = 0;
}


/* This is a work-around for a bug in flex v 2.5.31 (but not earlier or
   later versions such as 2.5.4) that left this symbol undefined. */

#ifndef yytext_ptr
#define yytext_ptr yytext
#endif


/* Use yywrap to insert a marker character, which causes the
   scanner to return Y_EOF, before return a hard EOF.  This
   wouldn't be necessary, except that bison does not allow
   the parser to use EOF (= 0) as a non-terminal */

int yywrap()
{
	if (eof_returned)
		return (1);
	else
	{
		unput ('\001');
		eof_returned = 1;
#ifdef FLEX_SCANNER
		yy_did_buffer_switch_on_eof = 1;
#endif
		return (0);
	}
}


/* A backslash has just been read, return the character designated by *STR.  */

static YY_CHAR
scan_escape (YY_CHAR **str)
{
  YY_CHAR first = **str;
  *str += 1;
  switch (first)
    {
    case 'a': return '\a';
    case 'b': return '\b';
    case 'f': return '\f';
    case 'n': return '\n';
    case 'r': return '\r';
    case 't': return '\t';
    case '\\': return '\\';
    case '"': return '"';
    case '\'': return '\'';

    case 'x':
    case 'X':
      {
	YY_CHAR c1 = **str, c2 = *(*str + 1);
	int b = 0;

	if ('0' <= c1 && c1 <= '9') b = c1 - '0';
	else if ('A' <= c1 && c1 <= 'F') b = c1 - 'A' + 10;
	else if ('a' <= c1 && c1 <= 'f') b = c1 - 'a' + 10;
	else yyerror ("Bad character in \\X construct in string");

	b <<= 4;
	if ('0' <= c2 && c2 <= '9') b += c2 - '0';
	else if ('A' <= c2 && c2 <= 'F') b += c2 - 'A' + 10;
	else if ('a' <= c2 && c2 <= 'f') b += c2 - 'a' + 10;
	else yyerror ("Bad character in \\X construct in string");

	*str += 2;
	return (YY_CHAR) b;
      }

    default:
      {
	char message[] = "Bad character \\X";
	message[strlen (message) - 1] = first;
	yyerror (message);
	return '\0';
      }
    }
}


/* Return a freshly-allocated copy of STRING with the last CHOP
   characters removed. */

static YY_CHAR *
copy_str (YY_CHAR *str, int chop)
{
  int new_len = strlen (str) - chop;
  YY_CHAR *new_str = (YY_CHAR *) xmalloc (new_len + 1), *n;

  for (n = new_str; *str != '\0' && new_len > 0; new_len -= 1)
    if (*str == '\\')
      switch (*(str + 1))
	{
	case 'n':
	  {
	    *n ++ = '\n';
	    str += 2;
	    new_len -= 1;
	    continue;
	  }
	case 't':
	  {
	    *n ++ = '\t';
	    str += 2;
	    new_len -= 1;
	    continue;
	  }
	case '"':
	  {
	    *n ++ = '"';
	    str += 2;
	    new_len -= 1;
	    continue;
	  }
	case '0':		/* \nnn */
	case '1':
	case '2':
	case '3':
	  {
	    YY_CHAR c2 = *(str + 2), c3 = *(str + 3);
	    int b = (*(str + 1) - '0') << 3;

	    if ('0' <= c2 && c2 <= '7')
	      b = (c2 - '0') << 3;
	    else
	      yyerror ("Bad character in \\ooo construct in string");

	    if ('0' <= c3 && c3 <= '7')
	      b += c3 - '0';
	    else
	      yyerror ("Bad character in \\ooo construct in string");

	    *n ++ = (YY_CHAR) b;
	    str += 4;
	    new_len -= 3;
	    continue;
	  }
	case 'X':
	  {
	    YY_CHAR c2 = *(str + 2), c3 = *(str + 3);
	    int b = 0;

	    if ('0' <= c2 && c2 <= '9')
	      b = c2 - '0';
	    else if ('A' <= c2 && c2 <= 'F')
	      b = c2 - 'A' + 10;
	    else
	      yyerror ("Bad character in \\X construct in string");

	    b <<= 4;
	    if ('0' <= c3 && c3 <= '9')
	      b += c3 - '0';
	    else if ('A' <= c3 && c3 <= 'F')
	      b += c3 - 'A' + 10;
	    else
	      yyerror ("Bad character in \\X construct in string");

	    *n ++ = (YY_CHAR) b;
	    str += 4;
	    new_len -= 3;
	    continue;
	  }
	default:
	  {
	    *n ++ = *str ++;
	    continue;
	  }
	}
    else
      *n ++ = *str ++;

  *n = '\0';
  return (new_str);
}


/* On a parse error, write out the current line and print a caret (^)
   below the point at which the error occured.	Also, reset the input
   stream to the begining of the next line. */

void
print_erroneous_line ()
{
  int prefix_length = yytext - current_line;
  int i, c;
  YY_CHAR buffer[1024], *bp = buffer;

  if (current_line == NULL) return;

  /* Print part of line that has been consumed. */
  if (0 <= prefix_length)
    {
      /* yytext and current_line point to same line */
      error ("	  ");
      c = *(current_line + prefix_length);
      *(current_line + prefix_length) = '\0';
      error ("%s", current_line);
      *(current_line + prefix_length) = (char)c;
      error ("%s", yytext);
    }
  else
    {
      /* yytext and current_line point to different lines */
      error ("	  ");
      error ("%s", current_line);
      prefix_length = strlen(current_line);
    }

  /* Flush the rest of the line (not consumed) from lex input. */
  if (*yytext != '\n')
    {
      while ((c = input ()) != '\n' && c != EOF && c != 1)
	*bp ++ = (char)c;
      *bp = '\0';
      error ("%s\n", buffer);
      if (c == '\n') unput ('\n');
      current_line = NULL;
    }

  /* Print marker to point at which consumption stopped. */
  if (1024 <= prefix_length) return;
  error ("	  ");
  for (i = 0; i < prefix_length; i ++) buffer[i] = ' ';
  buffer[i] = '\0';
  error ("%s^\n", buffer);
}


static name_val_val keyword_tbl [] = {
#undef OP
#define OP(NAME, OPCODE, TYPE, R_OPCODE) {NAME, OPCODE, TYPE},
#include "op.h"
};


static int
check_keyword (YY_CHAR *id, int allow_pseudo_ops)
{
  name_val_val *entry =
    map_string_to_name_val_val (keyword_tbl,
			     sizeof(keyword_tbl) / sizeof (name_val_val),
			     id);
  if (entry == NULL)
    return (0);
  else if (!allow_pseudo_ops && entry->value2 == PSEUDO_OP)
    return (0);
  else
    return (entry->value1);
}


static name_val_val register_tbl [] = {
  {"a0", 4, 0},
  {"a1", 5, 0},
  {"a2", 6, 0},
  {"a3", 7, 0},
  {"at", 1, 0},
  {"fp", 30, 0},
  {"gp", 28, 0},
  {"k0", 26, 0},
  {"k1", 27, 0},
  {"kt0", 26, 0},
  {"kt1", 27, 0},
  {"ra", 31, 0},
  {"s0", 16, 0},
  {"s1", 17, 0},
  {"s2", 18, 0},
  {"s3", 19, 0},
  {"s4", 20, 0},
  {"s5", 21, 0},
  {"s6", 22, 0},
  {"s7", 23, 0},
  {"s8", 30, 0},
  {"sp", 29, 0},
  {"t0", 8, 0},
  {"t1", 9, 0},
  {"t2", 10, 0},
  {"t3", 11, 0},
  {"t4", 12, 0},
  {"t5", 13, 0},
  {"t6", 14, 0},
  {"t7", 15, 0},
  {"t8", 24, 0},
  {"t9", 25, 0},
  {"v0", 2, 0},
  {"v1", 3, 0},
  {"zero", 0, 0}
};

int
register_name_to_number (char *name)
{
  int c1 = *name, c2 = *(name + 1);

  if ('0' <= c1 && c1 <= '9'
      && (c2 == '\0' || (('0' <= c2 && c2 <= '9') && *(name + 2) == '\0')))
    return (atoi (name));
  else if (c1 == 'f' && c2 >= '0' && c2 <= '9')
    return atoi (name + 1);
  else
    {
      name_val_val *entry =
	map_string_to_name_val_val (register_tbl,
				 sizeof (register_tbl) / sizeof (name_val_val),
				 name);
      if (entry == NULL)
	return (-1);
      else
	return (entry->value1);
    }
}


/* Exactly once, return the current source line, as a printable string
   with a line number.  Subsequent calls receive NULL instead of the
   line. */

char *
source_line ()
{
  if (line_returned)
    return (NULL);
  else if (current_line == NULL)	/* Error on line */
    return (NULL);
  else
    {
      YY_CHAR *eol1, c1;
      YY_CHAR *null1 = NULL;
      char *r;

      /* Find end of line: */
      for (eol1 = current_line; *eol1 != '\0' && *eol1 != '\n'; ) eol1 += 1;

#ifdef FLEX_SCANNER
      /* Ran into null byte, inserted by yylex. In necessary, look further
	 for newline. (This only works for scanners produced by flex. Other
         versions of lex need similar code, or source code lines will end
         early. */
      if (*eol1 == '\0' && yy_hold_char != '\n')
	{
	  null1 = eol1;
	  *eol1 = yy_hold_char;
	  for ( ; *eol1 != '\0' && *eol1 != '\n'; )
	    eol1 += 1;
	}
#endif

      /* Save end-of-line character and null terminate string so it can
	 be printed. */
      c1 = *eol1;
      *eol1 = '\0';

      r = (char *) xmalloc (eol1 - current_line + 10);
      sprintf (r, "%d: %s", current_line_no, current_line);

      /* Restore end-of-line character and, if necessary, yylex's null byte. */
      *eol1 = c1;
      if (null1 != NULL)
	{
	  *null1 = '\0';
	}
      line_returned = 1;
      return ((char *) r);
    }
}
%{
/* SPIM S20 MIPS simulator.
   Lexical scanner.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: $
*/


#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "sym-tbl.h"
#include "parser.h"
#include "scanner.h"
#include "y.tab.h"

#ifndef YY_CHAR
#define YY_CHAR char
#endif
#define YY_NO_UNISTD_H

/* Exported Variables: */

int only_id;
int line_no;		/* Line number in input file*/


/* Local Variables: */

/* Track which line we are reading and where it began in the buffer. */
static int current_line_no = 0;

static YY_CHAR *current_line = NULL;


static double scan_float;	/* Where FP values are kept */

static int line_returned = 0;	/* Returned current line yet? */

static int eof_returned = 0;	/* Return EOF token yet? */


/* Local functions: */

static int check_keyword (YY_CHAR *id, int allow_pseudo_ops);
static YY_CHAR *copy_str (YY_CHAR *str, int chop);
static YY_CHAR scan_escape (YY_CHAR **str);


#undef yywrap

%}

%%

[ \t]		       {
		        if (current_line == NULL)
			  {
			    current_line_no = line_no;
			    current_line = yytext;
			  }
		       }


[\n]			{
			 line_no += 1;
			 return (Y_NL);
			}

[\r]			{ /* Ignore carrage returns */ }

[;]			{
			 return (Y_NL);
			}


[\001]		{	/* Marker character inserted to allow scanner to
				   return Y_EOF before returning hard EOF. */
			  return (Y_EOF);
			}

"#@"			{
				/* CS296: The special form of a comment "#@" should not be ignored */
				return (Y_MACRO_START);
			}

("#"[^@\n].*)|("#\n")
			{
			/* CS296: A comment is anything that starts with a '#' character such that 
			 * the next character is not '@'. Comments are ignored so we do nothing here.
 			 */
			}

(-[0-9]+)|([0-9]+)	{
			 if (current_line == NULL)
			   {
			     current_line_no = line_no;
			     current_line = yytext;
			   }
			 yylval.i = atoi (yytext);
			 return (Y_INT);
			}


((0x)|(-0x))[0-9A-Fa-f]+ {
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  if (*yytext == '-')
			    {
			      sscanf(yytext+3, "%x", &(yylval.i));
			      yylval.i = -yylval.i;
			    }
			  else
			    {
			      sscanf(yytext+2, "%x", &(yylval.i));
			    }
			  return (Y_INT);
			}


(\+|\-)?[0-9]+\.[0-9]*(e)?(\+|\-)?[0-9]* {
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  scan_float = atof (yytext);
			  yylval.p = (double*) &scan_float;
			  return (Y_FP);
			}


[a-zA-Z_\.][a-zA-Z0-9_\.]* {
			  int token = check_keyword (yytext,
						     !bare_machine
						     && accept_pseudo_insts);
			  label *l;

			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }

			  if (!only_id && token != 0)
			    {
			      /* Keyword */
			      yylval.i = token;
			      current_line = yytext;
			      return (token);
			    }

			  if (only_id && token != 0)
			    yyerror ("Cannot use opcodes as labels");

			  if ((l = label_is_defined (yytext)) != NULL
			      && l->const_flag)
			    {
			      /* Defined label */
			      yylval.i = (int) l->addr;
			      return (Y_INT);
			    }
			  else
			    {
			      /* Not-yet defined label */
			      yylval.p = (char*) str_copy (yytext);
			      return (Y_ID);
			    }
			}


\$[a-zA-Z0-9_\.$]+	{
			  int reg_no = register_name_to_number (yytext + 1);

			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }

			  if (reg_no != -1
			      && *(yytext + 1) == 'f'
			      && *(yytext + 2) != 'p')
			    {
			      /* Floating point register ($f0) */
			      yylval.i = reg_no;
			      return (Y_FP_REG);
			    }

			  if (0 <= reg_no && reg_no < R_LENGTH)
			    {
			      /* Register ($r0) */
			      yylval.i = reg_no;
			      return (Y_REG);
			    }
			  else
			    {
			      /* Otherwise, an integer or identifier */
			      label *l = label_is_defined (yytext);

			      if (l != NULL && l->const_flag)
				{
				  yylval.i = (int) l->addr;
				  return (Y_INT);
				}
			      else
				{
				  yylval.p = (char*) str_copy (yytext);
				  return (Y_ID);
				}
			    }
			}


[:()+-]|">"|"="		{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  return (*yytext);
			}


","			{
			 if (current_line == NULL)
			   {
			     current_line_no = line_no;
			     current_line = yytext;
			   }
			 /* Skip commas */
		        }

"?"			{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  yylval.p = (char*) str_copy (yytext);
			  /* For top level */
			  return (Y_ID);
			}


\"(([^""])|(\\\"))*\"	{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  yylval.p = (char*) copy_str (yytext + 1, 1);
			  return (Y_STR);
			}

\'(([^''])|(\\[^'']))\'	{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }

			    if (*(yytext + 1) == '\\')
			      {
				YY_CHAR *escape = yytext + 1;
				yylval.i = (int) scan_escape (&escape);
			      }
			    else
			      {
				yylval.i = (int) *(yytext + 1);
				return (Y_INT);
			      }
			}

.			{
			  if (current_line == NULL)
			    {
			      current_line_no = line_no;
			      current_line = yytext;
			    }
			  yyerror ("Unknown character");
			}


%%



void
initialize_scanner (FILE *in_file)
{
  yyin = in_file;
#ifdef FLEX_SCANNER
  yyrestart(in_file);
#if (YY_FLEX_MAJOR_VERSION==2 && YY_FLEX_MINOR_VERSION==5 && YY_FLEX_SUBMINOR_VERSION>=33)
  /* flex 2.5.33 flipped the polarity of this flag (sigh) */
  yy_init = 0;
#else
  yy_init = 1;
#endif
#endif
  line_no = 1;
  current_line = NULL;
  line_returned = 0;
  eof_returned = 0;
}


void
scanner_start_line ()
{
  current_line = NULL;
  line_returned = 0;
}


/* This is a work-around for a bug in flex v 2.5.31 (but not earlier or
   later versions such as 2.5.4) that left this symbol undefined. */

#ifndef yytext_ptr
#define yytext_ptr yytext
#endif


/* Use yywrap to insert a marker character, which causes the
   scanner to return Y_EOF, before return a hard EOF.  This
   wouldn't be necessary, except that bison does not allow
   the parser to use EOF (= 0) as a non-terminal */

int yywrap()
{
	if (eof_returned)
		return (1);
	else
	{
		unput ('\001');
		eof_returned = 1;
#ifdef FLEX_SCANNER
		yy_did_buffer_switch_on_eof = 1;
#endif
		return (0);
	}
}


/* A backslash has just been read, return the character designated by *STR.  */

static YY_CHAR
scan_escape (YY_CHAR **str)
{
  YY_CHAR first = **str;
  *str += 1;
  switch (first)
    {
    case 'a': return '\a';
    case 'b': return '\b';
    case 'f': return '\f';
    case 'n': return '\n';
    case 'r': return '\r';
    case 't': return '\t';
    case '\\': return '\\';
    case '"': return '"';
    case '\'': return '\'';

    case 'x':
    case 'X':
      {
	YY_CHAR c1 = **str, c2 = *(*str + 1);
	int b = 0;

	if ('0' <= c1 && c1 <= '9') b = c1 - '0';
	else if ('A' <= c1 && c1 <= 'F') b = c1 - 'A' + 10;
	else if ('a' <= c1 && c1 <= 'f') b = c1 - 'a' + 10;
	else yyerror ("Bad character in \\X construct in string");

	b <<= 4;
	if ('0' <= c2 && c2 <= '9') b += c2 - '0';
	else if ('A' <= c2 && c2 <= 'F') b += c2 - 'A' + 10;
	else if ('a' <= c2 && c2 <= 'f') b += c2 - 'a' + 10;
	else yyerror ("Bad character in \\X construct in string");

	*str += 2;
	return (YY_CHAR) b;
      }

    default:
      {
	char message[] = "Bad character \\X";
	message[strlen (message) - 1] = first;
	yyerror (message);
	return '\0';
      }
    }
}


/* Return a freshly-allocated copy of STRING with the last CHOP
   characters removed. */

static YY_CHAR *
copy_str (YY_CHAR *str, int chop)
{
  int new_len = strlen (str) - chop;
  YY_CHAR *new_str = (YY_CHAR *) xmalloc (new_len + 1), *n;

  for (n = new_str; *str != '\0' && new_len > 0; new_len -= 1)
    if (*str == '\\')
      switch (*(str + 1))
	{
	case 'n':
	  {
	    *n ++ = '\n';
	    str += 2;
	    new_len -= 1;
	    continue;
	  }
	case 't':
	  {
	    *n ++ = '\t';
	    str += 2;
	    new_len -= 1;
	    continue;
	  }
	case '"':
	  {
	    *n ++ = '"';
	    str += 2;
	    new_len -= 1;
	    continue;
	  }
	case '0':		/* \nnn */
	case '1':
	case '2':
	case '3':
	  {
	    YY_CHAR c2 = *(str + 2), c3 = *(str + 3);
	    int b = (*(str + 1) - '0') << 3;

	    if ('0' <= c2 && c2 <= '7')
	      b = (c2 - '0') << 3;
	    else
	      yyerror ("Bad character in \\ooo construct in string");

	    if ('0' <= c3 && c3 <= '7')
	      b += c3 - '0';
	    else
	      yyerror ("Bad character in \\ooo construct in string");

	    *n ++ = (YY_CHAR) b;
	    str += 4;
	    new_len -= 3;
	    continue;
	  }
	case 'X':
	  {
	    YY_CHAR c2 = *(str + 2), c3 = *(str + 3);
	    int b = 0;

	    if ('0' <= c2 && c2 <= '9')
	      b = c2 - '0';
	    else if ('A' <= c2 && c2 <= 'F')
	      b = c2 - 'A' + 10;
	    else
	      yyerror ("Bad character in \\X construct in string");

	    b <<= 4;
	    if ('0' <= c3 && c3 <= '9')
	      b += c3 - '0';
	    else if ('A' <= c3 && c3 <= 'F')
	      b += c3 - 'A' + 10;
	    else
	      yyerror ("Bad character in \\X construct in string");

	    *n ++ = (YY_CHAR) b;
	    str += 4;
	    new_len -= 3;
	    continue;
	  }
	default:
	  {
	    *n ++ = *str ++;
	    continue;
	  }
	}
    else
      *n ++ = *str ++;

  *n = '\0';
  return (new_str);
}


/* On a parse error, write out the current line and print a caret (^)
   below the point at which the error occured.	Also, reset the input
   stream to the begining of the next line. */

void
print_erroneous_line ()
{
  int prefix_length = yytext - current_line;
  int i, c;
  YY_CHAR buffer[1024], *bp = buffer;

  if (current_line == NULL) return;

  /* Print part of line that has been consumed. */
  if (0 <= prefix_length)
    {
      /* yytext and current_line point to same line */
      error ("	  ");
      c = *(current_line + prefix_length);
      *(current_line + prefix_length) = '\0';
      error ("%s", current_line);
      *(current_line + prefix_length) = (char)c;
      error ("%s", yytext);
    }
  else
    {
      /* yytext and current_line point to different lines */
      error ("	  ");
      error ("%s", current_line);
      prefix_length = strlen(current_line);
    }

  /* Flush the rest of the line (not consumed) from lex input. */
  if (*yytext != '\n')
    {
      while ((c = input ()) != '\n' && c != EOF && c != 1)
	*bp ++ = (char)c;
      *bp = '\0';
      error ("%s\n", buffer);
      if (c == '\n') unput ('\n');
      current_line = NULL;
    }

  /* Print marker to point at which consumption stopped. */
  if (1024 <= prefix_length) return;
  error ("	  ");
  for (i = 0; i < prefix_length; i ++) buffer[i] = ' ';
  buffer[i] = '\0';
  error ("%s^\n", buffer);
}


static name_val_val keyword_tbl [] = {
#undef OP
#define OP(NAME, OPCODE, TYPE, R_OPCODE) {NAME, OPCODE, TYPE},
#include "op.h"
};


static int
check_keyword (YY_CHAR *id, int allow_pseudo_ops)
{
  name_val_val *entry =
    map_string_to_name_val_val (keyword_tbl,
			     sizeof(keyword_tbl) / sizeof (name_val_val),
			     id);
  if (entry == NULL)
    return (0);
  else if (!allow_pseudo_ops && entry->value2 == PSEUDO_OP)
    return (0);
  else
    return (entry->value1);
}


static name_val_val register_tbl [] = {
  {"a0", 4, 0},
  {"a1", 5, 0},
  {"a2", 6, 0},
  {"a3", 7, 0},
  {"at", 1, 0},
  {"fp", 30, 0},
  {"gp", 28, 0},
  {"k0", 26, 0},
  {"k1", 27, 0},
  {"kt0", 26, 0},
  {"kt1", 27, 0},
  {"ra", 31, 0},
  {"s0", 16, 0},
  {"s1", 17, 0},
  {"s2", 18, 0},
  {"s3", 19, 0},
  {"s4", 20, 0},
  {"s5", 21, 0},
  {"s6", 22, 0},
  {"s7", 23, 0},
  {"s8", 30, 0},
  {"sp", 29, 0},
  {"t0", 8, 0},
  {"t1", 9, 0},
  {"t2", 10, 0},
  {"t3", 11, 0},
  {"t4", 12, 0},
  {"t5", 13, 0},
  {"t6", 14, 0},
  {"t7", 15, 0},
  {"t8", 24, 0},
  {"t9", 25, 0},
  {"v0", 2, 0},
  {"v1", 3, 0},
  {"zero", 0, 0}
};

int
register_name_to_number (char *name)
{
  int c1 = *name, c2 = *(name + 1);

  if ('0' <= c1 && c1 <= '9'
      && (c2 == '\0' || (('0' <= c2 && c2 <= '9') && *(name + 2) == '\0')))
    return (atoi (name));
  else if (c1 == 'f' && c2 >= '0' && c2 <= '9')
    return atoi (name + 1);
  else
    {
      name_val_val *entry =
	map_string_to_name_val_val (register_tbl,
				 sizeof (register_tbl) / sizeof (name_val_val),
				 name);
      if (entry == NULL)
	return (-1);
      else
	return (entry->value1);
    }
}


/* Exactly once, return the current source line, as a printable string
   with a line number.  Subsequent calls receive NULL instead of the
   line. */

char *
source_line ()
{
  if (line_returned)
    return (NULL);
  else if (current_line == NULL)	/* Error on line */
    return (NULL);
  else
    {
      YY_CHAR *eol1, c1;
      YY_CHAR *null1 = NULL;
      char *r;

      /* Find end of line: */
      for (eol1 = current_line; *eol1 != '\0' && *eol1 != '\n'; ) eol1 += 1;

#ifdef FLEX_SCANNER
      /* Ran into null byte, inserted by yylex. In necessary, look further
	 for newline. (This only works for scanners produced by flex. Other
         versions of lex need similar code, or source code lines will end
         early. */
      if (*eol1 == '\0' && yy_hold_char != '\n')
	{
	  null1 = eol1;
	  *eol1 = yy_hold_char;
	  for ( ; *eol1 != '\0' && *eol1 != '\n'; )
	    eol1 += 1;
	}
#endif

      /* Save end-of-line character and null terminate string so it can
	 be printed. */
      c1 = *eol1;
      *eol1 = '\0';

      r = (char *) xmalloc (eol1 - current_line + 10);
      sprintf (r, "%d: %s", current_line_no, current_line);

      /* Restore end-of-line character and, if necessary, yylex's null byte. */
      *eol1 = c1;
      if (null1 != NULL)
	{
	  *null1 = '\0';
	}
      line_returned = 1;
      return ((char *) r);
    }
}
/* SPIM S20 MIPS simulator.
   Definitions for the SPIM S20.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.
   Changes for DOS and Windows versions by David A. Carley (dac@cs.wisc.edu)

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/spim.h 21    3/21/04 11:18a Larus $
*/


#ifndef NULL
#define NULL 0
#endif


/* Type declarations for portability.  They work for DEC's Alpha (64 bits)
   and 32 bit machines */

typedef int int32;
typedef unsigned int  uint32;
typedef union {int i; void* p;} intptr_union;


#define streq(s1, s2) !strcmp(s1, s2)


/* Round V to next greatest B boundary */
#define ROUND_UP(V, B) (((int) V + (B-1)) & ~(B-1))
#define ROUND_DOWN(V, B) (((int) V) & ~(B-1))

/* Sign-extend an int16 to an int32 */
#define SIGN_EX(X) (((X) & 0x8000) ? ((X) | 0xffff0000) : (X))


#ifdef MIN		  /* Some systems define these in system includes */
#undef MIN
#endif
#ifdef MAX
#undef MAX
#endif
#define MIN(A, B) ((A) < (B) ? (A) : (B))
#define MAX(A, B) ((A) > (B) ? (A) : (B))


/* Useful and pervasive declarations: */

#ifdef NO_MEM_FUNCTIONS
#define memcpy(T, F, S) bcopy((void*)F, (void*)T, S)
#define memclr(B, S) bzero(B, S)
#define memcmp(S1, S2, N) bcmp(S1, S2, N)
#else
#include <memory.h>
#define memclr(B, S) memset((void*)B, 0, S)
#endif

#include <stdlib.h>
#include <string.h>
#define QSORT_FUNC int(*)(const void *, const void *)



#define K 1024


/* Type of a memory address.  Must be a 32-bit quantity to match MIPS.  */

typedef uint32 /*@alt int @*/ mem_addr;


#define BYTES_PER_WORD 4	/* On the MIPS processor */


/* Sizes of memory segments. */

/* Initial size of text segment. */

#ifndef TEXT_SIZE
#define TEXT_SIZE	(256*K)	/* 1/4 MB */
#endif

/* Initial size of k_text segment. */

#ifndef K_TEXT_SIZE
#define K_TEXT_SIZE	(64*K)	/* 64 KB */
#endif

/* The data segment must be larger than 64K since we immediate grab
   64K for the small data segment pointed to by $gp. The data segment is
   expanded by an sbrk system call. */

/* Initial size of data segment. */

#ifndef DATA_SIZE
#define DATA_SIZE	(256*K)	/* 1/4 MB */
#endif

/* Maximum size of data segment. */

#ifndef DATA_LIMIT
#define DATA_LIMIT	(K*K)	/* 1 MB */
#endif

/* Initial size of k_data segment. */

#ifndef K_DATA_SIZE
#define K_DATA_SIZE	(64*K)	/* 64 KB */
#endif

/* Maximum size of k_data segment. */

#ifndef K_DATA_LIMIT
#define K_DATA_LIMIT	(K*K)	/* 1 MB */
#endif

/* The stack grows down automatically. */

/* Initial size of stack segment. */

#ifndef STACK_SIZE
#define STACK_SIZE	(64*K)	/* 64 KB */
#endif

/* Maximum size of stack segment. */

#ifndef STACK_LIMIT
#define STACK_LIMIT	(256*K)	/* 1/4 MB */
#endif


/* Name of the function to invoke at start up */

#define DEFAULT_RUN_LOCATION "__start"


/* Name of the symbol marking the end of the exception handler */

#define END_OF_TRAP_HANDLER_SYMBOL "__eoth"


/* Default number of instructions to execute. */

#define DEFAULT_RUN_STEPS 2147483647


/* Address to branch to when exception occurs */
#ifdef MIPS1
/* MIPS R2000 */
#define EXCEPTION_ADDR 0x80000080
#else
/* MIPS32 */
#define EXCEPTION_ADDR 0x80000180
#endif

/* Maximum size of object stored in the small data segment pointed to by $gp */

#define SMALL_DATA_SEG_MAX_SIZE 8

#ifndef DIRECT_MAPPED
#define DIRECT_MAPPED 0
#define TWO_WAY_SET 1
#endif


/* Interval (in instructions) at which memory-mapped IO registers are
   checked and updated. (This is to reduce overhead from making system calls
   to check for IO. It can be set as low as 1.) */

#define IO_INTERVAL 100


/* Number of IO_INTERVALs that a character remains in receiver buffer,
   even if another character is available. */

#define RECV_INTERVAL 100


/* Number of IO_INTERVALs that it takes to write a character. */

#define TRANS_LATENCY 100


/* Iterval (milliseconds) for the hardware timer in CP0. */

#define TIMER_TICK_MS 10	/* 100 times per second */



/* A port is either a Unix file descriptor (an int) or a FILE* pointer. */

#include <stdio.h>

typedef union {int i; FILE* f;} port;


/* Exported functions (from spim.c or xspim.c): */

int console_input_available ();
void control_c_seen (int);
void error (char *fmt, ...);
void fatal_error (char *fmt, ...);
char get_console_char ();
void put_console_char (char c);
void read_input (char *str, int n);
void run_error (char *fmt, ...);
void write_output (port, char *fmt, ...);


/* Exported variables: */

extern int bare_machine;	/* Non-zero => simulate bare machine */
extern int accept_pseudo_insts;	/* Non-Zero => parse pseudo instructions  */
extern int delayed_branches;	/* Non-zero => simulate delayed branches */
extern int delayed_loads;	/* Non-zero => simulate delayed loads */
extern int quiet;		/* Non-zero => no warning messages */
extern char *exception_file_name;/* File containing exception handler */
extern int force_break;		/* Non-zero => stop interpreter loop  */
extern int parser_error_occurred; /* Non-zero => parse resulted in error */
extern int spim_return_value;	/* Value returned when spim exits */
/* Actual type of structure pointed to depends on X/terminal interface */
extern port message_out, console_out, console_in;
extern int mapped_io;		/* Non-zero => activate memory-mapped IO */
extern mem_addr program_starting_address;
extern int initial_text_size;
extern int initial_data_size;
extern mem_addr initial_data_limit;
extern int initial_stack_size;
extern mem_addr initial_stack_limit;
extern int initial_k_text_size;
extern int initial_k_data_size;
extern mem_addr initial_k_data_limit;
/* SPIM S20 MIPS simulator.
   System calls implemented by simulator.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/spim-syscall.h 7     2/15/04 1:07p Larus $
*/


#define PRINT_INT_SYSCALL	1
#define PRINT_FLOAT_SYSCALL	2
#define PRINT_DOUBLE_SYSCALL	3
#define PRINT_STRING_SYSCALL	4
#define READ_INT_SYSCALL	5
#define READ_FLOAT_SYSCALL	6
#define READ_DOUBLE_SYSCALL	7
#define READ_STRING_SYSCALL	8
#define SBRK_SYSCALL		9
#define EXIT_SYSCALL		10
#define PRINT_CHARACTER_SYSCALL	11
#define READ_CHARACTER_SYSCALL	12

#define OPEN_SYSCALL		13
#define READ_SYSCALL		14
#define WRITE_SYSCALL		15
#define CLOSE_SYSCALL		16

#define EXIT2_SYSCALL		17
/* SPIM S20 MIPS simulator.
   Misc. routines for SPIM.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.
   Changes for DOS and Windows versions by David A. Carley (dac@cs.wisc.edu)

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/spim-utils.c 28    1/02/05 7:59p Larus $
*/


#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdarg.h>

#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "data.h"
#include "reg.h"
#include "mem.h"
#include "scanner.h"
#include "parser.h"
#include "y.tab.h"
#include "run.h"
#include "sym-tbl.h"


/* Internal functions: */

static mem_addr copy_int_to_stack (int n);
static mem_addr copy_str_to_stack (char *s);
static void delete_all_breakpoints ();


int exception_occurred;

mem_addr program_starting_address = 0;

int initial_text_size = TEXT_SIZE;

int initial_data_size = DATA_SIZE;

mem_addr initial_data_limit = DATA_LIMIT;

int initial_stack_size = STACK_SIZE;

mem_addr initial_stack_limit = STACK_LIMIT;

int initial_k_text_size = K_TEXT_SIZE;

int initial_k_data_size = K_DATA_SIZE;

mem_addr initial_k_data_limit = K_DATA_LIMIT;



/* Initialize or reinitialize the state of the machine. */

void
initialize_world (char* exception_file_names)
{
  /* Allocate the floating point registers */
  if (FGR == NULL)
    FPR = (double *) xmalloc (FPR_LENGTH * sizeof (double));
  /* Allocate the memory */
  make_memory (initial_text_size,
	       initial_data_size, initial_data_limit,
	       initial_stack_size, initial_stack_limit,
	       initial_k_text_size,
	       initial_k_data_size, initial_k_data_limit);
  initialize_registers ();
  program_starting_address = 0;
  initialize_inst_tables ();
  initialize_symbol_table ();
  k_text_begins_at_point (K_TEXT_BOT);
  k_data_begins_at_point (K_DATA_BOT);
  data_begins_at_point (DATA_BOT);
  text_begins_at_point (TEXT_BOT);

  if (exception_file_names != NULL)
    {
      int old_bare = bare_machine;
      int old_accept = accept_pseudo_insts;
      char *filename;
      char *files;

      /* Save machine state */
      bare_machine = 0;	       /* Exception handler uses extended machine */
      accept_pseudo_insts = 1;

      /* strtok modifies the string, so we must back up the string prior to use. */
      if ((files = strdup (exception_file_names)) == NULL)
         fatal_error ("Insufficient memory to complete.\n");

      for (filename = strtok (files, ";"); filename != NULL; filename = strtok (NULL, ";"))
         {
            if (read_assembly_file (filename))
               fatal_error ("Cannot read exception handler: %s\n", filename);

            write_output (message_out, "Loaded: %s\n", filename);
         }

      free (files);

      /* Restore machine state */
      bare_machine = old_bare;
      accept_pseudo_insts = old_accept;

      if (!bare_machine)
      {
	(void)make_label_global ("main"); /* In case .globl main forgotten */
	(void)record_label ("main", 0, 0);
      }
    }
  initialize_scanner (stdin);
  delete_all_breakpoints ();
}


void
write_startup_message ()
{
  write_output (message_out, "SPIM %s\n", SPIM_VERSION);
  write_output (message_out,
		"Copyright 1990-2004 by James R. Larus (larus@cs.wisc.edu).\n");
  write_output (message_out, "All Rights Reserved.\n");
#ifdef WIN32
  write_output (message_out, "DOS and Windows ports by David A. Carley (dac@cs.wisc.edu).\n");
  write_output (message_out, "Copyright 1997 by Morgan Kaufmann Publishers, Inc.\n");
#endif
  write_output (message_out, "See the file README for a full copyright notice.\n");
}



void
initialize_registers ()
{
  memclr (FPR, FPR_LENGTH * sizeof (double));
  FGR = (float *) FPR;
  FWR = (int *) FPR;

  memclr (R, R_LENGTH * sizeof (reg_word));
  R[REG_SP] = STACK_TOP - BYTES_PER_WORD - 4096; /* Initialize $sp */
  HI = LO = 0;
  PC = 0;

  CP0_BadVAddr = 0;
  CP0_Count = 0;
  CP0_Compare = 0;
  CP0_Status = (CP0_Status_CU & 0x30000000) | CP0_Status_IM | CP0_Status_UM;
  CP0_Cause = 0;
  CP0_EPC = 0;
#ifdef BIGENDIAN
  CP0_Config =  CP0_Config_BE;
#else
  CP0_Config = 0;
#endif

  FIR = FIR_W | FIR_D | FIR_S;	/* Word, double, & single implemented */
  FCSR = 0x0;
  FCCR = 0x0;
  FEXR = 0x0;
  FENR = 0x0;
}


/* Read file NAME, which should contain assembly code. Return zero if
   successful and non-zero otherwise. */

int
read_assembly_file (char *name)
{
  FILE *file = fopen (name, "rt");

  if (file == NULL)
    {
      error ("Cannot open file: `%s'\n", name);
      return (1);
    }
  else
    {
      initialize_scanner (file);
      initialize_parser (name);

      while (!yyparse ()) ;

      fclose (file);
      flush_local_labels (!parse_error_occurred);
      end_of_assembly_file ();
      return (0);
    }
}


mem_addr
starting_address ()
{
  if (PC == 0)
    {
      if (program_starting_address != 0)
	return (program_starting_address);
      else
	return (program_starting_address
		= find_symbol_address (DEFAULT_RUN_LOCATION));
    }
  else
    return (PC);
}


/* Initialize the SPIM stack with ARGC, ARGV, and ENVP data. */

#ifdef _MSC_VER
#define environ	_environ
#endif

void
initialize_run_stack (int argc, char **argv)
{
  char **p;
  extern char **environ;
  int i, j = 0, env_j;
  mem_addr addrs[10000];

  /* Put strings on stack: */

  /* env: */
  for (p = environ; *p != NULL; p++)
    addrs[j++] = copy_str_to_stack (*p);
  env_j = j;

  /* argv; */
  for (i = 0; i < argc; i++)
    addrs[j++] = copy_str_to_stack (argv[i]);

  R[REG_SP] = STACK_TOP - BYTES_PER_WORD - 4096; /* Initialize $sp */
  R[REG_SP] = R[REG_SP] & ~3;	/* Round down to nearest word */
  R[REG_SP] -= BYTES_PER_WORD;	/* First free word on stack */

  R[REG_SP] = R[REG_SP] & ~7;	/* Double-word align stack-pointer*/
  if ((j % 2) != 0)		/* Odd number of arguments */
    {
      R[REG_SP] -= BYTES_PER_WORD; /* Ensure stack ends up double-word aligned */
    }

  /* Build vectors on stack: */

  /* env: */
  (void)copy_int_to_stack (0);	/* Null-terminate vector */
  for (i = env_j - 1; i >= 0; i--)
    R[REG_A2] = copy_int_to_stack (addrs[i]);

  /* argv: */
  (void)copy_int_to_stack (0);	/* Null-terminate vector */
  for (i = j - 1; i >= env_j; i--)
    R[REG_A1] = copy_int_to_stack (addrs[i]);

  /* argc: */
  R[REG_A0] = argc;
  set_mem_word (R[REG_SP], argc); /* Leave argc on stack */
}


static mem_addr
copy_str_to_stack (char *s)
{
  int i = strlen (s);
  while (i >= 0)
    {
      set_mem_byte (R[REG_SP], s[i]);
      R[REG_SP] -= 1;
      i -= 1;
    }
  return ((mem_addr) R[REG_SP] + 1); /* Leaves stack pointer byte-aligned!! */
}


static mem_addr
copy_int_to_stack (int n)
{
  set_mem_word (R[REG_SP], n);
  R[REG_SP] -= BYTES_PER_WORD;
  return ((mem_addr) R[REG_SP] + BYTES_PER_WORD);
}


/* Run a program starting at PC for N steps and display each
   instruction before executing if FLAG is non-zero.  If CONTINUE is
   non-zero, then step through a breakpoint.  Return non-zero if
   breakpoint is encountered. */

int
run_program (mem_addr pc, int steps, int display, int cont_bkpt)
{
  if (cont_bkpt && inst_is_breakpoint (pc))
    {
      mem_addr addr = PC == 0 ? pc : PC;

      delete_breakpoint (addr);
      exception_occurred = 0;
      run_spim (addr, 1, display);
      add_breakpoint (addr);
      steps -= 1;
      pc = PC;
    }

  exception_occurred = 0;
  if (!run_spim (pc, steps, display))
      /* Can't restart program */
      PC = 0;
  if (exception_occurred && CP0_ExCode == ExcCode_Bp)
  {
      /* Turn off EXL bit, so subsequent interrupts set EPC since the break is
      handled by SPIM code, not MIPS code. */
      CP0_Status &= ~CP0_Status_EXL;
      return (1);
  }
  else
    return (0);
}


/* Record of where a breakpoint was placed and the instruction previously
   in memory. */

typedef struct bkptrec
{
  mem_addr addr;
  instruction *inst;
  struct bkptrec *next;
} bkpt;


static bkpt *bkpts = NULL;


/* Set a breakpoint at memory location ADDR. */

void
add_breakpoint (mem_addr addr)
{
  bkpt *rec = (bkpt *) xmalloc (sizeof (bkpt));

  rec->next = bkpts;
  rec->addr = addr;

  if ((rec->inst = set_breakpoint (addr)) != NULL)
    bkpts = rec;
  else
    {
      if (exception_occurred)
	error ("Cannot put a breakpoint at address 0x%08x\n", addr);
      else
	error ("No instruction to breakpoint at address 0x%08x\n", addr);
      free (rec);
    }
}


/* Delete all breakpoints at memory location ADDR. */

void
delete_breakpoint (mem_addr addr)
{
  bkpt *p, *b;
  int deleted_one = 0;

  for (p = NULL, b = bkpts; b != NULL; )
    if (b->addr == addr)
      {
	bkpt *n;

	set_mem_inst (addr, b->inst);
	if (p == NULL)
	  bkpts = b->next;
	else
	  p->next = b->next;
	n = b->next;
	free (b);
	b = n;
	deleted_one = 1;
      }
    else
      p = b, b = b->next;
  if (!deleted_one)
    error ("No breakpoint to delete at 0x%08x\n", addr);
}


static void
delete_all_breakpoints ()
{
  bkpt *b, *n;

  for (b = bkpts, n = NULL; b != NULL; b = n)
    {
      n = b->next;
      free (b);
    }
  bkpts = NULL;
}


/* List all breakpoints. */

void
list_breakpoints ()
{
  bkpt *b;

  if (bkpts)
    for (b = bkpts;  b != NULL; b = b->next)
      write_output (message_out, "Breakpoint at 0x%08x\n", b->addr);
  else
    write_output (message_out, "No breakpoints set\n");
}



/* Utility routines */


/* Return the entry in the linear TABLE of length LENGTH with key STRING.
   TABLE must be sorted on the key field.
   Return NULL if no such entry exists. */

name_val_val *
map_string_to_name_val_val (name_val_val tbl[], int tbl_len, char *id)
{
  int low = 0;
  int hi = tbl_len - 1;

  while (low <= hi)
    {
      int mid = (low + hi) / 2;
      char *idp = id, *np = tbl[mid].name;

      while (*idp == *np && *idp != '\0') {idp ++; np ++;}

      if (*np == '\0' && *idp == '\0') /* End of both strings */
	return (& tbl[mid]);
      else if (*idp > *np)
	low = mid + 1;
      else
	hi = mid - 1;
    }

  return NULL;
}


/* Return the entry in the linear TABLE of length LENGTH with VALUE1 field NUM.
   TABLE must be sorted on the VALUE1 field.
   Return NULL if no such entry exists. */

name_val_val *
map_int_to_name_val_val (name_val_val tbl[], int tbl_len, int num)
{
  int low = 0;
  int hi = tbl_len - 1;

  while (low <= hi)
    {
      int mid = (low + hi) / 2;

      if (tbl[mid].value1 == num)
	return (&tbl[mid]);
      else if (num > tbl[mid].value1)
	low = mid + 1;
      else
	hi = mid - 1;
    }

  return NULL;
}


#ifdef NEED_VSPRINTF
char *
vsprintf (str, fmt, args)
     char *str,*fmt;
     va_list *args;
{
  FILE _strbuf;

  _strbuf._flag = _IOWRT+_IOSTRG;
  _strbuf._ptr = str;
  _strbuf._cnt = 32767;
  _doprnt(fmt, args, &_strbuf);
  putc('\0', &_strbuf);
  return(str);
}
#endif


#ifdef NEED_STRTOL
unsigned long
strtol (const char* str, const char** eptr, int base)
{
  long result;

  if (base != 0 && base != 16)
    fatal_error ("SPIM's strtol only works for base 16 (not base %d)\n", base);
  if (*str == '0' && (*(str + 1) == 'x' || *(str + 1) == 'X'))
    {
      str += 2;
      sscanf (str, "%lx", &result);
    }
  else if (base == 16)
    {
      sscanf (str, "%lx", &result);
    }
  else
    {
      sscanf (str, "%ld", &result);
    }
  return (result);
}
#endif

#ifdef NEED_STRTOUL
unsigned long
strtoul (const char* str, char** eptr, int base)
{
  unsigned long result;

  if (base != 0 && base != 16)
    fatal_error ("SPIM's strtoul only works for base 16 (not base %d)\n", base);
  if (*str == '0' && (*(str + 1) == 'x' || *(str + 1) == 'X'))
    {
      str += 2;
      sscanf (str, "%lx", &result);
    }
  else if (base == 16)
    {
      sscanf (str, "%lx", &result);
    }
  else
    {
      sscanf (str, "%ld", &result);
    }
  return (result);
}
#endif


char *
str_copy (char *str)
{
  return (strcpy (xmalloc (strlen (str) + 1), str));
}


void *
xmalloc (int size)
{
  void *x = (void *) malloc (size);

  if (x == 0)
    fatal_error ("Out of memory at request for %d bytes.\n");
  return (x);
}


/* Allocate a zero'ed block of storage. */

void *
zmalloc (int size)
{
  void *z = (void *) malloc (size);

  if (z == 0)
    fatal_error ("Out of memory at request for %d bytes.\n");

  memclr (z, size);
  return (z);
}
/* SPIM S20 MIPS simulator.
   Interface to misc. routines for SPIM.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/spim-utils.h 10    3/21/04 2:05p Larus $
*/


/* Triple containing a string and two integers.	 Used in tables
   mapping from a name to values. */

typedef struct
{
  char *name;
  int value1;
  int value2;
} name_val_val;



/* Exported functions: */

void add_breakpoint (mem_addr addr);
void delete_breakpoint (mem_addr addr);
void format_data_segs (str_stream *ss);
void format_insts (str_stream *ss, mem_addr from, mem_addr to);
void format_mem (str_stream *ss, mem_addr from, mem_addr to);
void format_registers (str_stream *ss, int print_gpr_hex, int print_fpr_hex);
void initialize_registers ();
void initialize_run_stack (int argc, char **argv);
void initialize_world (char *exception_file_names);
void list_breakpoints ();
name_val_val *map_int_to_name_val_val (name_val_val tbl[], int tbl_len, int num);
name_val_val *map_string_to_name_val_val (name_val_val tbl[], int tbl_len, char *id);
int read_assembly_file (char *name);
int run_program (mem_addr pc, int steps, int display, int cont_bkpt);
mem_addr starting_address ();
char *str_copy (char *str);
void write_startup_message ();
void *xmalloc (int);
void *zmalloc (int);
/* SPIM S20 MIPS simulator.
  Append-only output stream convertable to a string.

  Copyright (C) 2004 by James Larus (larus@cs.wisc.edu).
  ALL RIGHTS RESERVED.

  SPIM is distributed under the following conditions:

  You may make copies of SPIM for your own use and modify those copies.

  All copies of SPIM must retain my name and copyright notice.

  You may not sell SPIM or distributed SPIM in conjunction with a
  commerical product or service without the expressed written consent of
  James Larus.

  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE.

  $Header: /Software/SPIM/src/string-stream.c 3     7/07/04 8:22p Larus $
*/

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>

#include "spim.h"
#include "string-stream.h"


#ifndef SS_BUF_LENGTH
/* Initialize length of buffer */
#define SS_BUF_LENGTH 256
#endif


static void
ss_init (str_stream* ss)
{
  ss->buf = (char *) malloc (SS_BUF_LENGTH);
  ss->max_length = SS_BUF_LENGTH;
  ss->empty_pos = 0;
  ss->initialized = 1;
}


void
ss_clear (str_stream* ss)
{
  if (0 == ss->initialized) ss_init (ss);

  ss->empty_pos = 0;
}


void
ss_erase (str_stream* ss, int n)
{
  if (0 == ss->initialized) ss_init (ss);

  ss->empty_pos -= n;
  if (ss->empty_pos <0) ss->empty_pos = 0;
}


int
ss_length (str_stream* ss)
{
  if (0 == ss->initialized) ss_init (ss);

  return ss->empty_pos;
}


char*
ss_to_string (str_stream* ss)
{
  if (0 == ss->initialized) ss_init (ss);

  if (ss->empty_pos == ss->max_length)
    {
      /* Not enough room to store output: increase buffer size and try again */
      ss->max_length = ss->max_length + 1;
      ss->buf = (char *) realloc (ss->buf, (size_t)ss->max_length);
      if (NULL == ss->buf)
	fatal_error ("realloc failed\n");
    }
  ss->buf[ss->empty_pos] = '\0'; /* Null terminate string */
  ss->empty_pos += 1;
  return ss->buf;
}


void
ss_printf (str_stream* ss, char* fmt, ...)
{
  int free_space;
  int n;
  va_list args;

  va_start (args, fmt);

  if (0 == ss->initialized) ss_init (ss);

  free_space = ss->max_length - ss->empty_pos;
#ifdef WIN32
  /* Returns -1 when buffer is too small */
  while ((n = _vsnprintf (ss->buf + ss->empty_pos, free_space, fmt, args)) < 0)
#else
    /* Returns necessary space when buffer is too small */
   while ((n = vsnprintf (ss->buf + ss->empty_pos, free_space, fmt, args)) >= free_space)
#endif
      {
	/* Not enough room to store output: double buffer size and try again */
	ss->max_length = 2 * ss->max_length;
	ss->buf = (char *) realloc (ss->buf, (size_t)ss->max_length);
	free_space = ss->max_length - ss->empty_pos;
	if (NULL == ss->buf)
	  fatal_error ("realloc failed\n");

	va_end (args);		/* Restart argument pointer */
	va_start (args, fmt);
      }
  ss->empty_pos += n;

  /* Null terminate string (for debugging) if there is enough room*/
  if (ss->empty_pos < ss->max_length)
    ss->buf[ss->empty_pos] = '\0';

  va_end (args);
}
/* SPIM S20 MIPS simulator.
  Append-only output stream convertable to a string.

  Copyright (C) 2004 by James Larus (larus@cs.wisc.edu).
  ALL RIGHTS RESERVED.

  SPIM is distributed under the following conditions:

  You may make copies of SPIM for your own use and modify those copies.

  All copies of SPIM must retain my name and copyright notice.

  You may not sell SPIM or distributed SPIM in conjunction with a
  commerical product or service without the expressed written consent of
  James Larus.

  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE.

  $Header: /Software/SPIM/src/string-stream.h 1     3/21/04 2:05p Larus $
*/

typedef struct str_stm
{
  char* buf;			/* Buffer containing output */
  int max_length;		/* Length of buffer */
  int empty_pos;		/* Index  of empty char in stream*/
  int initialized;		/* Stream initialized? */
} str_stream;


void ss_clear (str_stream* ss);
void ss_erase (str_stream* ss, int n);
int ss_length (str_stream* ss);
char* ss_to_string (str_stream* ss);
void ss_printf (str_stream* ss, char* fmt, ...);
/* SPIM S20 MIPS simulator.
   Code to maintain symbol table to resolve symbolic labels.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/sym-tbl.c 22    3/21/04 2:05p Larus $
*/



#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "mem.h"
#include "data.h"
#include "parser.h"
#include "sym-tbl.h"
#include "y.tab.h"


/* Local functions: */

static void get_hash (char *name, int *slot_no, label **entry);
static void resolve_a_label_sub (label *sym, instruction *inst, mem_addr pc);



/* Keep track of the memory location that a label represents.  If we
   see a reference to a label that is not yet defined, then record the
   reference so that we can patch up the instruction when the label is
   defined.

   At the end of a file, we flush the hash table of all non-global
   labels so they can't be seen in other files.	 */


static label *local_labels = NULL; /* Labels local to current file. */


#define HASHBITS 30

#define LABEL_HASH_TABLE_SIZE 8191


/* Map from name of a label to a label structure. */

static label *label_hash_table [LABEL_HASH_TABLE_SIZE];


/* Initialize the symbol table by removing and freeing old entries. */

void
initialize_symbol_table ()
{
  int i;

  for (i = 0; i < LABEL_HASH_TABLE_SIZE; i ++)
  {
    label *x, *n;

    for (x = label_hash_table [i]; x != NULL; x = n)
    {
      free (x->name);
      n = x->next;
      free (x);
    }
    label_hash_table [i] = NULL;
  }

  local_labels = NULL;
}



/* Lookup for a label with the given NAME.  Set the SLOT_NO to be the hash
   table bucket that contains (or would contain) the label's record.  If the
   record is already in the table, set ENTRY to point to it.  Otherwise,
   set ENTRY to be NULL. */

static void
get_hash (char *name, int *slot_no, label **entry)
{
  int hi;
  int i;
  label *lab;
  int len;

  /* Compute length of name in len.  */
  for (len = 0; name[len]; len++);

  /* Compute hash code */
  hi = len;
  for (i = 0; i < len; i++)
    hi = ((hi * 613) + (unsigned)(name[i]));

  hi &= (1 << HASHBITS) - 1;
  hi %= LABEL_HASH_TABLE_SIZE;

  *slot_no = hi;
  /* Search table for entry */
  for (lab = label_hash_table [hi]; lab; lab = lab->next)
    if (streq (lab->name, name))
      {
	*entry = lab;		/* <-- return if found */
	return;
      }
  *entry = NULL;
}


/* Lookup label with NAME.  Either return its symbol table entry or NULL
   if it is not in the table. */

label *
label_is_defined (char *name)
{
  int hi;
  label *entry;

  get_hash (name, &hi, &entry);

  return (entry);
}


/* Return a label with a given NAME.  If an label with that name has
   previously been looked-up, the same node is returned this time.  */

label *
lookup_label (char *name)
{
  int hi;
  label *entry, *lab;

  get_hash (name, &hi, &entry);

  if (entry != NULL)
    return (entry);

  /* Not found, create one, add to chain */
  lab = (label *) xmalloc (sizeof (label));
  lab->name = str_copy (name);
  lab->addr = 0;
  lab->global_flag = 0;
  lab->const_flag = 0;
  lab->gp_flag = 0;
  lab->uses = NULL;

  lab->next = label_hash_table [hi];
  label_hash_table [hi] = lab;
  return lab;			/* <-- return if created */
}


/* Record that the label named NAME refers to ADDRESS.	If RESOLVE_USES is
   true, resolve all references to it.  Return the label structure. */

label *
record_label (char *name, mem_addr address, int resolve_uses)
{
  label *l = lookup_label (name);

  if (!l->gp_flag)
    {
      if (l->addr != 0)
	{
	  yyerror ("Label is defined for the second time");
	  return (l);
	}
      l->addr = address;
    }

  if (resolve_uses)
    {
      resolve_label_uses (l);
    }

  if (!l->global_flag)
    {
      l->next_local = local_labels;
      local_labels = l;
    }
  return (l);
}


/* Make the label named NAME global.  Return its symbol. */

label *
make_label_global (char *name)
{
  label *l = lookup_label (name);

  l->global_flag = 1;
  return (l);
}


/* Record that an INSTRUCTION uses the as-yet undefined SYMBOL. */

void
record_inst_uses_symbol (instruction *inst, label *sym)
{
  label_use *u = (label_use *) xmalloc (sizeof (label_use));

  if (data_dir)			/* Want to free up original instruction */
    {
      u->inst = copy_inst (inst);
      u->addr = current_data_pc ();
    }
  else
    {
      u->inst = inst;
      u->addr = current_text_pc ();
    }
  u->next = sym->uses;
  sym->uses = u;
}


/* Record that a memory LOCATION uses the as-yet undefined SYMBOL. */

void
record_data_uses_symbol (mem_addr location, label *sym)
{
  label_use *u = (label_use *) xmalloc (sizeof (label_use));

  u->inst = NULL;
  u->addr = location;
  u->next = sym->uses;
  sym->uses = u;
}


/* Given a newly-defined LABEL, resolve the previously encountered
   instructions and data locations that refer to the label. */

void
resolve_label_uses (label *sym)
{
  label_use *use;
  label_use *next_use;

  for (use = sym->uses; use != NULL; use = next_use)
    {
      resolve_a_label_sub (sym, use->inst, use->addr);
      if (use->inst != NULL && use->addr >= DATA_BOT && use->addr < stack_bot)
	{
	  set_mem_word (use->addr, inst_encode (use->inst));
	  free_inst (use->inst);
	}
      next_use = use->next;
      free (use);
    }
  sym->uses = NULL;
}


/* Resolve the newly-defined label in INSTRUCTION. */

void
resolve_a_label (label *sym, instruction *inst)
{
  resolve_a_label_sub (sym,
		       inst,
		       (data_dir ? current_data_pc () : current_text_pc ()));
}


static void
resolve_a_label_sub (label *sym, instruction *inst, mem_addr pc)
{
  if (inst == NULL)
    {
      /* Memory data: */
      set_mem_word (pc, sym->addr);
    }
  else
    {
      /* Instruction: */
      if (EXPR (inst)->pc_relative)
	EXPR (inst)->offset = 0 - pc; /* Instruction may have moved */

      if (EXPR (inst)->symbol == NULL
	  || SYMBOL_IS_DEFINED (EXPR (inst)->symbol))
	{
	  int32 value;
	  int32 field_mask;

	  if (opcode_is_branch (OPCODE (inst)))
	    {
	      int val;

	      /* Drop low two bits since instructions are on word boundaries. */
	      val = SIGN_EX (eval_imm_expr (EXPR (inst)));   /* 16->32 bits */
	      val = (val >> 2) & 0xffff;	    /* right shift, 32->16 bits */

	      if (delayed_branches)
		val -= 1;

	      value = val;
	      field_mask = 0xffff;
	    }
	  else if (opcode_is_jump (OPCODE (inst)))
	    {
	      value = eval_imm_expr (EXPR (inst));
		  if ((value & 0xf0000000) != (pc & 0xf0000000))
		  {
			  error ("Target of jump differs in high-order 4 bits from instruction pc 0x%x\n", pc);
		  }
		  /* Drop high four bits, since they come from the PC and the
			 low two bits since instructions are on word boundaries. */
	      value = (value & 0x0fffffff) >> 2;
	      field_mask = 0xffffffff;	/* Already checked that value fits in instruction */
	    }
	  else if (opcode_is_load_store (OPCODE (inst)))
	    {
	      /* Label's location is an address */
	      value = eval_imm_expr (EXPR (inst));
	      field_mask = 0xffff;

	      if (value & 0x8000)
		{
  		  /* LW/SW sign extends offset. Compensate by adding 1 to high 16 bits. */
		  instruction* prev_inst;
		  instruction* prev_prev_inst;
		  prev_inst = read_mem_inst (pc - BYTES_PER_WORD);
		  prev_prev_inst = read_mem_inst (pc - 2 * BYTES_PER_WORD);

		  if (prev_inst != NULL
		      && OPCODE (prev_inst) == Y_LUI_OP
		      && EXPR (inst)->symbol == EXPR (prev_inst)->symbol
		      && IMM (prev_inst) == 0)
		    {
		      /* Check that previous instruction was LUI and it has no immediate,
			 otherwise it will have compensated for sign-extension */
		      EXPR (prev_inst)->offset += 0x10000;
		    }
		  /* There is an ADDU instruction before the LUI if the
		     LW/SW instruction uses an index register: skip over the ADDU. */
		  else if (prev_prev_inst != NULL
		      && OPCODE (prev_prev_inst) == Y_LUI_OP
		      && EXPR (inst)->symbol == EXPR (prev_prev_inst)->symbol
		      && IMM (prev_prev_inst) == 0)
		    {
		      EXPR (prev_prev_inst)->offset += 0x10000;
		    }
		}
	    }
	  else
	    {
	      /* Label's location is a value */
	      value = eval_imm_expr (EXPR (inst));
	      field_mask = 0xffff;
	    }

	  if ((value & ~field_mask) != 0 && (value & ~field_mask) != 0xffff0000)
	    {
	      error ("Immediate value is too large for field: ");
	      print_inst (pc);
	    }
	  if (opcode_is_jump (OPCODE (inst)))
	    SET_TARGET (inst, value); /* Don't mask so it is sign-extended */
	  else
	    SET_IMM (inst, value);	/* Ditto */
	  SET_ENCODING (inst, inst_encode (inst));
	}
      else
	error ("Resolving undefined symbol: %s\n",
	       (EXPR (inst)->symbol == NULL) ? "" : EXPR (inst)->symbol->name);
    }
}


/* Remove all local (non-global) label from the table. */

void
flush_local_labels (int issue_undef_warnings)
{
  label *l;

  for (l = local_labels; l != NULL; l = l->next_local)
    {
      int hi;
      label *entry, *lab, *p;

      get_hash (l->name, &hi, &entry);

      for (lab = label_hash_table [hi], p = NULL;
	   lab;
	   p = lab, lab = lab->next)
	if (lab == entry)
	  {
	    if (p == NULL)
	      label_hash_table [hi] = lab->next;
	    else
	      p->next = lab->next;
	    if (issue_undef_warnings && entry->addr == 0 && !entry->const_flag)
	      error ("Warning: local symbol %s was not defined\n",
		     entry->name);
	    /* Can't free label since IMM_EXPR's still reference it */
	    break;
	  }
    }
  local_labels = NULL;
}


/* Return the address of SYMBOL or 0 if it is undefined. */

mem_addr
find_symbol_address (char *symbol)
{
  label *l = lookup_label (symbol);

  if (l == NULL || l->addr == 0)
    return 0;
  else
    return (l->addr);
}


/* Print all symbols in the table. */

void
print_symbols ()
{
  int i;
  label *l;

  for (i = 0; i < LABEL_HASH_TABLE_SIZE; i ++)
    for (l = label_hash_table [i]; l != NULL; l = l->next)
      write_output (message_out, "%s%s at 0x%08x\n",
		    l->global_flag ? "g\t" : "\t", l->name, l->addr);
}


/* Print all undefined symbols in the table. */

void
print_undefined_symbols ()
{
  int i;
  label *l;

  for (i = 0; i < LABEL_HASH_TABLE_SIZE; i ++)
    for (l = label_hash_table [i]; l != NULL; l = l->next)
      if (l->addr == 0)
	write_output (message_out, "%s\n", l->name);
}


/* Return a string containing the names of all undefined symbols in the
   table, seperated by a newline character.  Return NULL if no symbols
   are undefined. */

char *
undefined_symbol_string ()
{
  int buffer_length = 128;
  int string_length = 0;
  char *buffer = malloc(buffer_length);

  int i;
  label *l;

  for (i = 0; i < LABEL_HASH_TABLE_SIZE; i ++)
    for (l = label_hash_table[i]; l != NULL; l = l->next)
      if (l->addr == 0)
      {
	int name_length = strlen(l->name);
	int after_length = string_length + name_length + 2;
	if (buffer_length < after_length)
	{
	  buffer_length = MAX (2 * buffer_length, 2 * after_length);
	  buffer = realloc (buffer, buffer_length);
	}
	memcpy (buffer + string_length, l->name, name_length);
	string_length += name_length;
	buffer[string_length] = '\n';
	string_length += 1;
	buffer[string_length] = '\0'; /* After end of string */
      }

  if (string_length != 0)
    return (buffer);
  else
  {
    free (buffer);
    return (NULL);
  };
}
/* SPIM S20 MIPS simulator.
   Data structures for symbolic addresses.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/sym-tbl.h 9     2/23/04 4:42a Larus $
*/


typedef struct lab_use
{
  instruction *inst;		/* NULL => Data, not code */
  mem_addr addr;
  struct lab_use *next;
} label_use;


/* Symbol table information on a label. */

typedef struct lab
{
  char *name;			/* Name of label */
  long addr;			/* Address of label or 0 if not yet defined */
  unsigned global_flag : 1;	/* Non-zero => declared global */
  unsigned gp_flag : 1;		/* Non-zero => referenced off gp */
  unsigned const_flag : 1;	/* Non-zero => constant value (in addr) */
  struct lab *next;		/* Hash table link */
  struct lab *next_local;	/* Link in list of local labels */
  label_use *uses;		/* List of instructions that reference */
} label;			/* label that has not yet been defined */


#define SYMBOL_IS_DEFINED(SYM) ((SYM)->addr != 0)



/* Exported functions: */

mem_addr find_symbol_address (char *symbol);
void flush_local_labels (int issue_undef_warnings);
void initialize_symbol_table ();
label *label_is_defined (char *name);
label *lookup_label (char *name);
label *make_label_global (char *name);
void print_symbols ();
void print_undefined_symbols ();
label *record_label (char *name, mem_addr address, int resolve_uses);
void record_data_uses_symbol (mem_addr location, label *sym);
void record_inst_uses_symbol (instruction *inst, label *sym);
char *undefined_symbol_string ();
void resolve_a_label (label *sym, instruction *inst);
void resolve_label_uses (label *sym);
/* SPIM S20 MIPS simulator.
   Execute SPIM syscalls, both in simulator and bare mode.
   Execute MIPS syscalls in bare mode, when running on MIPS systems.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/syscall.c 4     3/27/04 4:50p Larus $ */

#ifndef WIN32
#include <unistd.h>
#endif
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/types.h>

#ifdef WIN32
#include <io.h>
#endif

#include "spim.h"
#include "string-stream.h"
#include "inst.h"
#include "reg.h"
#include "mem.h"
#include "sym-tbl.h"
#include "syscall.h"



/* Decides which syscall to execute or simulate.  Returns zero upon
   exit syscall and non-zero to continue execution. */

int
do_syscall ()
{
  /* Syscalls for the source-language version of SPIM.  These are easier to
     use than the real syscall and are portable to non-MIPS operating
     systems. */

  switch (R[REG_V0])
    {
    case PRINT_INT_SYSCALL:
      write_output (console_out, "%d", R[REG_A0]);
      break;

    case PRINT_FLOAT_SYSCALL:
      {
	float val = FPR_S (REG_FA0);

	write_output (console_out, "%.8f", val);
	break;
      }

    case PRINT_DOUBLE_SYSCALL:
      write_output (console_out, "%.18g", FPR[REG_FA0 / 2]);
      break;

    case PRINT_STRING_SYSCALL:
      write_output (console_out, "%s", mem_reference (R[REG_A0]));
      break;

    case READ_INT_SYSCALL:
      {
	static char str [256];

	read_input (str, 256);
	R[REG_RES] = atol (str);
	break;
      }

    case READ_FLOAT_SYSCALL:
      {
	static char str [256];

	read_input (str, 256);
	FPR_S (REG_FRES) = (float) atof (str);
	break;
      }

    case READ_DOUBLE_SYSCALL:
      {
	static char str [256];

	read_input (str, 256);
	FPR [REG_FRES] = atof (str);
	break;
      }

    case READ_STRING_SYSCALL:
      {
	read_input ( (char *) mem_reference (R[REG_A0]), R[REG_A1]);
	data_modified = 1;
	break;
      }

    case SBRK_SYSCALL:
      {
	mem_addr x = data_top;
	expand_data (R[REG_A0]);
	R[REG_RES] = x;
	data_modified = 1;
	break;
      }

    case PRINT_CHARACTER_SYSCALL:
      write_output (console_out, "%c", R[REG_A0]);
      break;

    case READ_CHARACTER_SYSCALL:
      {
	static char str [2];

	read_input (str, 2);
	if (*str == '\0') *str = '\n';      /* makes xspim = spim */
	R[REG_RES] = (long) str[0];
	break;
      }

    case EXIT_SYSCALL:
      spim_return_value = 0;
      return (0);

    case EXIT2_SYSCALL:
      spim_return_value = R[REG_A0];	/* value passed to spim's exit() call */
      return (0);

    case OPEN_SYSCALL:
      {
#ifdef WIN32
	R[REG_RES] = _open(mem_reference (R[REG_A0]), R[REG_A1], R[REG_A2]);
#else
	R[REG_RES] = open(mem_reference (R[REG_A0]), R[REG_A1], R[REG_A2]);
#endif
	break;
      }
		
    case READ_SYSCALL:
      {
	/* Test if address is valid */
	(void)mem_reference (R[REG_A1] + R[REG_A2] - 1);
#ifdef WIN32
	R[REG_RES] = _read(R[REG_A0], mem_reference (R[REG_A1]), R[REG_A2]);
#else
	R[REG_RES] = read(R[REG_A0], mem_reference (R[REG_A1]), R[REG_A2]);
#endif
	data_modified = 1;
	break;
      }

    case WRITE_SYSCALL:
      {
	/* Test if address is valid */
	(void)mem_reference (R[REG_A1] + R[REG_A2] - 1);
#ifdef WIN32
	R[REG_RES] = _write(R[REG_A0], mem_reference (R[REG_A1]), R[REG_A2]);
#else
	R[REG_RES] = write(R[REG_A0], mem_reference (R[REG_A1]), R[REG_A2]);
#endif
	break;
      }

    case CLOSE_SYSCALL:
      {
#ifdef WIN32
	R[REG_RES] = _close(R[REG_A0]);
#else
	R[REG_RES] = close(R[REG_A0]);
#endif
	break;
      }

    default:
      run_error ("Unknown system call: %d\n", R[REG_V0]);
      break;
    }

  return (1);
}



void
handle_exception ()
{
  if (!quiet && CP0_ExCode != ExcCode_Int)
    error ("Exception occurred at PC=0x%08x\n", CP0_EPC);

  exception_occurred = 0;
  PC = EXCEPTION_ADDR;

  switch (CP0_ExCode)
    {
    case ExcCode_Int:
      break;

    case ExcCode_AdEL:
      if (!quiet)
	error ("  Unaligned address in inst/data fetch: 0x%08x\n", CP0_BadVAddr);
      break;

    case ExcCode_AdES:
      if (!quiet)
	error ("  Unaligned address in store: 0x%08x\n", CP0_BadVAddr);
      break;

    case ExcCode_IBE:
      if (!quiet)
	error ("  Bad address in text read: 0x%08x\n", CP0_BadVAddr);
      break;

    case ExcCode_DBE:
      if (!quiet)
	error ("  Bad address in data/stack read: 0x%08x\n", CP0_BadVAddr);
      break;

    case ExcCode_Sys:
      if (!quiet)
	error ("  Error in syscall\n");
      break;

    case ExcCode_Bp:
      exception_occurred = 0;
      return;

    case ExcCode_RI:
      if (!quiet)
	error ("  Reserved instruction execution\n");
      break;

    case ExcCode_CpU:
      if (!quiet)
	error ("  Coprocessor unuable\n");
      break;

    case ExcCode_Ov:
      if (!quiet)
	error ("  Arithmetic overflow\n");
      break;

    case ExcCode_Tr:
      if (!quiet)
	error ("  Trap\n");
      break;

    case ExcCode_FPE:
      if (!quiet)
	error ("  Floating point\n");
      break;

    default:
      if (!quiet)
	error ("Unknown exception: %d\n", CP0_ExCode);
      break;
    }
}
/* SPIM S20 MIPS simulator.
   Execute SPIM syscalls, both in simulator and bare mode.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.
   Improved by Emin Gun Sirer.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.
     ALL RIGHTS RESERVED.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/syscall.h 1     3/11/04 7:14a Larus $
*/


/* Exported functions. */

int do_syscall ();
void handle_exception ();

#define PRINT_INT_SYSCALL	1
#define PRINT_FLOAT_SYSCALL	2
#define PRINT_DOUBLE_SYSCALL	3
#define PRINT_STRING_SYSCALL	4

#define READ_INT_SYSCALL	5
#define READ_FLOAT_SYSCALL	6
#define READ_DOUBLE_SYSCALL	7
#define READ_STRING_SYSCALL	8

#define SBRK_SYSCALL		9

#define EXIT_SYSCALL		10

#define PRINT_CHARACTER_SYSCALL	11
#define READ_CHARACTER_SYSCALL	12

#define OPEN_SYSCALL		13
#define READ_SYSCALL		14
#define WRITE_SYSCALL		15
#define CLOSE_SYSCALL		16

#define EXIT2_SYSCALL		17

/* SPIM S20 MIPS simulator.
   Code to build assembly instructions and resolve symbolic labels.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/inst.c 27    10/19/04 9:22p Larus $
*/

#include <stdio.h>
#include <string.h>

#include "spim.h"
#include "string-stream.h"
#include "spim-utils.h"
#include "inst.h"
#include "reg.h"
#include "mem.h"
#include "sym-tbl.h"
#include "parser.h"
#include "scanner.h"
#include "y.tab.h"
#include "data.h"


/* Local functions: */

static int compare_pair_value (name_val_val *p1, name_val_val *p2);
static void format_imm_expr (str_stream *ss, imm_expr *expr, int base_reg);
static void i_type_inst_full_word (int opcode, int rt, int rs, imm_expr *expr,
				   int value_known, int32 value);
static void inst_cmp (instruction *inst1, instruction *inst2);
static instruction *make_r_type_inst (int opcode, int rd, int rs, int rt);
static instruction *mk_i_inst (int32 value, int opcode, int rs, int rt, int offset);
static instruction *mk_j_inst (int32, int opcode, int target);
static instruction *mk_r_inst (int32, int opcode, int rs, int rt, int rd, int shamt);
static void produce_immediate (imm_expr *expr, int rt, int value_known, int32 value);
static void sort_a_opcode_table ();
static void sort_i_opcode_table ();
static void sort_name_table ();


/* Local variables: */

/* Non-zero means store instructions in kernel, not user, text segment */

static int in_kernel = 0;

/* Instruction used as breakpoint by SPIM: */

static instruction *break_inst = NULL;


/* Locations for next instruction in user and kernel text segments */

static mem_addr next_text_pc;

static mem_addr next_k_text_pc;


#define INST_PC (in_kernel ? next_k_text_pc : next_text_pc)
#define BUMP_INST_PC(DELTA) {if (in_kernel) \
			       next_k_text_pc += DELTA; \
			       else next_text_pc += DELTA;}



/* Set ADDRESS at which the next instruction is stored. */

void
text_begins_at_point (mem_addr addr)
{
  next_text_pc = addr;
}


void
k_text_begins_at_point (mem_addr addr)
{
  next_k_text_pc = addr;
}


/* Set the location (in user or kernel text space) for the next instruction. */

void
set_text_pc (mem_addr addr)
{
  if (in_kernel)
    next_k_text_pc = addr;
  else
    next_text_pc = addr;
}


/* Return address for next instruction, in appropriate text segment. */

mem_addr
current_text_pc ()
{
  return (INST_PC);
}


/* Increment the current text segement PC. */

void
increment_text_pc (int delta)
{
  BUMP_INST_PC (delta);
}


/* If FLAG is non-zero, next instruction goes to kernel text segment,
   otherwise it goes to user segment. */

void
user_kernel_text_segment (int to_kernel)
{
  in_kernel = to_kernel;
}


/* Store an INSTRUCTION in memory at the next location. */

void
store_instruction (instruction *inst)
{
  if (data_dir)
    {
      store_word (inst_encode (inst));
      free_inst (inst);
    }
  else if (text_dir)
    {
      exception_occurred = 0;
      set_mem_inst (INST_PC, inst);
      if (exception_occurred)
	error ("Invalid address (0x%08x) for instruction\n", INST_PC);
      else
	BUMP_INST_PC (BYTES_PER_WORD);
      if (inst != NULL)
	{
	  SET_SOURCE (inst, source_line ());
	  if (ENCODING (inst) == 0)
	    SET_ENCODING (inst, inst_encode (inst));
	}
    }
}



void
i_type_inst_free (int opcode, int rt, int rs, imm_expr *expr)
{
  i_type_inst (opcode, rt, rs, expr);
  free (expr);
}


/* Produce an immediate instruction with the OPCODE, RT, RS, and IMM
   fields.  NB, because the immediate value may not fit in the field,
   this routine may produce more than one instruction.	On the bare
   machine, we resolve symbolic address, but they better produce values
   that fit into instruction's immediate field. */

void
i_type_inst (int opcode, int rt, int rs, imm_expr *expr)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE (inst, opcode);
  SET_RS (inst, rs);
  SET_RT (inst, rt);
  SET_EXPR (inst, copy_imm_expr (expr));
  if (expr->symbol == NULL || SYMBOL_IS_DEFINED (expr->symbol))
    {
      /* Evaluate the instruction's expression. */
      int32 value = eval_imm_expr (expr);

      if (!bare_machine
	  && (((opcode == Y_ADDI_OP
		|| opcode == Y_ADDIU_OP
		|| opcode == Y_SLTI_OP
		|| opcode == Y_SLTIU_OP)
	       ? ((value & 0xffff8000) != 0
		  && (value & 0xffff8000) != 0xffff8000)
	       : (value & 0xffff0000) != 0)))
	{
	  free_inst (inst);
	  i_type_inst_full_word (opcode, rt, rs, expr, 1, value);
	  return;
	}
      else
	resolve_a_label (expr->symbol, inst);
    }
  else if (bare_machine || expr->bits != 0)
    /* Don't know expression's value, but only needed upper/lower 16-bits
       anyways. */
    record_inst_uses_symbol (inst, expr->symbol);
  else
    {
      /* Don't know the expressions's value and want all of its bits,
	 so assume that it will not produce a small result and generate
	 sequence for 32 bit value. */
      free_inst (inst);

      i_type_inst_full_word (opcode, rt, rs, expr, 0, 0);
      return;
    }

  store_instruction (inst);
}


/* The immediate value for an instruction will (or may) not fit in 16 bits.
   Build the value from its piece with separate instructions. */

static void
i_type_inst_full_word (int opcode, int rt, int rs, imm_expr *expr,
		       int value_known, int32 value)
{
  if (opcode_is_load_store (opcode))
    {
      int offset;

      if (expr->symbol != NULL
	  && expr->symbol->gp_flag
	  && rs == 0
	  && IMM_MIN <= (offset = expr->symbol->addr + expr->offset)
	  && offset <= IMM_MAX)
	{
	  i_type_inst_free (opcode, rt, REG_GP, make_imm_expr (offset, NULL, 0));
	}
      else if (value_known)
	{
	  int low, high;

	  high = (value >> 16) & 0xffff;
	  low = value & 0xffff;

	  if (high != 0 &&
	      !(high == 0xffff && (low & 0x8000)))
	    {
	      /* Some of high 16 bits are non-zero */
	      if (low & 0x8000)
		{
		  /* Adjust high 16, since load sign-extends low 16*/
		  high += 1;
		}

	      i_type_inst_free (Y_LUI_OP, 1, 0, const_imm_expr (high));
	      if (rs != 0)	/* Base register */
		{
		  r_type_inst (Y_ADDU_OP, 1, 1, rs);
		}
	      i_type_inst_free (opcode, rt, 1, const_imm_expr (low));
	    }
	  else
	    {
	      /* Special case, sign-extension of low 16 bits sets high to 0xffff */
	      i_type_inst_free (opcode, rt, rs, const_imm_expr (low));
	    }
	}
      else
	{
	  /* Use $at */
	  /* Need to adjust if lower bits are negative */
	  i_type_inst_free (Y_LUI_OP, 1, 0, upper_bits_of_expr (expr));
	  if (rs != 0)		/* Base register */
	    {
	      r_type_inst (Y_ADDU_OP, 1, 1, rs);
	    }
	  i_type_inst_free (opcode, rt, 1, lower_bits_of_expr (expr));
	}
    }
  else if (opcode_is_branch (opcode))
    {
      if (value_known)
	{
	  if (bare_machine || (((value & 0xffff0000) == 0) || ((value & 0xffff0000) == 0xffff0000)))
	    {
	      /* Known value fits in 16 bits, so branch is fine: */
	      i_type_inst_free (opcode, rt, rs, lower_bits_of_expr (expr));
	    }
	  else
	    {
	      /* Known value is larger and requires a jump instruction: */
	      i_type_inst_free (negate_branch (opcode), rt, rs, make_imm_expr (8, NULL, 0));
	      j_type_inst (Y_J_OP, make_imm_expr(0, expr->symbol->name, 0));	/* Not a PC-relative branch, so discard offset */
	    }
	}
      else
	{
	  /* This only allows branches +/- 32K, which is not correct in general! FIXME!! */
	  i_type_inst_free (opcode, rt, rs, lower_bits_of_expr (expr));
	}
    }
  else
    /* Computation instruction */
    {
      int offset;

      if (expr->symbol != NULL
	  && expr->symbol->gp_flag && rs == 0
	  && IMM_MIN <= (offset = expr->symbol->addr + expr->offset)
	  && offset <= IMM_MAX)
	{
	  i_type_inst_free ((opcode == Y_LUI_OP ? Y_ADDIU_OP : opcode),
			    rt, REG_GP, make_imm_expr (offset, NULL, 0));
	}
      else
	{
	  /* Use $at */
	  if ((opcode == Y_ORI_OP
	       || opcode == Y_ADDI_OP
	       || opcode == Y_ADDIU_OP
	       || opcode == Y_LUI_OP)
	      && rs == 0)
	    {
	      produce_immediate(expr, rt, value_known, value);
	    }
	  else
	    {
	      produce_immediate(expr, 1, value_known, value);
	      r_type_inst (imm_op_to_op (opcode), rt, rs, 1);
	    }
	}
    }
}


static void
produce_immediate (imm_expr *expr, int rt, int value_known, int32 value)
{
  if (value_known && (value & 0xffff) == 0)
    {
      i_type_inst_free (Y_LUI_OP, rt, 0, upper_bits_of_expr (expr));
    }
  else if (value_known && (value & 0xffff0000) == 0)
    {
      i_type_inst_free (Y_ORI_OP, rt, 0, lower_bits_of_expr (expr));
    }
  else
    {
      i_type_inst_free (Y_LUI_OP, 1, 0, upper_bits_of_expr (expr));
      i_type_inst_free (Y_ORI_OP, rt, 1, lower_bits_of_expr(expr));
    }
}


/* Return a jump-type instruction with the given OPCODE and TARGET
   fields. NB, even the immediate value may not fit in the field, this
   routine will not produce more than one instruction. */

void
j_type_inst (int opcode, imm_expr *target)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE(inst, opcode);
  target->offset = 0;		/* Not PC relative */
  target->pc_relative = 0;
  SET_EXPR (inst, copy_imm_expr (target));
  if (target->symbol == NULL || SYMBOL_IS_DEFINED (target->symbol))
    resolve_a_label (target->symbol, inst);
  else
    record_inst_uses_symbol (inst, target->symbol);
  store_instruction (inst);
}


/* Return a register-type instruction with the given OPCODE, RD, RS, and RT
   fields. */

static instruction *
make_r_type_inst (int opcode, int rd, int rs, int rt)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE(inst, opcode);
  SET_RS(inst, rs);
  SET_RT(inst, rt);
  SET_RD(inst, rd);
  SHAMT(inst) = 0;
  return (inst);
}


/* Return a register-type instruction with the given OPCODE, RD, RS, and RT
   fields. */

void
r_type_inst (int opcode, int rd, int rs, int rt)
{
  store_instruction (make_r_type_inst (opcode, rd, rs, rt));
}


/* Return a register-type instruction with the given OPCODE, FD, FS, and FT
   fields. */

void
r_co_type_inst (int opcode, int fd, int fs, int ft)
{
  instruction *inst = make_r_type_inst (opcode, fs, 0, ft);
  SET_FD (inst, fd);
  store_instruction (inst);
}


/* Return a register-shift instruction with the given OPCODE, RD, RT, and
   SHAMT fields.*/

void
r_sh_type_inst (int opcode, int rd, int rt, int shamt)
{
  instruction *inst = make_r_type_inst (opcode, rd, 0, rt);
  SET_SHAMT(inst, shamt & 0x1f);
  store_instruction (inst);
}


/* Return a floating-point compare instruction with the given OPCODE,
   FS, FT, and CC fields.*/

void
r_cond_type_inst (int opcode, int fs, int ft, int cc)
{
  instruction *inst = make_r_type_inst (opcode, fs, 0, ft);
  SET_FD(inst, cc << 2);
  switch (opcode)
    {
    case Y_C_EQ_D_OP:
    case Y_C_EQ_S_OP:
      {
	SET_COND(inst, COND_EQ);
	break;
      }

    case Y_C_LE_D_OP:
    case Y_C_LE_S_OP:
      {
	SET_COND(inst, COND_IN | COND_LT | COND_EQ);
	break;
      }

    case Y_C_LT_D_OP:
    case Y_C_LT_S_OP:
      {
	SET_COND(inst, COND_IN | COND_LT);
	break;
      }

    case Y_C_NGE_D_OP:
    case Y_C_NGE_S_OP:
      {
	SET_COND(inst, COND_IN | COND_LT | COND_UN);
	break;
      }

    case Y_C_NGLE_D_OP:
    case Y_C_NGLE_S_OP:
      {
	SET_COND(inst, COND_IN | COND_UN);
	break;
      }

    case Y_C_NGL_D_OP:
    case Y_C_NGL_S_OP:
      {
	SET_COND(inst, COND_IN | COND_EQ | COND_UN);
	break;
      }

    case Y_C_NGT_D_OP:
    case Y_C_NGT_S_OP:
      {
	SET_COND(inst, COND_IN | COND_LT | COND_EQ | COND_UN);
	break;
      }

    case Y_C_OLT_D_OP:
    case Y_C_OLT_S_OP:
      {
	SET_COND(inst, COND_LT);
	break;
      }

    case Y_C_OLE_D_OP:
    case Y_C_OLE_S_OP:
      {
	SET_COND(inst, COND_LT | COND_EQ);
	break;
      }

    case Y_C_SEQ_D_OP:
    case Y_C_SEQ_S_OP:
      {
	SET_COND(inst, COND_IN | COND_EQ);
	break;
      }

    case Y_C_SF_D_OP:
    case Y_C_SF_S_OP:
      {
	SET_COND(inst, COND_IN);
	break;
      }

    case Y_C_F_D_OP:
    case Y_C_F_S_OP:
      {
	SET_COND(inst, 0);
	break;
      }

    case Y_C_UEQ_D_OP:
    case Y_C_UEQ_S_OP:
      {
	SET_COND(inst, COND_EQ | COND_UN);
	break;
      }

    case Y_C_ULT_D_OP:
    case Y_C_ULT_S_OP:
      {
	SET_COND(inst, COND_LT | COND_UN);
	break;
      }

    case Y_C_ULE_D_OP:
    case Y_C_ULE_S_OP:
      {
	SET_COND(inst, COND_LT | COND_EQ | COND_UN);
	break;
      }

    case Y_C_UN_D_OP:
    case Y_C_UN_S_OP:
      {
	SET_COND(inst, COND_UN);
	break;
      }
    }
  store_instruction (inst);
}


/* Make and return a deep copy of INST. */

instruction *
copy_inst (instruction *inst)
{
  instruction *new_inst = (instruction *) xmalloc (sizeof (instruction));

  *new_inst = *inst;
  /*memcpy ((void*)new_inst, (void*)inst , sizeof (instruction));*/
  SET_EXPR (new_inst, copy_imm_expr (EXPR (inst)));
  return (new_inst);
}


void
free_inst (instruction *inst)
{
  if (inst != break_inst)
    /* Don't free the breakpoint insructions since we only have one. */
    {
      if (EXPR (inst))
	free (EXPR (inst));
      free (inst);
    }
}



/* Maintain a table mapping from opcode to instruction name and
   instruction type.

   Table must be sorted before first use since its entries are
   alphabetical on name, not ordered by opcode. */


/* Sort all instruction table before first use. */

void
initialize_inst_tables ()
{
	sort_name_table ();
	sort_i_opcode_table ();
	sort_a_opcode_table ();
}


/* Map from opcode -> name/type. */

static name_val_val name_tbl [] = {
#undef OP
#define OP(NAME, OPCODE, TYPE, R_OPCODE) {NAME, OPCODE, TYPE},
#include "op.h"
};


/* Sort the opcode table on their key (the opcode value). */

static void
sort_name_table ()
{
  qsort (name_tbl,
	 sizeof (name_tbl) / sizeof (name_val_val),
	 sizeof (name_val_val),
	 (QSORT_FUNC) compare_pair_value);
}


/* Compare the VALUE1 field of two NAME_VAL_VAL entries in the format
   required by qsort. */

static int
compare_pair_value (name_val_val *p1, name_val_val *p2)
{
  if (p1->value1 < p2->value1)
    return (-1);
  else if (p1->value1 > p2->value1)
    return (1);
  else
    return (0);
}


/* Print the instruction stored at the memory ADDRESS. */

void
print_inst (mem_addr addr)
{
  instruction *inst;
  static str_stream ss;

  exception_occurred = 0;
  inst = read_mem_inst (addr);

  if (exception_occurred)
    {
      error ("Can't print instruction not in text segment (0x%08x)\n", addr);
      return;
    }

  ss_clear (&ss);
  format_an_inst (&ss, inst, addr);
  write_output (message_out, ss_to_string (&ss));
}


void
format_an_inst (str_stream *ss, instruction *inst, mem_addr addr)
{
  name_val_val *entry;
  int line_start = ss_length (ss);

  if (inst_is_breakpoint (addr))
    {
      delete_breakpoint (addr);
      ss_printf (ss, "*");
      format_an_inst (ss, read_mem_inst (addr), addr);
      add_breakpoint (addr);
      return;
    }

  ss_printf (ss, "[0x%08x]\t", addr);
  if (inst == NULL)
    {
      ss_printf (ss, "<none>\n");
      return;
    }

  entry = map_int_to_name_val_val (name_tbl,
				   sizeof (name_tbl) / sizeof (name_val_val),
				   OPCODE (inst));
  if (entry == NULL)
    {
      ss_printf (ss, "<unknown instruction %d>\n", OPCODE (inst));
      return;
    }

  ss_printf (ss, "0x%08x  %s", (uint32)ENCODING (inst), entry->name);
  switch (entry->value2)
    {
    case BC_TYPE_INST:
      ss_printf (ss, "%d %d", CC (inst), IDISP (inst));
      break;

    case B1_TYPE_INST:
      ss_printf (ss, " $%d %d", RS (inst), IDISP (inst));
      break;

    case I1s_TYPE_INST:
      ss_printf (ss, " $%d, %d", RS (inst), IMM (inst));
      break;

    case I1t_TYPE_INST:
      ss_printf (ss, " $%d, %d", RT (inst), IMM (inst));
      break;

    case I2_TYPE_INST:
      ss_printf (ss, " $%d, $%d, %d", RT (inst), RS (inst), IMM (inst));
      break;

    case B2_TYPE_INST:
      ss_printf (ss, " $%d, $%d, %d", RS (inst), RT (inst), IDISP (inst));
      break;

    case I2a_TYPE_INST:
      ss_printf (ss, " $%d, %d($%d)", RT (inst), IMM (inst), BASE (inst));
      break;

    case R1s_TYPE_INST:
      ss_printf (ss, " $%d", RS (inst));
      break;

    case R1d_TYPE_INST:
      ss_printf (ss, " $%d", RD (inst));
      break;

    case R2td_TYPE_INST:
      ss_printf (ss, " $%d, $%d", RT (inst), RD (inst));
      break;

    case R2st_TYPE_INST:
      ss_printf (ss, " $%d, $%d", RS (inst), RT (inst));
      break;

    case R2ds_TYPE_INST:
      ss_printf (ss, " $%d, $%d", RD (inst), RS (inst));
      break;

    case R2sh_TYPE_INST:
      if (ENCODING (inst) == 0)
	{
	  ss_erase (ss, 3);	/* zap sll */
	  ss_printf (ss, "nop");
	}
      else
	ss_printf (ss, " $%d, $%d, %d", RD (inst), RT (inst), SHAMT (inst));
      break;

    case R3_TYPE_INST:
      ss_printf (ss, " $%d, $%d, $%d", RD (inst), RS (inst), RT (inst));
      break;

    case R3sh_TYPE_INST:
      ss_printf (ss, " $%d, $%d, $%d", RD (inst), RT (inst), RS (inst));
      break;

    case FP_I2a_TYPE_INST:
      ss_printf (ss, " $f%d, %d($%d)", FT (inst), IMM (inst), BASE (inst));
      break;

    case FP_R2ds_TYPE_INST:
      ss_printf (ss, " $f%d, $f%d", FD (inst), FS (inst));
      break;

    case FP_R2ts_TYPE_INST:
      ss_printf (ss, " $%d, $f%d", RT (inst), FS (inst));
      break;

    case FP_CMP_TYPE_INST:
      ss_printf (ss, " $f%d, $f%d", FS (inst), FT (inst));
      break;

    case FP_R3_TYPE_INST:
      ss_printf (ss, " $f%d, $f%d, $f%d", FD (inst), FS (inst), FT (inst));
      break;

    case FP_MOVC_TYPE_INST:
      if (OPCODE (inst) == Y_MOVF_OP)
	ss_printf (ss, " $%d, $%d, %d", FD (inst), FS (inst), CC (inst));
      else
	ss_printf (ss, " $f%d, $f%d, %d", FD (inst), FS (inst), CC (inst));
      break;

    case J_TYPE_INST:
      ss_printf (ss, " 0x%08x", TARGET (inst) << 2);
      break;

    case NOARG_TYPE_INST:
      break;

    default:
      fatal_error ("Unknown instruction type in print_inst\n");
    }

  if (EXPR (inst) != NULL && EXPR (inst)->symbol != NULL)
    {
      ss_printf (ss, " [");
      if (opcode_is_load_store (OPCODE (inst)))
	format_imm_expr (ss, EXPR (inst), BASE (inst));
      else
	format_imm_expr (ss, EXPR (inst), -1);
      ss_printf (ss, "]");
    }

  if (SOURCE (inst) != NULL)
    {
      /* Comment is source line text of current line. */
      int gap_length = 57 - (ss_length (ss) - line_start);
      for ( ; 0 < gap_length; gap_length -= 1)
	{
	  ss_printf (ss, " ");
	}

      ss_printf (ss, "; ");
      ss_printf (ss, "%s", SOURCE (inst));
    }

  ss_printf (ss, "\n");
}



/* Return non-zero if SPIM OPCODE (e.g. Y_...) represents a conditional
   branch. */

int
opcode_is_branch (int opcode)
{
  switch (opcode)
    {
    case Y_BC1F_OP:
    case Y_BC1FL_OP:
    case Y_BC1T_OP:
    case Y_BC1TL_OP:
    case Y_BC2F_OP:
    case Y_BC2FL_OP:
    case Y_BC2T_OP:
    case Y_BC2TL_OP:
    case Y_BEQ_OP:
    case Y_BEQL_OP:
    case Y_BEQZ_POP:
    case Y_BGE_POP:
    case Y_BGEU_POP:
    case Y_BGEZ_OP:
    case Y_BGEZAL_OP:
    case Y_BGEZALL_OP:
    case Y_BGEZL_OP:
    case Y_BGT_POP:
    case Y_BGTU_POP:
    case Y_BGTZ_OP:
    case Y_BGTZL_OP:
    case Y_BLE_POP:
    case Y_BLEU_POP:
    case Y_BLEZ_OP:
    case Y_BLEZL_OP:
    case Y_BLT_POP:
    case Y_BLTU_POP:
    case Y_BLTZ_OP:
    case Y_BLTZAL_OP:
    case Y_BLTZALL_OP:
    case Y_BLTZL_OP:
    case Y_BNE_OP:
    case Y_BNEL_OP:
    case Y_BNEZ_POP:
      return (1);

    default:
      return (0);
    }
}


/* Return non-zero if SPIM OPCODE represents a nullified (e.g., Y_...L_OP)
   conditional branch. */

int
opcode_is_nullified_branch (int opcode)
{
  switch (opcode)
    {
    case Y_BC1FL_OP:
    case Y_BC1TL_OP:
    case Y_BC2FL_OP:
    case Y_BC2TL_OP:
    case Y_BEQL_OP:
    case Y_BGEZALL_OP:
    case Y_BGEZL_OP:
    case Y_BGTZL_OP:
    case Y_BLEZL_OP:
    case Y_BLTZALL_OP:
    case Y_BLTZL_OP:
    case Y_BNEL_OP:
      return (1);

    default:
      return (0);
    }
}


/* Return non-zero if SPIM OPCODE (e.g. Y_...) represents a conditional
   branch on a true condition. */

int
opcode_is_true_branch (int opcode)
{
  switch (opcode)
    {
    case Y_BC1T_OP:
    case Y_BC1TL_OP:
    case Y_BC2T_OP:
    case Y_BC2TL_OP:
      return (1);

    default:
      return (0);
    }
}



/* Return the negated equivalent of a branch opcode, i.e. bne -> be */
int
negate_branch (int opcode)
{
  switch (opcode)
    {
    case Y_BC1F_OP: return Y_BC1T_OP;
    case Y_BC1FL_OP: return Y_BC1TL_OP;

    case Y_BC1T_OP: return Y_BC1F_OP;
    case Y_BC1TL_OP: return Y_BC1FL_OP;

    case Y_BC2F_OP: return Y_BC2T_OP;
    case Y_BC2FL_OP: return Y_BC2TL_OP;

    case Y_BC2T_OP: return Y_BC2F_OP;
    case Y_BC2TL_OP: return Y_BC2FL_OP;

    case Y_BEQ_OP: return Y_BNE_OP;
    case Y_BEQL_OP: return Y_BNEL_OP;

    case Y_BGEZ_OP: return Y_BLTZ_OP;
    case Y_BGEZAL_OP: return Y_BLTZAL_OP;

    case Y_BGEZALL_OP: return Y_BLTZALL_OP;
    case Y_BGEZL_OP: return Y_BLTZL_OP;

    case Y_BGTZ_OP: return Y_BLEZ_OP;
    case Y_BGTZL_OP: return Y_BLEZL_OP;

    case Y_BLE_POP: return Y_BGEZ_OP;
    case Y_BLEZ_OP: return Y_BGTZ_OP;

    case Y_BLEZL_OP: return Y_BGTZL_OP;
    case Y_BLTZ_OP: return Y_BGEZ_OP;

    case Y_BLTZAL_OP: return Y_BGEZAL_OP;
    case Y_BLTZALL_OP: return Y_BGEZALL_OP;

    case Y_BLTZL_OP: return Y_BGEZL_OP;

    case Y_BNE_OP: return Y_BEQ_OP;
    case Y_BNEL_OP: return Y_BEQL_OP;

    default:
      error ("Trying to negate non-conditional branch");
      return 0;
    }
}

/* Return non-zero if SPIM OPCODE (e.g. Y_...) is a direct unconditional
   branch (jump). */

int
opcode_is_jump (int opcode)
{
  switch (opcode)
    {
    case Y_J_OP:
    case Y_JAL_OP:
      return (1);

    default:
      return (0);
    }
}

/* Return non-zero if SPIM OPCODE (e.g. Y_...) is a load or store. */

int
opcode_is_load_store (int opcode)
{
  switch (opcode)
    {
    case Y_LB_OP:
    case Y_LBU_OP:
    case Y_LH_OP:
    case Y_LHU_OP:
    case Y_LL_OP:
    case Y_LDC1_OP:
    case Y_LDC2_OP:
    case Y_LW_OP:
    case Y_LWC1_OP:
    case Y_LWC2_OP:
    case Y_LWL_OP:
    case Y_LWR_OP:
    case Y_SB_OP:
    case Y_SC_OP:
    case Y_SH_OP:
    case Y_SDC1_OP:
    case Y_SDC2_OP:
    case Y_SW_OP:
    case Y_SWC1_OP:
    case Y_SWC2_OP:
    case Y_SWL_OP:
    case Y_SWR_OP:
      return (1);

    default:
      return (0);
    }
}


/* Return non-zero if a breakpoint is set at ADDR. */

int
inst_is_breakpoint (mem_addr addr)
{
  if (break_inst == NULL)
    break_inst = make_r_type_inst (Y_BREAK_OP, 1, 0, 0);

  return (read_mem_inst (addr) == break_inst);
}


/* Set a breakpoint at ADDR and return the old instruction.  If the
   breakpoint cannot be set, return NULL. */

instruction *
set_breakpoint (mem_addr addr)
{
  instruction *old_inst;

  if (break_inst == NULL)
    break_inst = make_r_type_inst (Y_BREAK_OP, 1, 0, 0);

  exception_occurred = 0;
  old_inst = read_mem_inst (addr);
  if (old_inst == break_inst)
    return (NULL);

  set_mem_inst (addr, break_inst);
  if (exception_occurred)
    return (NULL);
  else
    return (old_inst);
}



/* An immediate expression has the form: SYMBOL +/- IOFFSET, where either
   part may be omitted. */

/* Make and return a new immediate expression */

imm_expr *
make_imm_expr (int offs, char *sym, int pc_rel)
{
  imm_expr *expr = (imm_expr *) xmalloc (sizeof (imm_expr));

  expr->offset = offs;
  expr->bits = 0;
  expr->pc_relative = (short)pc_rel;
  if (sym != NULL)
    expr->symbol = lookup_label (sym);
  else
    expr->symbol = NULL;
  return (expr);
}


/* Return a shallow copy of the EXPRESSION. */

imm_expr *
copy_imm_expr (imm_expr *old_expr)
{
  imm_expr *expr = (imm_expr *) xmalloc (sizeof (imm_expr));

  *expr = *old_expr;
  /*memcpy ((void*)expr, (void*)old_expr, sizeof (imm_expr));*/
  return (expr);
}


/* Return a shallow copy of an EXPRESSION that only uses the upper
   sixteen bits of the expression's value. */

imm_expr *
upper_bits_of_expr (imm_expr *old_expr)
{
  imm_expr *expr = copy_imm_expr (old_expr);

  expr->bits = 1;
  return (expr);
}


/* Return a shallow copy of the EXPRESSION that only uses the lower
   sixteen bits of the expression's value. */

imm_expr *
lower_bits_of_expr (imm_expr *old_expr)
{
  imm_expr *expr = copy_imm_expr (old_expr);

  expr->bits = -1;
  return (expr);
}


/* Return an instruction expression for a constant VALUE. */

imm_expr *
const_imm_expr (int32 value)
{
  return (make_imm_expr (value, NULL, 0));
}


/* Return a shallow copy of the EXPRESSION with the offset field
   incremented by the given amount. */

imm_expr *
incr_expr_offset (imm_expr *expr, int32 value)
{
  imm_expr *new_expr = copy_imm_expr (expr);

  new_expr->offset += value;
  return (new_expr);
}


/* Return the value of the EXPRESSION. */

int32
eval_imm_expr (imm_expr *expr)
{
  int32 value;

  if (expr->symbol == NULL)
    value = expr->offset;
  else if (SYMBOL_IS_DEFINED (expr->symbol))
    {
      value = expr->offset + expr->symbol->addr;
      if (expr->symbol->gp_flag) /* Addr is offset from $gp */
	value += gp_midpoint;
    }
  else
    {
      error ("Evaluated undefined symbol: %s\n", expr->symbol->name);
      value = 0;
    }
  if (expr->bits > 0)
    return ((value >> 16) & 0xffff);  /* Use upper bits of result */
  else if (expr->bits < 0)
    return (value & 0xffff);	      /* Use lower bits */
  else
    return (value);
}


/* Print the EXPRESSION. */

static void
format_imm_expr (str_stream *ss, imm_expr *expr, int base_reg)
{
  if (expr->symbol != NULL)
    {
      ss_printf (ss, "%s", expr->symbol->name);
    }

  if (expr->pc_relative)
    ss_printf (ss, "-0x%08x", (unsigned int)-expr->offset);
  else if (expr->offset < -10)
    ss_printf (ss, "-%d (-0x%08x)", -expr->offset, (unsigned int)-expr->offset);
  else if (expr->offset > 10)
    ss_printf (ss, "+%d (0x%08x)", expr->offset, (unsigned int)expr->offset);

  if (base_reg != -1 && expr->symbol != NULL &&
      (expr->offset > 10 || expr->offset < -10))
    {
      if (expr->offset == 0 && base_reg != 0)
	ss_printf (ss, "+0");

      if (expr->offset != 0 || base_reg != 0)
	ss_printf (ss, "($%d)", base_reg);
    }
}


/* Return non-zero if the EXPRESSION is a constant 0. */

int
zero_imm (imm_expr *expr)
{
  return (expr->offset == 0 && expr->symbol == NULL);
}



/* Return an address expression of the form SYMBOL +/- IOFFSET (REGISTER).
   Any of the three parts may be omitted. */

addr_expr *
make_addr_expr (int offs, char *sym, int reg_no)
{
  addr_expr *expr = (addr_expr *) xmalloc (sizeof (addr_expr));
  label *lab;

  if (reg_no == 0 && sym != NULL && (lab = lookup_label (sym))->gp_flag)
    {
      expr->reg_no = REG_GP;
      expr->imm = make_imm_expr (offs + lab->addr - gp_midpoint, NULL, 0);
    }
  else
    {
      expr->reg_no = (unsigned char)reg_no;
      expr->imm = make_imm_expr (offs, (sym ? str_copy (sym) : sym), 0);
    }
  return (expr);
}


imm_expr *
addr_expr_imm (addr_expr *expr)
{
  return (expr->imm);
}


int
addr_expr_reg (addr_expr *expr)
{
  return (expr->reg_no);
}



/* Map between a SPIM instruction and the binary representation of the
   instruction. */


/* Maintain a table mapping from internal opcode (i_opcode) to actual
   opcode (a_opcode).  Table must be sorted before first use since its
   entries are alphabetical on name, not ordered by opcode. */


/* Map from internal opcode -> real opcode */

static name_val_val i_opcode_tbl [] = {
#undef OP
#define OP(NAME, I_OPCODE, TYPE, A_OPCODE) {NAME, I_OPCODE, (int)A_OPCODE},
#include "op.h"
};


/* Sort the opcode table on their key (the interal opcode value). */

static void
sort_i_opcode_table ()
{
  qsort (i_opcode_tbl,
	 sizeof (i_opcode_tbl) / sizeof (name_val_val),
	 sizeof (name_val_val),
	 (QSORT_FUNC) compare_pair_value);
}


#define REGS(R,O) (((R) & 0x1f) << O)


int32
inst_encode (instruction *inst)
{
  int32 a_opcode = 0;
  name_val_val *entry;

  if (inst == NULL)
    return (0);

  entry = map_int_to_name_val_val (i_opcode_tbl,
				sizeof (i_opcode_tbl) / sizeof (name_val_val),
				OPCODE (inst));
  if (entry == NULL)
    return 0;

  a_opcode = entry->value2;
  entry = map_int_to_name_val_val (name_tbl,
				sizeof (name_tbl) / sizeof (name_val_val),
				OPCODE (inst));

  switch (entry->value2)
    {
    case BC_TYPE_INST:
      return (a_opcode
	      | REGS (CC (inst) << 2, 16)
	      | (IOFFSET (inst) & 0xffff));

    case B1_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | (IOFFSET (inst) & 0xffff));

    case I1s_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | (IMM (inst) & 0xffff));

    case I1t_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16)
	      | (IMM (inst) & 0xffff));

    case I2_TYPE_INST:
    case B2_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16)
	      | (IMM (inst) & 0xffff));

    case I2a_TYPE_INST:
      return (a_opcode
	      | REGS (BASE (inst), 21)
	      | REGS (RT (inst), 16)
	      | (IOFFSET (inst) & 0xffff));

    case R1s_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21));

    case R1d_TYPE_INST:
      return (a_opcode
	      | REGS (RD (inst), 11));

    case R2td_TYPE_INST:
      return (a_opcode
	      | REGS (RT (inst), 16)
	      | REGS (RD (inst), 11));

    case R2st_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16));

    case R2ds_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RD (inst), 11));

    case R2sh_TYPE_INST:
      return (a_opcode
	      | REGS (RT (inst), 16)
	      | REGS (RD (inst), 11)
	      | REGS (SHAMT (inst), 6));

    case R3_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16)
	      | REGS (RD (inst), 11));

    case R3sh_TYPE_INST:
      return (a_opcode
	      | REGS (RS (inst), 21)
	      | REGS (RT (inst), 16)
	      | REGS (RD (inst), 11));

    case FP_I2a_TYPE_INST:
      return (a_opcode
	      | REGS (BASE (inst), 21)
	      | REGS (RT (inst), 16)
	      | (IOFFSET (inst) & 0xffff));

    case FP_R2ds_TYPE_INST:
      return (a_opcode
	      | REGS (FS (inst), 11)
	      | REGS (FD (inst), 6));

    case FP_R2ts_TYPE_INST:
      return (a_opcode
	      | REGS (RT (inst), 16)
	      | REGS (FS (inst), 11));

    case FP_CMP_TYPE_INST:
      return (a_opcode
	      | REGS (FT (inst), 16)
	      | REGS (FS (inst), 11)
	      | (COND (inst) & 0xf));

    case FP_R3_TYPE_INST:
      return (a_opcode
	      | REGS (FT (inst), 16)
	      | REGS (FS (inst), 11)
	      | REGS (FD (inst), 6));

    case FP_MOVC_TYPE_INST:
      return (a_opcode
	      | REGS (CC (inst), 18)
	      | REGS (FS (inst), 11)
	      | REGS (FD (inst), 6));

    case J_TYPE_INST:
      return (a_opcode
	      | TARGET (inst));

    case NOARG_TYPE_INST:
      return (a_opcode);

    default:
      fatal_error ("Unknown instruction type in inst_encoding\n");
      return (0);		/* Not reached */
    }
}


/* Maintain a table mapping from actual opcode to interal opcode.
   Table must be sorted before first use since its entries are
   alphabetical on name, not ordered by opcode. */


/* Map from internal opcode -> real opcode */

static name_val_val a_opcode_tbl [] = {
#undef OP
#define OP(NAME, I_OPCODE, TYPE, A_OPCODE) {NAME, (int)A_OPCODE, (int)I_OPCODE},
#include "op.h"
};


/* Sort the opcode table on their key (the interal opcode value). */

static void
sort_a_opcode_table ()
{
  qsort (a_opcode_tbl,
	 sizeof (a_opcode_tbl) / sizeof (name_val_val),
	 sizeof (name_val_val),
	 (QSORT_FUNC) compare_pair_value);
}



instruction *
inst_decode (int32 val)
{
  int32 a_opcode = val & 0xfc000000;
  name_val_val *entry;
  int32 i_opcode;

  /* Field classes: (opcode is continued in other part of instruction): */
  if (a_opcode == 0 || a_opcode == 0x70000000) /* SPECIAL or SPECIAL2 */
    a_opcode |= (val & 0x3f);
  else if (a_opcode == 0x04000000)		/* REGIMM */
    a_opcode |= (val & 0x001f0000);
  else if (a_opcode == 0x40000000)		/* COP0 */
    a_opcode |= (val & 0x03e00000) | (val & 0x1f);
  else if (a_opcode == 0x44000000)		/* COP1 */
    {
      a_opcode |= (val & 0x03e00000);
      if ((val & 0xff000000) == 0x45000000)
	a_opcode |= (val & 0x00010000);		/* BC1f/t */
      else
	a_opcode |= (val & 0x3f);
    }
  else if (a_opcode == 0x48000000		/* COPz */
	   || a_opcode == 0x4c000000)
    a_opcode |= (val & 0x03e00000);


  entry = map_int_to_name_val_val (a_opcode_tbl,
				sizeof (a_opcode_tbl) / sizeof (name_val_val),
				a_opcode);
  if (entry == NULL)
    return (mk_r_inst (val, 0, 0, 0, 0, 0)); /* Invalid inst */

  i_opcode = entry->value2;

  switch (map_int_to_name_val_val (name_tbl,
				sizeof (name_tbl) / sizeof (name_val_val),
				i_opcode)->value2)
    {
    case BC_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), BIN_RT(val),
			 val & 0xffff));

    case B1_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), 0, val & 0xffff));

    case I1s_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), 0, val & 0xffff));

    case I1t_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), BIN_RT(val),
			 val & 0xffff));

    case I2_TYPE_INST:
    case B2_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), BIN_RT(val),
			 val & 0xffff));

    case I2a_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_RS(val), BIN_RT(val),
			 val & 0xffff));

    case R1s_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_RS(val), 0, 0, 0));

    case R1d_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, 0, BIN_RD(val), 0));

    case R2td_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, BIN_RT(val), BIN_RD(val), 0));

    case R2st_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_RS(val), BIN_RT(val), 0, 0));

    case R2ds_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_RS(val), 0, BIN_RD(val), 0));

    case R2sh_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, BIN_RT(val), BIN_RD(val), BIN_SA(val)));

    case R3_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_RS(val), BIN_RT(val), BIN_RD(val), 0));

    case R3sh_TYPE_INST:
      return(mk_r_inst (val, i_opcode, BIN_RS(val), BIN_RT(val), BIN_RD(val), 0));

    case FP_I2a_TYPE_INST:
      return (mk_i_inst (val, i_opcode, BIN_BASE(val), BIN_FT(val), val & 0xffff));

    case FP_R2ds_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_FS(val), 0, BIN_FD(val), 0));

    case FP_R2ts_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, BIN_RT(val), BIN_FS(val), 0));

    case FP_CMP_TYPE_INST:
      {
	instruction *inst = mk_r_inst (val, i_opcode, BIN_FS (val), BIN_FT (val), 0, 0);
	SET_COND (inst, val & 0xf);
	return (inst);
      }

    case FP_R3_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_FS(val), BIN_FT(val), BIN_FD(val), 0));

    case FP_MOVC_TYPE_INST:
      return (mk_r_inst (val, i_opcode, BIN_FS(val), BIN_RT(val), BIN_FD(val), 0));

    case J_TYPE_INST:
      return (mk_j_inst (val, i_opcode, val & 0x2ffffff));


    case NOARG_TYPE_INST:
      return (mk_r_inst (val, i_opcode, 0, 0, 0, 0));

    default:
      return (mk_r_inst (val, 0, 0, 0, 0, 0)); /* Invalid inst */
    }
}


static instruction *
mk_r_inst (int32 val, int opcode, int rs, int rt, int rd, int shamt)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE (inst, opcode);
  SET_RS (inst, rs);
  SET_RT (inst, rt);
  SET_RD (inst, rd);
  SET_SHAMT (inst, shamt);
  SET_ENCODING (inst, val);
  SET_EXPR (inst, NULL);
  return (inst);
}


static instruction *
mk_i_inst (int32 val, int opcode, int rs, int rt, int offset)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE (inst, opcode);
  SET_RS (inst, rs);
  SET_RT (inst, rt);
  SET_IOFFSET (inst, offset);
  SET_ENCODING (inst, val);
  SET_EXPR (inst, NULL);
  return (inst);
}

static instruction *
mk_j_inst (int32 val, int opcode, int target)
{
  instruction *inst = (instruction *) zmalloc (sizeof (instruction));

  SET_OPCODE (inst, opcode);
  SET_TARGET (inst, target);
  SET_ENCODING (inst, val);
  SET_EXPR (inst, NULL);
  return (inst);
}



/* Code to test encode/decode of instructions. */

void
test_assembly (instruction *inst)
{
  instruction *new_inst = inst_decode (inst_encode (inst));

  inst_cmp (inst, new_inst);
  free_inst (new_inst);
}


static void
inst_cmp (instruction *inst1, instruction *inst2)
{
  static str_stream ss;

  ss_clear (&ss);
  if (memcmp (inst1, inst2, sizeof (instruction) - 4) != 0)
    {
      ss_printf (&ss, "=================== Not Equal ===================\n");
      format_an_inst (&ss, inst1, 0);
      format_an_inst (&ss, inst2, 0);
      ss_printf (&ss, "=================== Not Equal ===================\n");
    }
}
/* SPIM S20 MIPS simulator.
   Description of a SPIM S20 instruction.

   Copyright (C) 1990-2004 by James Larus (larus@cs.wisc.edu).
   ALL RIGHTS RESERVED.

   SPIM is distributed under the following conditions:

     You may make copies of SPIM for your own use and modify those copies.

     All copies of SPIM must retain my name and copyright notice.

     You may not sell SPIM or distributed SPIM in conjunction with a
     commerical product or service without the expressed written consent of
     James Larus.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   PURPOSE. */


/* $Header: /Software/SPIM/src/inst.h 22    11/27/04 11:03a Larus $
*/


/* Represenation of the expression that produce a value for an instruction's
   immediate field.  Immediates have the form: label +/- offset. */

typedef struct immexpr
{
  int offset;			/* Offset from symbol */
  struct lab *symbol;		/* Symbolic label */
  short bits;			/* > 0 => 31..16, < 0 => 15..0 */
  short pc_relative;		/* Non-zero => offset from label in code */
} imm_expr;


/* Representation of the expression that produce an address for an
   instruction.  Address have the form: label +/- offset (register). */

typedef struct addrexpr
{
  unsigned char reg_no;		/* Register number */
  imm_expr *imm;		/* The immediate part */
} addr_expr;



/* Representation of an instruction. Store the instruction fields in an
   overlapping manner similar to the real encoding (but not identical, to
   speed decoding in C code, as opposed to hardware).. */

typedef struct inst_s
{
  short opcode;

  union
    {
      /* R-type or I-type: */
      struct
	{
	  unsigned char rs;
	  unsigned char rt;

	  union
	    {
	      short imm;

	      struct
		{
		  unsigned char rd;
		  unsigned char shamt;
		} r;
	    } r_i;
	} r_i;

      /* J-type: */
      mem_addr target;
    } r_t;

  int32 encoding;
  imm_expr *expr;
  char *source_line;
} instruction;


#define OPCODE(INST)		(INST)->opcode
#define SET_OPCODE(INST, VAL)	(INST)->opcode = (short)(VAL)


#define RS(INST)		(INST)->r_t.r_i.rs
#define SET_RS(INST, VAL)	(INST)->r_t.r_i.rs = (unsigned char)(VAL)

#define RT(INST)		(INST)->r_t.r_i.rt
#define SET_RT(INST, VAL)	(INST)->r_t.r_i.rt = (unsigned char)(VAL)

#define RD(INST)		(INST)->r_t.r_i.r_i.r.rd
#define SET_RD(INST, VAL)	(INST)->r_t.r_i.r_i.r.rd = (unsigned char)(VAL)


#define FS(INST)		RD(INST)
#define SET_FS(INST, VAL)	SET_RD(INST, VAL)

#define FT(INST)		RT(INST)
#define SET_FT(INST, VAL)	SET_RT(INST, VAL)

#define FD(INST)		SHAMT(INST)
#define SET_FD(INST, VAL)	SET_SHAMT(INST, VAL)


#define SHAMT(INST)		(INST)->r_t.r_i.r_i.r.shamt
#define SET_SHAMT(INST, VAL)	(INST)->r_t.r_i.r_i.r.shamt = (unsigned char)(VAL)

#define IMM(INST)		(INST)->r_t.r_i.r_i.imm
#define SET_IMM(INST, VAL)	(INST)->r_t.r_i.r_i.imm = (short)(VAL)


#define BASE(INST)		RS(INST)
#define SET_BASE(INST, VAL)	SET_RS(INST, VAL)

#define IOFFSET(INST)		IMM(INST)
#define SET_IOFFSET(INST, VAL)	SET_IMM(INST, VAL)
#define IDISP(INST)		(SIGN_EX (IOFFSET (INST) << 2))


#define COND(INST)		RS(INST)
#define SET_COND(INST, VAL)	SET_RS(INST, VAL)

#define CC(INST)		(RT(INST) >> 2)
#define ND(INST)		((RT(INST) & 0x2) >> 1)
#define TF(INST)		(RT(INST) & 0x1)


#define TARGET(INST)		(INST)->r_t.target
#define SET_TARGET(INST, VAL)	(INST)->r_t.target = (mem_addr)(VAL)

#define ENCODING(INST)		(INST)->encoding
#define SET_ENCODING(INST, VAL)	(INST)->encoding = (int32)(VAL)

#define EXPR(INST)		(INST)->expr
#define SET_EXPR(INST, VAL)	(INST)->expr = (imm_expr*)(VAL)

#define SOURCE(INST)		(INST)->source_line
#define SET_SOURCE(INST, VAL)	(INST)->source_line = (char *)(VAL)


#define COND_UN		0x1
#define COND_EQ		0x2
#define COND_LT		0x4
#define COND_IN		0x8

/* Minimum and maximum values that fit in instruction's imm field */
#define IMM_MIN		0xffff8000
#define IMM_MAX 	0x00007fff

#define UIMM_MIN  	(unsigned)0
#define UIMM_MAX  	((unsigned)((1<<16)-1))



/* Raise an exception! */

extern int exception_occurred;

#define RAISE_EXCEPTION(EXCODE, MISC)					\
	{								\
	raise_exception(EXCODE);					\
	MISC;								\
	}								\


#define RAISE_INTERRUPT(LEVEL)						\
	{								\
	/* Set IP (pending) bit for interrupt level. */			\
	CP0_Cause |= (1 << ((LEVEL) + 8));				\
	}								\

#define CLEAR_INTERRUPT(LEVEL)						\
	{								\
	/* Clear IP (pending) bit for interrupt level. */		\
	CP0_Cause &= ~(1 << ((LEVEL) + 8));				\
	}								\

/* Recognized exceptions: */

#define ExcCode_Int	0	/* Interrupt */
#define ExcCode_Mod	1	/* TLB modification (not implemented) */
#define ExcCode_TLBL	2	/* TLB exception (not implemented) */
#define ExcCode_TLBS	3	/* TLB exception (not implemented) */
#define ExcCode_AdEL	4	/* Address error (load/fetch) */
#define ExcCode_AdES	5	/* Address error (store) */
#define ExcCode_IBE	6	/* Bus error, instruction fetch */
#define ExcCode_DBE	7	/* Bus error, data reference */
#define ExcCode_Sys	8	/* Syscall exception */
#define ExcCode_Bp	9	/* Breakpoint exception */
#define ExcCode_RI	10	/* Reserve instruction */
#define ExcCode_CpU	11	/* Coprocessor unusable */
#define ExcCode_Ov	12	/* Arithmetic overflow */
#define ExcCode_Tr	13	/* Trap */
#define ExcCode_FPE	15	/* Floating point */
#define ExcCode_C2E	18	/* Coprocessor 2 (not impelemented) */
#define ExcCode_MDMX	22	/* MDMX unusable (not implemented) */
#define ExcCode_WATCH	23	/* Reference to Watch (not impelemented) */
#define ExcCode_MCheck	24	/* Machine check (not implemented) */
#define ExcCode_CacheErr 30	/* Cache error (not impelemented) */



/* Fields in binary representation of instructions: */

#define BIN_REG(V,O)	(((V) >> O) & 0x1f)
#define BIN_RS(V)	(BIN_REG(V, 21))
#define BIN_RT(V)	(BIN_REG(V, 16))
#define BIN_RD(V)	(BIN_REG(V, 11))
#define BIN_SA(V)	(BIN_REG(V, 6))

#define BIN_BASE(V)	(BIN_REG(V, 21))
#define BIN_FT(V)	(BIN_REG(V, 16))
#define BIN_FS(V)	(BIN_REG(V, 11))
#define BIN_FD(V)	(BIN_REG(V, 6))



/* Exported functions: */

imm_expr *addr_expr_imm (addr_expr *expr);
int addr_expr_reg (addr_expr *expr);
imm_expr *const_imm_expr (int32 value);
imm_expr *copy_imm_expr (imm_expr *old_expr);
instruction *copy_inst (instruction *inst);
mem_addr current_text_pc ();
int32 eval_imm_expr (imm_expr *expr);
void format_an_inst (str_stream *ss, instruction *inst, mem_addr addr);
void free_inst (instruction *inst);
void i_type_inst (int opcode, int rt, int rs, imm_expr *expr);
void i_type_inst_free (int opcode, int rt, int rs, imm_expr *expr);
void increment_text_pc (int delta);
imm_expr *incr_expr_offset (imm_expr *expr, int32 value);
void initialize_inst_tables ();
instruction *inst_decode (int32 value);
int32 inst_encode (instruction *inst);
int inst_is_breakpoint (mem_addr addr);
void j_type_inst (int opcode, imm_expr *target);
void k_text_begins_at_point (mem_addr addr);
imm_expr *lower_bits_of_expr (imm_expr *old_expr);
addr_expr *make_addr_expr (int offs, char *sym, int reg_no);
imm_expr *make_imm_expr (int offs, char *sym, int pc_rel);
int opcode_is_branch (int opcode);
int opcode_is_nullified_branch (int opcode);
int opcode_is_true_branch (int opcode);
int negate_branch (int opcode);
int opcode_is_jump (int opcode);
int opcode_is_load_store (int opcode);
void print_inst (mem_addr addr);
void r_co_type_inst (int opcode, int fd, int fs, int ft);
void r_cond_type_inst (int opcode, int fs, int ft, int cc);
void r_sh_type_inst (int opcode, int rd, int rt, int shamt);
void r_type_inst (int opcode, int rd, int rs, int rt);
void raise_exception(int excode);
instruction *set_breakpoint (mem_addr addr);
void store_instruction (instruction *inst);
void text_begins_at_point (mem_addr addr);
imm_expr *upper_bits_of_expr (imm_expr *old_expr);
void user_kernel_text_segment (int to_kernel);
int zero_imm (imm_expr *expr);
